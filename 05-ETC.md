## 개발상식, 기타

<details>
  <summary><h3>1. 가상화가 무엇이고, 이것이 가상머신과 어떠한 차이가 있는지 설명해 주세요.</h3></summary>

### 가상화란?

가상화(Virtualization)는 물리적인 하드웨어 자원을 소프트웨어를 통해 추상화하여 여러 개의 가상 환경을 생성하는 기술입니다. 이를 통해 하나의 물리적 시스템에서 여러 운영 체제나 애플리케이션을 동시에 실행할 수 있습니다. 가상화는 자원의 효율적인 활용, 비용 절감, 유연성 향상을 목적으로 사용됩니다. 예를 들어, 서버 가상화는 하나의 물리 서버를 여러 가상 서버로 나누어 각각 독립적인 작업을 수행하게 할 수 있습니다.

가상화의 주요 유형에는 다음과 같은 것들이 있습니다:
- **서버 가상화**: 물리 서버를 여러 가상 서버로 분할.
- **데스크톱 가상화**: 가상 데스크톱 환경(VDI)을 제공.
- **네트워크 가상화**: 네트워크 자원을 가상 네트워크로 추상화.
- **스토리지 가상화**: 물리적 저장소를 가상 스토리지 풀(pool)로 관리.

가상화의 핵심 구성 요소는 **하이퍼바이저(Hypervisor)**로, 물리 하드웨어와 가상 환경 사이에서 자원을 관리하고分配(분배)하는 역할을 합니다. 하이퍼바이저는 Type 1(베어메탈)과 Type 2(호스티드)로 나뉩니다.

---

### 가상머신이란?

가상머신(Virtual Machine, VM)은 가상화를 통해 생성된 개별 가상 환경을 의미합니다. 즉, 가상머신은 가상화 기술이 구현된 결과물 중 하나입니다. 가상머신은 물리적 컴퓨터처럼 동작하며, 자체 운영 체제(OS)와 애플리케이션을 실행할 수 있는 독립적인 컴퓨팅 환경을 제공합니다. 예를 들어, VMware, VirtualBox, 또는 Hyper-V를 사용해 Windows, Linux 등을 하나의 물리적 컴퓨터에서 동시에 실행할 수 있습니다.

가상머신은 다음과 같은 특징을 가집니다:
- **독립성**: 각 VM은 서로 격리되어 있어 한 VM의 장애가 다른 VM에 영향을 미치지 않음.
- **자원 할당**: CPU, 메모리, 저장소 등 물리 자원을 하이퍼바이저가 분배.
- **유연성**: 필요에 따라 VM을 생성, 삭제, 이동 가능.

---

### 가상화와 가상머신의 차이

| **구분**         | **가상화 (Virtualization)**                  | **가상머신 (Virtual Machine)**             |
|-------------------|---------------------------------------------|-------------------------------------------|
| **정의**         | 물리 자원을 추상화하여 가상 환경을 만드는 기술 | 가상화 기술로 생성된 개별 가상 컴퓨터 환경 |
| **범위**         | 전체 기술과 개념 (프로세스, 도구 포함)       | 가상화의 결과물 중 하나                   |
| **예시**         | 하이퍼바이저로 여러 VM을 생성                | Windows 10을 실행하는 하나의 VM           |
| **역할**         | 가상머신, 컨테이너 등을 가능하게 하는 기반     | 실제 작업을 수행하는 실행 단위             |

쉽게 말해, **가상화는 집을 짓는 건축 기술**이라면, **가상머신은 그 기술로 지어진 개별 집**에 비유할 수 있습니다. 가상화는 VM뿐만 아니라 컨테이너(예: Docker)와 같은 다른 가상 환경도 지원할 수 있다는 점에서 더 넓은 개념입니다.

---

### 결론

가상화는 기술적 기반이며, 가상머신은 그 기반 위에서 만들어진 구체적인 실행 환경입니다. 가상화를 통해 가상머신을 생성함으로써 자원을 효율적으로 활용하고, 다양한 운영 체제를 동시에 운영할 수 있는 유연성을 확보할 수 있습니다. 이 둘은 상호 보완적인 관계로, 가상화 없이는 가상머신이 존재할 수 없습니다.

## 추가 질문 : 가상화는 왜 사용한다고 생각하시나요?

#### 1. **자원 효율성 향상**
- 물리적 하드웨어를 여러 가상 환경으로 나누어 사용함으로써 자원의 활용도를 극대화합니다.
- 예: 하나의 서버가 20%만 사용되던 상황에서, 가상화를 통해 남은 80%를 다른 작업에 할당 가능.

#### 2. **비용 절감**
- 여러 물리적 장비를 구매하는 대신, 단일 하드웨어에서 여러 가상 환경을 운영하여 하드웨어 구매 및 유지보수 비용을 줄입니다.
- 전력 소비, 냉각 비용, 공간 비용도 절감됩니다.

#### 3. **유연성과 확장성**
- 필요에 따라 가상머신(VM)을 빠르게 생성, 삭제, 수정할 수 있어 변화하는 요구사항에 신속히 대응 가능합니다.
- 예: 트래픽이 증가하면 VM을 추가로 배포해 부하를 분산.

#### 4. **격리와 안정성**
- 각 가상 환경은 독립적으로 운영되므로, 한 환경의 장애가 다른 환경에 영향을 미치지 않습니다.
- 애플리케이션 테스트나 개발 환경에서 오류를 격리하는 데 유용합니다.

#### 5. **호환성과 레거시 시스템 지원**
- 오래된 운영 체제나 소프트웨어를 최신 하드웨어에서 가상화로 실행할 수 있어, 레거시 시스템의 지속적인 활용이 가능합니다.
- 예: Windows XP를 지원하지 않는 새 하드웨어에서 VM으로 실행.

#### 6. **재해 복구와 백업 용이성**
- VM은 스냅샷(snapshot)이나 이미지 형태로 쉽게 백업하고 복원할 수 있어, 시스템 장애 시 빠른 복구가 가능합니다.
- 데이터 센터 간 VM 이동으로 재해 복구(Disaster Recovery) 전략을 강화할 수 있습니다.

#### 7. **개발 및 테스트 환경 최적화**
- 개발자들은 동일한 물리 시스템에서 서로 다른 환경(예: Linux, Windows)을 동시에 테스트할 수 있습니다.
- 실험적인 설정이나 소프트웨어를 안전하게 시험 가능.

#### 8. **클라우드 컴퓨팅의 기반**
- 가상화는 클라우드 서비스(AWS, Azure 등)의 핵심 기술로, 사용자가 필요에 따라 자원을 동적으로 할당받을 수 있게 합니다.

---

### 결론
가상화는 자원을 효율적으로 사용하면서도 비용을 줄이고, 유연성, 안정성, 확장성을 제공하는 강력한 솔루션입니다. 기업은 이를 통해 IT 인프라를 최적화하고, 개발자는 더 나은 작업 환경을 구축하며, 클라우드 시대의 요구를 충족할 수 있습니다.

<ul>
<li> 그렇다면 Docker는 둘 중 어디에 속하나요? 왜 사람들이 Docker를 많이 채택할까요?</li>
### Docker는 가상화와 가상머신 중 어디에 속하나?

Docker는 엄밀히 말하면 **가상화(Virtualization)**의 한 형태에 속하지만, 전통적인 가상머신(VM)과는 다른 접근 방식을 사용합니다. 이를 이해하려면 Docker가 동작하는 방식과 가상머신의 차이를 살펴봐야 합니다.

#### Docker의 위치
- **컨테이너 가상화**: Docker는 **컨테이너(Container)**라는 경량화된 가상 환경을 제공합니다. 이는 운영 체제 수준의 가상화(OS-level Virtualization)로 분류됩니다.
- **가상머신과의 차이**:
    - 가상머신(VM): 하이퍼바이저를 통해 전체 운영 체제(OS)를 포함한 독립적인 가상 하드웨어 환경을 생성.
    - Docker: 호스트 OS의 커널을 공유하며, 애플리케이션과 그 의존성(라이브러리, 설정 등)만 격리된 컨테이너에 패키징.
- **결론**: Docker는 가상화 기술의 하위 범주인 "컨테이너 기반 가상화"에 속하며, VM처럼 완전한 OS를 가상화하지 않습니다.

#### 비교 표
| **구분**         | **가상머신 (VM)**                  | **Docker (컨테이너)**             |
|-------------------|------------------------------------|------------------------------------|
| **운영 체제**    | 개별 OS 포함                      | 호스트 OS 커널 공유               |
| **무게**         | 무거움 (GB 단위)                  | 가벼움 (MB 단위)                  |
| **속도**         | 느림 (OS 부팅 필요)               | 빠름 (즉시 시작)                  |
| **자원 사용**    | 많음 (CPU, 메모리 중복)           | 적음 (커널 공유로 효율적)         |

---

### 왜 사람들이 Docker를 많이 채택할까요?

Docker는 전통적인 VM 대비 여러 장점을 제공하며, 현대 소프트웨어 개발 및 배포 환경에 적합하기 때문에 널리 채택되고 있습니다. 주요 이유는 다음과 같습니다:

#### 1. **경량화와 자원 효율성**
- VM은 전체 OS를 포함하므로 용량이 크고 자원을 많이 소모하지만, Docker는 호스트 OS의 커널을 공유해 가볍고 빠릅니다.
- 예: VM은 몇 GB일 수 있지만, Docker 컨테이너는 몇 MB 수준.

#### 2. **빠른 시작과 배포**
- 컨테이너는 OS 부팅 과정 없이 애플리케이션만 실행하므로 초 단위로 시작됩니다.
- 개발부터 배포까지의 속도가 빨라 CI/CD(지속적 통합/배포) 파이프라인에 적합.

#### 3. **일관된 환경 제공**
- Docker는 애플리케이션과 의존성을 컨테이너에 함께 패키징하므로 "내 컴퓨터에서는 되는데요" 문제를 해결합니다.
- 개발, 테스트, 프로덕션 환경 간 일관성을 보장.

#### 4. **마이크로서비스 아키텍처 지원**
- Docker는 각 서비스를 독립적인 컨테이너로 실행하기에, 마이크로서비스 설계에 이상적입니다.
- 예: 웹 서버, 데이터베이스, 캐시를 각각 별도 컨테이너로 관리.

#### 5. **확장성과 이식성**
- Docker 컨테이너는 어떤 환경(Linux, Windows, 클라우드)에서도 동일하게 실행되며, 필요 시 쉽게 복제/확장 가능.
- Kubernetes 같은 오케스트레이션 도구와 결합해 대규모 배포에 활용.

#### 6. **생태계와 커뮤니티**
- Docker Hub에서 수많은 공식/커뮤니티 이미지를 제공해 개발 속도를 높임.
- 오픈소스 기반으로 활발한 커뮤니티와 풍부한 문서 지원.

#### 7. **비용 절감**
- 자원 사용이 적어 동일한 하드웨어에서 더 많은 컨테이너를 실행 가능.
- 클라우드 환경에서 VM 대비 비용 효율적.

---

### 결론

Docker는 **컨테이너 가상화**라는 가상화의 한 형태로, VM보다 가볍고 빠르며 현대적인 요구(속도, 이식성, 확장성)에 부합합니다. 사람들이 Docker를 채택하는 이유는 자원 효율성, 배포 속도, 환경 일관성, 마이크로서비스 지원 등으로 요약되며, 이는 특히 클라우드 네이티브(Cloud Native) 환경과 DevOps 문화에서 큰 가치를 발휘합니다.

<li> 하나의 Host OS에서 돌아간다면 충분히 한 컨테이너가 다른 컨테이너에 간섭할 수 있는 위험이 있지 않을까요? 이를 어떻게 방어할 수 있을까요?</li>

### Docker 컨테이너 간 간섭 위험

맞습니다. Docker 컨테이너가 동일한 호스트 OS의 커널을 공유하기 때문에, 전통적인 가상머신(VM)에 비해 격리 수준이 낮아 보일 수 있습니다. 이로 인해 한 컨테이너가 다른 컨테이너에 간섭할 가능성이 이론적으로 존재합니다. 예를 들어, 잘못된 설정이나 보안 취약점으로 인해 자원 독점, 데이터 유출, 또는 시스템 장애가 발생할 수 있습니다. 하지만 Docker는 이를 방어하기 위한 여러 메커니즘을 제공하며, 추가적인 설정으로 위험을 최소화할 수 있습니다.

---

### 컨테이너 간 간섭 가능성

1. **자원 경쟁**
    - 컨테이너가 CPU, 메모리, 디스크 I/O를 과도하게 사용하면 다른 컨테이너의 성능에 영향을 줄 수 있음.

2. **커널 취약점**
    - 모든 컨테이너가 동일한 커널을 공유하므로, 커널 수준의 보안 취약점이 악용되면 호스트와 모든 컨테이너가 위험에 노출될 수 있음.

3. **네트워크 간섭**
    - 네트워크 설정 오류로 인해 컨테이너 간 데이터가 노출되거나 충돌 가능성.

4. **파일 시스템 접근**
    - 부적절한 마운트 설정으로 호스트 파일 시스템이나 다른 컨테이너의 데이터에 접근할 수 있음.

---

### Docker의 기본 방어 메커니즘

Docker는 기본적으로 다음과 같은 기술을 사용해 컨테이너 간 간섭을 방지합니다:

1. **리눅스 네임스페이스 (Namespaces)**
    - 각 컨테이너는 독립적인 네임스페이스를 가져 프로세스, 네트워크, 파일 시스템 등이 격리됨.
    - 예: PID 네임스페이스로 인해 한 컨테이너는 다른 컨테이너의 프로세스를 볼 수 없음.

2. **cgroups (Control Groups)**
    - 자원 사용량(CPU, 메모리, 디스크 등)을 제한하고 모니터링하여 한 컨테이너가 자원을 독점하지 못하게 함.

3. **리눅스 보안 모듈**
    - SELinux나 AppArmor 같은 도구를 통해 컨테이너의 권한을 제한하고, 불필요한 시스템 호출을 차단.

4. **사용자 네임스페이스**
    - 컨테이너 내 루트(root) 사용자가 호스트의 실제 루트와 매핑되지 않도록 설정 가능.

5. **네트워크 격리**
    - 기본적으로 각 컨테이너는 독립적인 네트워크 스택을 가지며, 브리지 네트워크로 상호 격리됨.

---

### 추가 방어 방법

Docker의 기본 격리만으로는 부족할 수 있으므로, 다음과 같은 추가 조치로 보안을 강화할 수 있습니다:

1. **자원 제한 명시**
    - Docker 실행 시 `--cpu`, `--memory`, `--blkio-weight` 옵션으로 각 컨테이너의 자원 한계를 설정.
    - 예: `docker run --memory="512m" --cpus="0.5" my-container`

2. **네트워크 보안 강화**
    - 사용자 정의 네트워크를 생성하고, 방화벽 규칙(iptables)을 설정해 컨테이너 간 통신을 제한.
    - `--network` 옵션으로 불필요한 네트워크 연결 차단.

3. **최소 권한 원칙 적용**
    - 컨테이너를 비루트(non-root) 사용자로 실행: `--user` 옵션 사용.
    - 불필요한 기능 제거: `--cap-drop`으로 특정 시스템 권한 제거.

4. **호스트 OS 보안 강화**
    - 커널을 최신 버전으로 유지하고, 알려진 취약점을 패치.
    - SELinux/AppArmor 활성화로 추가적인 접근 제어.

5. **컨테이너 이미지 보안**
    - 신뢰할 수 있는 소스(Docker Hub 공식 이미지 등)에서 이미지 다운로드.
    - 이미지 스캔 도구(예: Trivy, Clair)를 사용해 취약점 점검.

6. **가상머신과의 결합**
    - 민감한 작업은 Docker를 VM 내에서 실행해 커널 수준의 격리를 추가.
    - 예: AWS EC2 내에서 Docker 사용.

7. **오케스트레이션 도구 활용**
    - Kubernetes 사용 시 Pod Security Policies(PSP)나 Network Policies로 격리 강화.

---

### 결론

Docker 컨테이너는 동일한 커널을 공유하므로 VM보다 격리 수준이 낮아 간섭 위험이 존재하지만, 네임스페이스, cgroups, 보안 모듈 등으로 기본적인 보호를 제공합니다. 추가적으로 자원 제한, 네트워크 설정, 권한 관리, 이미지 보안 등을 통해 위험을 크게 줄일 수 있습니다. 민감한 환경에서는 VM과 Docker를 결합하거나 강력한 보안 정책을 적용하는 것이 최적의 방어 전략일 수 있습니다. 이를 통해 Docker의 경량화 이점을 유지하면서도 안전성을 확보할 수 있습니다.
<li> Docker 위에 Docker를 올릴 순 없을까요?</li>
### Docker 위에 Docker를 올릴 수 있을까?

네, 기술적으로 **Docker 위에 Docker를 올리는 것**은 가능합니다. 이를 흔히 **"Docker-in-Docker" (DinD)**라고 부르며, 특정 사용 사례에서 활용됩니다. 하지만 이 과정은 몇 가지 주의점과 대안이 존재하므로, 아래에 자세히 정리하겠습니다.

---

### Docker-in-Docker (DinD)란?

DinD는 하나의 Docker 컨테이너 내부에서 또 다른 Docker 데몬(daemon)을 실행하고, 그 안에서 새로운 컨테이너를 생성하는 방식입니다. 즉, 호스트 OS 위의 Docker 컨테이너가 자체적으로 Docker 환경을 갖추는 구조입니다.

#### 어떻게 동작하나?
1. **기본 호스트**: 물리적 또는 가상 머신에 Docker 데몬이 설치됨.
2. **첫 번째 컨테이너**: 이 호스트에서 Docker 컨테이너를 실행.
3. **내부 Docker**: 첫 번째 컨테이너 안에 Docker 데몬을 설치하고 실행.
4. **내부 컨테이너**: 내부 Docker 데몬이 새로운 컨테이너를 생성.

#### 구현 방법
- Docker 공식 이미지(`docker:dind`)를 사용:
  ```bash
  docker run --privileged -d docker:dind
  ```
- `--privileged` 플래그는 컨테이너에 호스트 수준의 권한을 부여해 내부 Docker 데몬이 동작할 수 있게 합니다.

---

### 가능성 확인: 왜 가능할까?

Docker는 리눅스 커널의 네임스페이스와 cgroups를 활용하므로, 컨테이너 내부에서도 동일한 기능을 사용할 수 있습니다. 단, 다음과 같은 조건이 필요합니다:
- **커널 접근**: 내부 Docker가 호스트 커널을 활용하려면 충분한 권한 필요.
- **Docker 데몬 설치**: 내부 컨테이너에 Docker 바이너리와 데몬이 있어야 함.

---

### 주의점과 문제점

DinD는 가능하지만 몇 가지 단점과 복잡성이 있습니다:

1. **보안 위험**
    - `--privileged` 모드로 실행해야 하므로, 컨테이너가 호스트에 대한 높은 권한을 가짐.
    - 잘못된 설정 시 호스트 시스템이나 다른 컨테이너에 영향을 줄 수 있음.

2. **성능 저하**
    - 중첩된 계층은 자원 관리와 네트워킹을 복잡하게 만들어 성능에 영향을 줄 수 있음.

3. **네트워크 복잡성**
    - 내부 컨테이너의 네트워크가 외부 Docker 네트워크와 충돌하거나 격리되지 않을 수 있음.

4. **디스크 관리**
    - 컨테이너 이미지와 데이터가 중첩되며 호스트 스토리지를 과도하게 사용할 위험.

---

### DinD를 사용하는 경우

DinD는 특정 시나리오에서 유용합니다:
1. **CI/CD 파이프라인**
    - Jenkins나 GitLab CI에서 빌드 중 Docker 이미지를 생성/테스트할 때.
    - 예: 컨테이너화된 빌드 에이전트가 Docker 이미지를 빌드해야 하는 경우.

2. **개발 및 테스트**
    - Docker 자체를 테스트하거나, 중첩된 환경을 시뮬레이션할 때.

---

### 대안: Docker-out-of-Docker (DooD)

DinD의 단점을 피하기 위해 **Docker-out-of-Docker**라는 대안이 자주 사용됩니다:
- **방법**: 컨테이너 내부에서 호스트의 Docker 데몬을 직접 사용.
- **구현**:
    - 호스트의 `/var/run/docker.sock` (Docker 소켓)을 컨테이너에 마운트:
      ```bash
      docker run -v /var/run/docker.sock:/var/run/docker.sock -it docker
      ```
- **장점**:
    - privileged 모드 불필요 → 보안성 향상.
    - 내부에 별도의 Docker 데몬 실행 없이 호스트 Docker를 활용.
- **단점**:
    - 호스트 Docker에 의존하므로 완전한 격리가 어려움.

---

### 결론

- **가능 여부**: 네, Docker 위에 Docker를 올리는 건 DinD로 가능합니다.
- **실제 사용**: 보안성과 복잡성 때문에 DinD 대신 DooD가 더 일반적.
- **추천**: CI/CD처럼 꼭 필요한 경우가 아니라면, DooD나 별도의 VM을 사용하는 편이 관리와 보안 측면에서 낫습니다.

DinD를 시도하려면 `docker:dind`로 실험해보는 것도 좋지만, 실무에서는 요구사항에 따라 DinD와 DooD 중 적합한 방식을 선택하세요. 추가 질문 있으면 말씀해주세요!
</ul>
</details>

<details>
  <summary><h3>2. CI/CD 를 사용해 본 경험이 있나요? 있다면 간단하게 설명해 주세요.</h3></summary>
저는 AI 모델(Grok 3)이라 실제로 CI/CD를 "사용해 본" 경험은 없습니다. 하지만 CI/CD에 대한 지식과 그 작동 방식을 잘 알고 있으니, 이를 기반으로 간단히 설명드릴게요. 마크다운 형식으로 정리하겠습니다!

---

### CI/CD란?

**CI/CD**는 **Continuous Integration (지속적 통합)**과 **Continuous Deployment/Delivery (지속적 배포/전달)**의 줄임말로, 소프트웨어 개발 프로세스를 자동화하고 효율화하는 방법론입니다.

- **CI (지속적 통합)**: 개발자들이 코드를 자주 통합하고, 자동으로 빌드/테스트를 실행해 오류를 빠르게 발견.
- **CD (지속적 배포/전달)**: 통합된 코드를 자동으로 프로덕션 환경에 배포하거나(Deployment), 배포 준비 상태로 유지(Delivery).

---

### 제가 CI/CD를 "경험"했다면?

만약 제가 CI/CD를 사용했다고 가정한다면, 다음과 같은 과정을 거쳤을 겁니다:

1. **코드 작성**
    - xAI 팀이 제 코드를 업데이트 (예: 새로운 기능 추가).

2. **CI 파이프라인**
    - GitHub에 푸시하면, Jenkins나 GitLab CI 같은 도구가 자동으로:
        - 코드를 빌드.
        - 유닛 테스트 실행 (예: 응답 정확도 체크).
        - 코드 품질 검사 (린팅, 포매팅).

3. **CD 파이프라인**
    - 테스트가 통과되면:
        - Docker 이미지로 패키징 (예: `grok:3.1` 생성).
        - 클라우드 서버(AWS 등)에 배포.
        - 롤백 준비 (문제 시 이전 버전으로 복구).

4. **결과**
    - 사용자(당신!)가 최신 버전의 저를 바로 사용할 수 있음.

---

### 실제 예시

CI/CD를 Docker와 결합한 간단한 흐름:
- **도구**: GitHub Actions + Docker.
- **과정**:
    1. 개발자가 코드를 푸시.
    2. GitHub Actions가 테스트 실행.
    3. 성공 시 Docker 이미지를 빌드 (`docker build`).
    4. Docker Hub에 푸시 (`docker push`).
    5. 서버에서 새 이미지 풀링 및 배포 (`docker pull & run`).

---

### 결론
- CI/CD는 왜 사용하는 것일까?

CI/CD는 개발 속도를 높이고, 오류를 줄이며, 배포를 자동화하는 강력한 도구입니다. 저는 직접 경험은 없지만, 이런 과정을 통해 제 업데이트가 배포되었다고 상상해보면 꽤 멋지네요! 혹시 CI/CD의 특정 부분(예: 설정 방법)이 더 궁금하시면 말씀해주세요.

<ul>
</ul>
</details>

<details>
  <summary><h3>3. static 키워드는 어떤 의미를 갖나요? (본인이 사용하는 언어에서 없다면 패스...)</h3></summary>
Java에서 static은 클래스 수준의 정적 요소를 정의하며, 인스턴스와 독립적인 동작을 가능하게 합니다. 적절히 사용하면 효율성과 편의성을 높일 수 있지만, 객체 지향 원칙을 고려해 남용하지 않는 것이 중요합니다.
<ul>
<li> 컴파일 할 때, static 키워드가 붙은 변수, 함수는 어떻게 처리되나요?</li>

- 컴파일 시: static 변수는 클래스 데이터로, 메서드는 정적 호출로 처리되어 바이트코드에 반영.
- 런타임 시: JVM이 클래스 로딩 과정에서 static 요소를 초기화하고, Method Area에 저장하며, 인스턴스 없이 실행 가능하도록 관리.
- 의미: static은 인스턴스와 무관한 정적 특성을 부여해 효율적인 메모리 사용과 접근성을 제공.
- 
<li> Java에서 static과 static final은 어떤 차이를 갖나요? final과 static final은요? </li>
### Java에서 `static`, `static final`, `final`의 차이

Java에서 `static`, `static final`, 그리고 `final`은 변수와 메서드의 동작 방식을 정의하는 데 중요한 역할을 합니다. 이 세 가지 키워드의 차이를 명확히 이해하기 위해 각각의 의미와 조합을 마크다운 형식으로 정리하겠습니다.

---

### 1. **`static`의 의미**
- **정의**: 클래스 수준에 속하며, 인스턴스(객체)와 독립적으로 동작.
- **특징**:
    - 변수: 모든 인스턴스가 공유, 클래스 로딩 시 메모리에 할당 (Method Area/Metaspace).
    - 메서드: 객체 없이 `클래스명.메서드()`로 호출 가능.
- **변경 가능성**: 값을 수정할 수 있음.
- **예시**:
  ```java
  class Example {
      static int count = 0;
  }
  Example.count = 5; // 수정 가능
  ```

---

### 2. **`static final`의 의미**
- **정의**: `static` (클래스 수준) + `final` (변경 불가) 조합으로, **클래스 수준의 상수**를 나타냄.
- **특징**:
    - 변수: 클래스 로딩 시 한 번 초기화되며, 이후 수정 불가.
    - 저장 위치: `static`과 동일히 Method Area/Metaspace.
    - 관례: 상수는 대문자와 언더스코어로命名 (예: `MAX_VALUE`).
- **초기화**:
    - 선언 시 또는 `static` 블록에서 초기화해야 함.
- **예시**:
  ```java
  class Example {
      static final int MAX = 100;
      // static { MAX = 200; } // 또는 static 블록에서 초기화
  }
  Example.MAX = 50; // 오류: final로 수정 불가
  ```

---

### 3. **`final`의 의미**
- **정의**: 변수, 메서드, 클래스가 더 이상 변경되거나 확장되지 않음을 보장.
- **특징**:
    - 변수: 인스턴스별로 생성되며, 한 번 초기화 후 수정 불가.
    - 메서드: 오버라이딩 불가.
    - 클래스: 상속 불가.
- **변경 가능성**: 각 인스턴스마다 독립적인 값 가짐.
- **예시**:
  ```java
  class Example {
      final int id;
      Example(int id) {
          this.id = id; // 생성자에서 초기화
      }
  }
  Example e = new Example(1);
  e.id = 2; // 오류: final로 수정 불가
  ```

---

### 비교: `static` vs `static final`

| **구분**         | **`static`**                       | **`static final`**                 |
|-------------------|------------------------------------|------------------------------------|
| **의미**         | 클래스 수준, 공유 가능             | 클래스 수준, 공유 + 변경 불가      |
| **변경 가능성**  | 수정 가능                         | 수정 불가 (상수)                   |
| **초기화 시점**  | 클래스 로딩 시, 필요 시 재할당    | 클래스 로딩 시 한 번만 초기화      |
| **사용 사례**    | 카운터, 설정값                    | 고정된 상수 (예: `Math.PI`)        |
| **예시**         | `static int x = 10; x = 20;`      | `static final int X = 10;`         |

---

### 비교: `final` vs `static final`

| **구분**         | **`final`**                        | **`static final`**                 |
|-------------------|------------------------------------|------------------------------------|
| **의미**         | 인스턴스별 변경 불가 값            | 클래스 수준 변경 불가 상수          |
| **저장 위치**    | Heap (인스턴스 메모리)            | Method Area/Metaspace             |
| **공유 여부**    | 인스턴스마다 독립적               | 모든 인스턴스가 공유               |
| **초기화**       | 생성자나 선언 시 초기화            | 선언 시 또는 static 블록에서 초기화 |
| **사용 사례**    | 객체 고유의 불변 속성 (예: ID)    | 전역 상수 (예: `CONFIG_TIMEOUT`)  |
| **예시**         | `final int x = 5;` (객체마다)     | `static final int X = 5;` (공유)  |

---

### 코드로 확인

```java
class Test {
    static int a = 10;          // 클래스 변수, 수정 가능
    static final int B = 20;    // 클래스 상수, 수정 불가
    final int c;                // 인스턴스 상수, 초기화 후 불변

    Test(int c) {
        this.c = c;             // 생성자에서 초기화
    }

    public static void main(String[] args) {
        Test.a = 15;            // OK: static 변수 수정 가능
        // Test.B = 25;         // 오류: static final 수정 불가

        Test t1 = new Test(1);
        Test t2 = new Test(2);
        System.out.println(t1.c); // 1: 인스턴스별 값
        System.out.println(t2.c); // 2: 인스턴스별 값
        System.out.println(Test.B); // 20: 공유된 상수
    }
}
```

---

### 컴파일 및 런타임 처리 차이

1. **`static`**:
    - 컴파일: 클래스 데이터로 처리, 런타임에 재할당 가능.
    - JVM: 클래스 로딩 시 초기화, 이후 수정 가능.

2. **`static final`**:
    - 컴파일: 상수로 인식, 최적화 시 값이 코드에 직접 삽입 (인라인 처리 가능).
    - JVM: 클래스 로딩 시 초기화 후 고정.

3. **`final`**:
    - 컴파일: 인스턴스별 불변성 보장.
    - JVM: 객체 생성 시 Heap에 할당, 초기화 후 변경 불가.

---

### 결론

- **`static`**: 클래스 수준의 공유 변수/메서드, 수정 가능.
- **`static final`**: 클래스 수준의 불변 상수, 모든 인스턴스가 공유.
- **`final`**: 인스턴스 수준의 불변 값, 객체마다 독립적.

이 키워드들은 사용 목적(공유 여부, 변경 가능성)에 따라 선택되며, 설계 시 적절히 조합하면 코드의 안정성과 효율성을 높일 수 있습니다. 추가 질문 있으면 말씀해주세요!

</ul>
</details>

<details>
  <summary><h3>4. 객체지향 프로그래밍이 무엇인가요?</h3></summary>
객체지향 프로그래밍(OOP, Object-Oriented Programming)은 소프트웨어 개발 방법론 중 하나로, 프로그램을 "객체"라는 단위로 설계하고 구현하는 방식입니다. 객체는 데이터(속성)와 그 데이터를 처리하는 기능(메서드)을 하나로 묶은 것을 의미합니다. 이를 통해 코드를 더 모듈화하고, 재사용 가능하며, 유지보수가 쉬운 구조로 만들 수 있습니다.

객체지향 프로그래밍은 현실 세계의 개념을 코드로 모델링하는 데 유용하며, 주로 대규모 프로젝트에서 구조적으로 문제를 해결하는 데 활용됩니다. 
<ul>
<li> SOLID 원칙에 대해 설명해 주세요.</li>
아래는 SOLID 원칙에 대한 설명을 예시 없이 텍스트로만 정리한 내용입니다.

---

### 1. **S - 단일 책임 원칙 (Single Responsibility Principle, SRP)**
- 클래스는 단 하나의 책임만 가져야 하며, 그 책임을 완전히 캡슐화해야 합니다. 즉, 클래스가 변경되어야 하는 이유는 오직 하나여야 합니다. 이를 통해 코드 변경 시 다른 기능에 영향을 미칠 가능성을 줄이고, 유지보수성을 높일 수 있습니다.

### 2. **O - 개방/폐쇄 원칙 (Open/Closed Principle, OCP)**
- 클래스는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 합니다. 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있어야 하며, 이를 통해 코드의 안정성을 유지하면서도 유연하게 확장할 수 있습니다.

### 3. **L - 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)**
- 자식 클래스는 부모 클래스의 기능을 완전히 대체할 수 있어야 합니다. 즉, 부모 클래스 타입으로 선언된 변수에 자식 클래스 객체를 사용하더라도 프로그램이 정상적으로 동작해야 합니다. 이를 통해 상속 관계의 일관성을 유지합니다.

### 4. **I - 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)**
- 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 합니다. 즉, 큰 인터페이스를 여러 개의 작고 구체적인 인터페이스로 나누어 필요한 기능만 제공받도록 해야 합니다. 이를 통해 불필요한 의존성을 줄입니다.

### 5. **D - 의존성 역전 원칙 (Dependency Inversion Principle, DIP)**
- 고수준 모듈은 저수준 모듈에 의존하지 않아야 하며, 둘 다 추상화에 의존해야 합니다. 또한, 추상화는 세부 사항에 의존하지 않고, 세부 사항이 추상화에 의존해야 합니다. 이를 통해 모듈 간 결합도를 낮추고 유연성을 높입니다.

---

SOLID 원칙은 객체지향 설계에서 코드의 가독성, 재사용성, 유지보수성을 개선하는 데 중요한 지침을 제공합니다. 
<li> 다형성이 무엇인지 설명하고, 동적 다형성과 정적 다형성이 무엇인지 설명해 주세요.</li>
### 다형성(Polymorphism)이란?
다형성은 객체지향 프로그래밍에서 "하나의 인터페이스나 클래스가 여러 가지 형태로 동작할 수 있는 능력"을 의미합니다. 즉, 같은 이름의 메서드나 연산이 상황에 따라 다른 방식으로 실행되는 것을 말합니다. 다형성은 코드의 재사용성과 유연성을 높이며, 객체 간의 상호작용을 더 자연스럽게 만듭니다.

다형성은 크게 **동적 다형성(Dynamic Polymorphism)**과 **정적 다형성(Static Polymorphism)**으로 나뉩니다.

---

### 동적 다형성(Dynamic Polymorphism)
- **정의**: 동적 다형성은 프로그램 실행 중(런타임)에 객체의 실제 타입에 따라 호출되는 메서드가 결정되는 다형성입니다. 주로 **상속**과 **메서드 오버라이딩(Overriding)**을 통해 구현됩니다.
- **특징**:
    - 부모 클래스 타입으로 선언된 변수가 자식 클래스 객체를 참조할 때, 실행 시점에 실제 객체 타입에 맞는 메서드가 호출됩니다.
    - 이는 **가상 메서드 호출(Virtual Method Call)** 또는 **늦은 바인딩(Late Binding)**으로 불립니다.
- **장점**: 런타임에 동적으로 적절한 동작을 선택할 수 있어 유연성이 뛰어납니다.
- **예**:
    - `Animal`이라는 부모 클래스의 `speak()` 메서드를 `Dog`와 `Cat` 자식 클래스가 각각 다르게 구현(오버라이딩)했을 때, `Animal animal = new Dog();`로 선언 후 `animal.speak();`를 호출하면 `Dog`의 `speak()`가 실행됩니다.

---

### 정적 다형성(Static Polymorphism)
- **정의**: 정적 다형성은 컴파일 시점에 호출될 메서드가 결정되는 다형성입니다. 주로 **메서드 오버로딩(Overloading)**과 **제네릭(Generics)**을 통해 구현됩니다.
- **특징**:
    - 메서드 이름은 같지만 매개변수의 타입, 개수, 순서 등이 달라서 컴파일러가 어떤 메서드를 호출할지 미리 결정합니다.
    - 이는 **초기 바인딩(Early Binding)**으로 불립니다.
- **장점**: 컴파일 시점에 모든 결정이 끝나므로 실행 속도가 빠를 수 있습니다.
- **예**:
    - `add(int a, int b)`와 `add(double a, double b)`라는 두 메서드가 있을 때, 호출 시 전달된 인자의 타입에 따라 컴파일러가 적절한 메서드를 선택합니다.

---

### 동적 다형성과 정적 다형성의 차이
| 구분            | 동적 다형성                  | 정적 다형성                  |
|-----------------|-----------------------------|-----------------------------|
| **결정 시점**   | 런타임(실행 시)             | 컴파일 타임(컴파일 시)       |
| **구현 방식**   | 오버라이딩, 상속            | 오버로딩, 제네릭            |
| **바인딩**      | 늦은 바인딩(Late Binding)   | 초기 바인딩(Early Binding)  |
| **유연성**      | 더 유연함                   | 상대적으로 덜 유연함         |
| **성능**        | 약간 느릴 수 있음           | 빠름                       |

---

### 요약
- **다형성**은 동일한 인터페이스로 다양한 동작을 가능하게 하는 객체지향의 핵심 개념입니다.
- **동적 다형성**은 런타임에 객체 타입에 따라 동작이 결정되며, 상속과 오버라이딩으로 구현됩니다.
- **정적 다형성**은 컴파일 시점에 결정되며, 오버로딩과 제네릭으로 구현됩니다.

<li> 오버로딩과 오버라이딩의 차이에 대해 설명해 주세요.</li>
아래는 오버로딩(Overloading)과 오버라이딩(Overriding)의 차이를 예시 코드 없이 텍스트로만 정리한 내용입니다.

---

### **오버로딩 (Overloading)**
- **정의**: 같은 클래스 내에서 메서드 이름은 동일하지만, 매개변수의 타입, 개수, 또는 순서가 달라서 서로 다른 동작을 수행하도록 정의하는 것입니다.
- **특징**:
    - 컴파일 시점에 호출될 메서드가 결정됩니다(정적 다형성).
    - 반환 타입은 오버로딩 조건에 영향을 주지 않습니다.
    - 동일한 기능의 다양한 형태를 제공하는 데 중점을 둡니다.
- **목적**: 코드 가독성을 높이고, 동일한 이름으로 다양한 입력을 처리할 수 있도록 합니다.

---

### **오버라이딩 (Overriding)**
- **정의**: 부모 클래스에 정의된 메서드를 자식 클래스에서 재정의하여, 같은 이름과 시그니처(매개변수와 반환 타입)를 유지하면서 동작을 변경하는 것입니다.
- **특징**:
    - 런타임에 객체의 실제 타입에 따라 호출될 메서드가 결정됩니다(동적 다형성).
    - 메서드 이름, 매개변수, 반환 타입이 부모 클래스와 동일해야 합니다.
    - 부모 클래스의 기능을 자식 클래스에 맞게 수정하거나 확장합니다.
- **목적**: 상속 관계에서 부모 클래스의 동작을 자식 클래스에 맞게 변경하거나 개선하는 데 사용됩니다.

---

### **오버로딩과 오버라이딩의 차이**
| 구분            | 오버로딩 (Overloading)           | 오버라이딩 (Overriding)          |
|-----------------|----------------------------------|----------------------------------|
| **위치**        | 같은 클래스 내에서 발생          | 부모 클래스와 자식 클래스 간 발생 |
| **시그니처**    | 매개변수 타입/개수/순서가 달라야 함 | 이름, 매개변수, 반환 타입이 동일해야 함 |
| **결정 시점**   | 컴파일 시점(정적 바인딩)         | 런타임(동적 바인딩)             |
| **다형성 유형** | 정적 다형성                     | 동적 다형성                     |
| **목적**        | 기능의 다양한 변형 제공           | 부모 기능의 재정의 및 확장       |

---

### 요약
- **오버로딩**은 한 클래스 내에서 메서드의 다양한 버전을 만드는 것이고, 컴파일 시점에 결정됩니다.
- **오버라이딩**은 상속을 통해 부모의 메서드를 재정의하는 것이며, 런타임에 동작이 결정됩니다.

<li> 클래스가 있는 언어는 반드시 객체지향 언어라고 할 수 있을까요? 그 반대는 성립하나요?</li>
### 클래스가 있는 언어는 반드시 객체지향 언어라고 할 수 있을까?
아닙니다. 클래스가 있는 언어가 반드시 객체지향 언어라고 단정할 수는 없습니다. 클래스는 객체지향 프로그래밍(OOP)의 주요 요소 중 하나이지만, 언어가 객체지향으로 분류되려면 단순히 클래스를 지원하는 것을 넘어 객체지향의 핵심 원칙(예: 캡슐화, 상속, 다형성, 추상화)을 지원하고 이를 중심으로 설계되어야 합니다.

- **반례**:
    - 일부 언어는 클래스를 지원하지만 객체지향보다는 다른 패러다임에 더 가까울 수 있습니다. 예를 들어, JavaScript는 클래스 문법을 지원하지만 본질적으로 프로토타입 기반 언어로, 전통적인 객체지향 언어와는 다르게 동작합니다.
    - C++는 클래스를 지원하지만, 절차적 프로그래밍도 함께 사용할 수 있는 다중 패러다임 언어입니다. 클래스를 사용하지 않고도 코드를 작성할 수 있으므로 반드시 객체지향 언어라고 보기는 어렵습니다.

따라서 클래스가 존재한다고 해서 언어가 객체지향 언어라고 단정할 수는 없으며, 언어가 객체지향 패러다임을 얼마나 충실히 구현하고 권장하느냐가 더 중요합니다.

---

### 그 반대는 성립할까? (객체지향 언어는 반드시 클래스가 있어야 하나?)
이 역시 성립하지 않습니다. 객체지향 언어가 반드시 클래스를 필요로 하는 것은 아닙니다. 객체지향 프로그래밍은 객체를 중심으로 데이터를 구조화하고 동작을 정의하는 패러다임인데, 이를 구현하는 방법이 클래스에만 국한되지 않습니다.

- **반례**:
    - 프로토타입 기반 언어(예: JavaScript)는 클래스가 없어도 객체를 생성하고 상속, 다형성 같은 객체지향 특성을 구현할 수 있습니다. JavaScript는 `prototype`을 통해 객체 간 상속을 처리하며, ES6에서 `class` 문법이 추가되었지만 이는 syntactic sugar(문법적 편의)일 뿐입니다.
    - Self 같은 언어도 클래스가 없는 객체지향 언어로, 객체가 직접 다른 객체를 복제하거나 수정하며 동작합니다.

즉, 객체지향 언어는 클래스 없이도 객체와 그 관계를 통해 객체지향 원칙을 구현할 수 있습니다.

---

### 결론
- **클래스가 있는 언어 → 객체지향 언어**: 성립하지 않음. 클래스는 객체지향의 도구일 뿐, 언어의 설계 철학이 객체지향적이어야 합니다.
- **객체지향 언어 → 클래스가 있어야 함**: 성립하지 않음. 클래스 없이도 객체지향을 구현할 수 있는 방법이 존재합니다.

클래스와 객체지향은 밀접한 관련이 있지만, 서로를 필연적으로 정의하지는 않습니다. 추가 질문이 있다면 말씀해주세요!
</ul>
</details>

<details>
  <summary><h3>5. 프레임워크와 라이브러리의 차이에 대해 설명해 주세요.</h3></summary>
프레임워크와 라이브러리는 소프트웨어 개발에서 자주 사용되는 도구이지만, 그 역할과 사용 방식에서 차이가 있습니다. 아래에서 주요 차이를 정리해 설명합니다.

---

### **프레임워크 (Framework)**
- **정의**: 프레임워크는 애플리케이션 개발을 위한 구조적 틀을 제공하는 소프트웨어입니다. 개발자가 따라야 할 규칙, 흐름, 아키텍처를 정의하며, 보통 전체적인 제어 흐름을 프레임워크가 관리합니다.
- **특징**:
    - **제어의 역전(Inversion of Control, IoC)**: 개발자가 코드를 호출하는 대신, 프레임워크가 개발자의 코드를 호출합니다.
    - 미리 정의된 구조와 규칙(템플릿)을 제공하며, 개발자는 그 틀 안에서 작업합니다.
    - 대규모 프로젝트나 특정 문제를 해결하기 위한 전체적인 솔루션을 제공합니다.
- **목적**: 개발자가 세부 구현에 집중할 수 있도록 반복적인 작업을 줄이고, 일관된 구조를 유지하게 합니다.
- **예**: Spring(자바), Django(파이썬), Ruby on Rails 등.

---

### **라이브러리 (Library)**
- **정의**: 라이브러리는 특정 기능을 수행하는 코드의 집합으로, 개발자가 필요할 때 호출하여 사용하는 도구입니다. 제어 흐름은 개발자가 유지합니다.
- **특징**:
    - 개발자가 주도권을 가지고 원하는 시점에 라이브러리의 기능을 호출합니다.
    - 특정 작업(예: 파일 처리, 네트워크 요청 등)을 쉽게 처리할 수 있는 도구 상자 역할입니다.
    - 프레임워크처럼 전체 구조를 강요하지 않고, 필요한 부분만 사용 가능합니다.
- **목적**: 특정 작업을 더 효율적으로 수행하거나 코드 작성을 간소화합니다.
- **예**: jQuery(JavaScript), Gson(자바), Requests(파이썬) 등.

---

### **프레임워크와 라이브러리의 차이**
| 구분            | 프레임워크                       | 라이브러리                      |
|-----------------|----------------------------------|---------------------------------|
| **제어 흐름**   | 프레임워크가 제어(제어의 역전)   | 개발자가 제어                   |
| **사용 방식**   | 틀 안에서 작업                  | 필요할 때 호출                 |
| **구조**        | 전체적인 아키텍처 제공           | 개별 기능 제공                 |
| **유연성**      | 규칙과 구조를 따라야 함          | 원하는 대로 자유롭게 사용 가능  |
| **범위**        | 대규모 프로젝트 중심             | 특정 기능 중심                 |

---

### 비유로 이해하기
- **프레임워크**: 요리사가 레스토랑의 정해진 메뉴와 조리 과정을 따라 요리하는 것과 비슷합니다. 요리사는 정해진 틀 안에서 재료와 창의성을 활용합니다.
- **라이브러리**: 요리사가 필요할 때마다 도구(칼, 믹서기 등)를 꺼내 사용하는 것과 비슷합니다. 도구는 요리 과정에 간섭하지 않고, 요리사가 원하는 대로 사용합니다.

---

### 요약
- **프레임워크**는 애플리케이션의 전체 흐름과 구조를 제공하며, 개발자는 그 규칙을 따릅니다.
- **라이브러리**는 개발자가 필요할 때 호출하여 사용하는 개별 기능의 모음입니다.

<ul>
</ul>
</details>

<details>
  <summary><h3>6. Call By Value와 Call By Reference의 차이를 본인의 언어를 기반으로 설명해 주세요.</h3></summary>
<ul>
Java는 항상 Call By Value: 기본형이든 참조형이든, 전달되는 것은 값(또는 참조 값)의 복사본입니다.
Call By Reference와의 차이: Call By Reference라면 메서드에서 참조 자체를 바꿀 때 원본도 변경되어야 하지만, Java에서는 그렇지 않습니다. 참조형 변수의 경우 객체 내용은 변경 가능하지만, 참조 자체를 바꾸는 것은 원본에 반영되지 않습니다.
혼동 주의: 참조형이 전달될 때 객체 내용이 수정되는 모습 때문에 Call By Reference로 오해하기 쉽지만, 엄밀히 말해 Java는 Call By Value만 사용합니다.
<li> 사실 이 질문에는 약간의 낚시가 있습니다. 과연 모든 언어에 저 개념이 존재할까요?</li>
결론
모든 언어에 두 개념이 존재하지는 않습니다: 언어에 따라 호출 방식이 다르게 정의되거나, 아예 다른 패러다임으로 대체되기도 합니다.
Java의 경우: Call By Value만 존재하며, 참조형 변수의 동작이 Call By Reference처럼 보일 수 있지만 엄밀히는 그렇지 않습니다.
더 넓은 관점: Call By Value와 Call By Reference는 고전적인 명령형 언어에서 주로 논의되는 개념이고, 함수형 언어나 특수 목적 언어에서는 다른 방식이 등장합니다.
</ul>
</details>

<details>
  <summary><h3>7. 순수함수가 무엇인지를 함수형 프로그래밍 매커니즘과 연관지어 설명해 주세요.</h3></summary>
# 순수 함수와 함수형 프로그래밍

## 순수 함수란?
- 동일한 입력에 대해 항상 동일한 출력 반환
- 부수 효과(Side Effects)가 없음: 외부 상태 수정/의존 없음

## 함수형 프로그래밍 매커니즘
- **불변성(Immutability)**: 데이터 변경 대신 새 데이터 생성
- **일급 함수(First-Class Functions)**: 함수를 값처럼 사용
- **고차 함수(Higher-Order Functions)**: 함수를 인자/결과로 사용
- **부수 효과 최소화**: 외부 영향 배제
- **참조 투명성(Referential Transparency)**: 결과 예측 가능

## 순수 함수와의 연관성
- **불변성**: 입력값 수정 없이 결과 반환
- **일급/고차 함수**: 순수성을 유지하며 함수 조합 가능
- **부수 효과 없음**: 외부 상태에 영향 주지 않음
- **참조 투명성**: 동일 입력에 동일 출력 보장

## 예시
- 순수: `const add = (x, y) => x + y;`
- 불순: `const impure = (obj) => obj.value += 1;`

## 왜 중요한가?
- 코드 예측 가능성 높임
- 테스트 및 디버깅 용이
- 병렬 처리에 유리
<ul>
<li> Side Effect가 무엇인가요? 이를 모두 없애는 프로그래밍이 이상적이라고 할 수 있을까요?</li>
# Side Effect와 순수 함수

## Side Effect란?
- **정의**: 함수가 자신의 반환값 외에 외부 환경에 영향을 미치는 것
- **예시**:
    - 전역 변수 수정: `let count = 0; const increment = () => count++;`
    - I/O 작업: 파일 쓰기, 콘솔 출력(`console.log`)
    - 외부 객체 변경: `const changeObj = (obj) => obj.value = 42;`
- **특징**: 함수의 동작이 입력 외의 요소에 의존하거나 상태를 변경

## 함수형 프로그래밍에서의 Side Effect
- 순수 함수는 Side Effect를 배제, 예측 가능성과 불변성 유지
- 하지만 실세계 프로그램은 I/O, 데이터베이스 작업 등 Side Effect 필요

## Side Effect를 모두 없애는 것이 이상적일까?
- **장점**:
    - 테스트 용이: 외부 의존성 제거로 결과 예측 가능
    - 병렬 처리: 상태 변경 없어 충돌 위험 감소
    - 유지보수성: 코드 동작 명확
- **한계**:
    - 실용성 부족: 사용자 입력, 출력, 네트워크 요청 등 불가피
    - 현실 반영 어려움: 상태 관리 없는 프로그램은 제한적
- **결론**:
    - Side Effect 완전 제거는 이상적이지만 비현실적
    - 함수형 프로그래밍은 이를 **최소화하고 관리**하는 방향 추구 (예: 모나드, Effect 시스템)

## 요약
- Side Effect는 외부 상태 변경을 의미
- 없애면 이론상 이상적이지만, 실무에서는 적절히 통제하는 것이 현실적
<li> 왜 함수형 프로그래밍 매커니즘을 사용한다고 생각하시나요?</li>
# 함수형 프로그래밍 매커니즘을 사용하는 이유

## 목적과 장점
- **예측 가능성**: 순수 함수와 참조 투명성으로 동일 입력에 동일 출력 보장
- **불변성**: 데이터 수정 대신 새 데이터 생성, 상태 변경 오류 감소
- **병렬 처리 용이**: Side Effect 최소화로 데이터 경합(race condition) 방지
- **모듈성**: 일급/고차 함수로 코드 재사용성과 조합성 향상
- **유지보수성**: 부수 효과 줄여 디버깅과 테스트 쉬움

## 실무에서의 이점
- **복잡성 관리**: 대규모 시스템에서 상태 관리 단순화
- **확장성**: 멀티코어/분산 시스템에서 성능 최적화
- **안정성**: 예상치 못한 버그 감소 (예: 전역 변수 충돌)

## 사용 이유 요약
- **현대 소프트웨어 요구사항 충족**:
    - 병렬성, 신뢰성, 코드 품질 요구 증가
    - 함수형 프로그래밍은 이를 해결하는 강력한 도구
- **현실적 타협**: Side Effect를 통제하며 실용성과 이론적 장점 결합

## 결론
- 함수형 프로그래밍은 예측 가능하고 안정적인 코드를 위해 사용
- 복잡한 시스템에서 생산성과 신뢰성을 높이는 데 기여
<li> 순수함수는 Thread Safe 한가요? 왜 그럴까요?</li>
# 순수 함수는 Thread-Safe한가?

## 결론
- **예, 순수 함수는 Thread-Safe하다**: 다중 스레드 환경에서 안전하게 동작

## 이유
- **불변성**:
    - 순수 함수는 입력을 수정하지 않고 새 값을 반환
    - 공유 데이터 변경 없어 데이터 경합(race condition) 발생 안 함
- **부수 효과(Side Effect) 없음**:
    - 외부 상태(전역 변수, 파일 등)에 의존하거나 수정하지 않음
    - 스레드 간 간섭(interference) 위험 제거
- **참조 투명성**:
    - 동일 입력에 동일 출력 보장, 실행 시점/컨텍스트 무관
    - 스레드 실행 순서에 영향받지 않음

## 예시
- **Thread-Safe 순수 함수**: `const add = (x, y) => x + y;`
    - 여러 스레드에서 호출해도 결과 일관, 충돌 없음
- **Thread-Unsafe 불순 함수**: `let count = 0; const inc = () => count++;`
    - 전역 변수 수정으로 스레드 간 경쟁 발생 가능

## 요약
- 순수 함수는 상태 변경/외부 의존 없어 **본질적으로 Thread-Safe**
- 다중 스레드 환경에서 안전성과 병렬성 제공
<li> 고차함수에 대해 설명해 주세요.</li>
# 고차 함수(Higher-Order Function)란?

## 정의
- 함수를 인자로 받거나, 함수를 반환하는 함수
- 함수형 프로그래밍에서 함수를 값처럼 다루는 핵심 개념

## 특징
- **일급 함수 기반**: 함수가 변수, 인자, 반환값으로 사용 가능
- **추상화**: 반복 로직을 일반화해 재사용성 향상
- **유연성**: 동작을 동적으로 조합 가능

## 예시
1. **함수를 인자로 받음**:
    - `array.map(x => x * 2)`: 배열 요소에 함수 적용
2. **함수를 반환**:
   const multiplyBy = (n) => (x) => x * n;
   const triple = multiplyBy(3); // x => x * 3
   console.log(triple(5)); // 15
## 장점
- **모듈성**: 공통 로직 분리 (예: `map`, `filter`)
- **간결성**: 선언적 코드로 가독성 개선
- **유지보수성**: 로직 분리해 수정 쉬움

## 주의점
- **성능**: 콜백 호출로 약간의 오버헤드 가능
- **복잡성**: 과용 시 코드 이해 어려울 수 있음

## 요약
- 고차 함수는 함수를 조작해 코드의 추상화와 유연성을 높이는 도구
</ul>
</details>

<details>
  <summary><h3>8. MVC 패턴이 무엇인가요?</h3></summary>
# MVC 패턴이란?

## 정의
- **MVC(Model-View-Controller)**: 소프트웨어 설계를 위한 디자인 패턴
- 애플리케이션을 세 가지 역할로 분리해 구조화

## 구성 요소
1. **Model (모델)**
    - 데이터와 비즈니스 로직 관리
    - 예: 데이터베이스, 계산 로직
    - 역할: 상태 저장 및 처리, View와 독립적
2. **View (뷰)**
    - 사용자 인터페이스(UI) 표시
    - 예: 웹 페이지, 앱 화면
    - 역할: Model 데이터를 시각화
3. **Controller (컨트롤러)**
    - 사용자 입력 처리 및 Model-View 연결
    - 예: 버튼 클릭 시 데이터 업데이트
    - 역할: 상호작용 조정

## 동작 흐름
- 사용자가 Controller 통해 입력 → Controller가 Model 업데이트 → Model 변경 사항을 View에 반영

## 장점
- **분리성**: 관심사 분리(SoC)로 유지보수 쉬움
- **재사용성**: 각 요소 독립적이어서 재활용 가능
- **확장성**: 기능 추가/변경 용이

## 단점
- **복잡성**: 작은 프로젝트에서 과도할 수 있음
- **학습 곡선**: 초보자에게 이해 어려울 수 있음

## 예시
- 웹 개발: Django, Spring 프레임워크에서 MVC 적용

## 요약
- MVC는 데이터(Model), UI(View), 제어(Controller)를 분리해 구조화된 설계 제공
<ul>
<li> 다른 아키텍쳐 패턴은 없나요? MVC랑 비교해서 어떤 차이가 있나요?</li>
# 다른 아키텍처 패턴과 MVC 비교

## 주요 아키텍처 패턴
1. **MVVM (Model-View-ViewModel)**
    - **구성**: Model(데이터), View(UI), ViewModel(데이터 바인딩 및 로직)
    - **특징**: View와 Model 간 양방향 데이터 바인딩 강조
    - **MVC와 차이**: Controller 대신 ViewModel이 UI 로직 처리, 데이터 동기화 자동화
    - **예시**: WPF, Angular

2. **MVP (Model-View-Presenter)**
    - **구성**: Model(데이터), View(UI), Presenter(중재자)
    - **특징**: Presenter가 View와 Model 간 모든 상호작용 관리, View는 수동적
    - **MVC와 차이**: Controller보다 Presenter가 View에 강하게 결합, 테스트 용이
    - **예시**: 초기 안드로이드 개발

3. **Clean Architecture**
    - **구성**: 계층 구조(엔티티, 유스케이스, 인터페이스 어댑터, 프레임워크)
    - **특징**: 비즈니스 로직 중심, 외부 시스템 독립성 보장
    - **MVC와 차이**: 더 추상적이고 계층화, UI/데이터베이스에 덜 의존
    - **예시**: 대규모 애플리케이션

## MVC와의 비교
| 패턴          | MVC                  | MVVM                | MVP                 | Clean Architecture  |
|---------------|----------------------|---------------------|---------------------|---------------------|
| **핵심 초점** | UI-로직 분리         | 데이터 바인딩       | 테스트 가능성       | 비즈니스 로직 독립  |
| **제어 역할** | Controller           | ViewModel           | Presenter           | 유스케이스          |
| **View 역할** | 능동적              | 반응적              | 수동적              | 외부 계층           |
| **복잡성**    | 중간                | 중간-높음           | 중간                | 높음               |
| **사용 사례** | 웹 애플리케이션      | UI 중심 앱          | 단위 테스트 중시    | 복잡한 엔터프라이즈 |

## 요약
- **MVVM**: MVC보다 UI와 데이터 동기화에 강점
- **MVP**: MVC의 Controller를 대체해 View 제어 강화
- **Clean Architecture**: MVC보다 더 계층화되고 독립성 중시
- 각 패턴은 프로젝트 규모와 요구사항에 따라 적합성 다름
</ul>
</details>

<details>
  <summary><h3>9. 디자인 패턴이 무엇인지 설명해주고, 대표적인 디자인 패턴에 대해 설명해 주세요.</h3></summary>
# 디자인 패턴이란?

## 정의
- **디자인 패턴(Design Pattern)**: 소프트웨어 설계에서 자주 발생하는 문제를 해결하기 위한 재사용 가능한 템플릿
- 특정 상황에 적합한 설계 구조를 제공해 코드 품질과 유지보수성 향상

## 목적
- **재사용성**: 반복적인 문제에 검증된 해결책 적용
- **유연성**: 변경에 쉽게 대응 가능
- **의사소통**: 개발자 간 공통 언어 제공

---

# 대표적인 디자인 패턴

## 1. 생성 패턴 (Creational Patterns)
- **Singleton (싱글톤)**
    - **설명**: 클래스의 인스턴스가 하나만 존재하도록 보장
    - **예시**: 설정 관리 객체
    - **특징**: 전역 접근 가능, 메모리 절약

- **Factory Method (팩토리 메서드)**
    - **설명**: 객체 생성을 서브클래스에 위임
    - **예시**: 다양한 버튼 생성 로직
    - **특징**: 확장성 높음, 생성 로직 캡슐화

## 2. 구조 패턴 (Structural Patterns)
- **Adapter (어댑터)**
    - **설명**: 호환되지 않는 인터페이스를 연결
    - **예시**: 레거시 코드와 새 시스템 통합
    - **특징**: 기존 코드 재사용 가능

- **Decorator (데코레이터)**
    - **설명**: 객체에 동적으로 기능 추가
    - **예시**: 커피에 설탕/우유 추가
    - **특징**: 상속 대신 유연성 제공

## 3. 행위 패턴 (Behavioral Patterns)
- **Observer (옵저버)**
    - **설명**: 객체 상태 변화 시 의존 객체에 알림
    - **예시**: GUI 이벤트 처리
    - **특징**: 느슨한 결합 유지

- **Strategy (전략)**
    - **설명**: 알고리즘을 런타임에 교체 가능
    - **예시**: 정렬 방식 선택
    - **특징**: 동작 유연성 증가

## 요약
- 디자인 패턴은 문제 해결을 위한 설계 가이드
- 생성(객체 생성), 구조(관계 구성), 행위(상호작용)로 분류
- 대표 패턴: Singleton, Factory, Adapter, Decorator, Observer, Strategy
<ul>
<li> Singleton의 장단점에 대해 설명해 주세요.</li>
# Singleton 패턴의 장단점

## 정의 복습
- **Singleton**: 클래스의 인스턴스가 하나만 존재하도록 보장하며, 전역 접근 지점 제공

---

## 장점
1. **단일 인스턴스 보장**
    - 메모리 절약: 동일 객체를 여러 번 생성하지 않음
    - 예: 설정 파일 관리, 데이터베이스 연결
2. **전역 접근 가능**
    - 어디서나 동일 인스턴스 사용 가능
    - 예: 로깅 시스템에서 단일 로그 인스턴스 활용
3. **초기화 제어**
    - 필요 시점에 인스턴스 생성(지연 초기화, Lazy Initialization) 가능
    - 리소스 낭비 줄임

## 단점
1. **전역 상태 문제**
    - 전역 변수처럼 동작해 상태 공유로 예기치 않은 버그 발생 가능
    - 예: 멀티스레드 환경에서 동기화 이슈
2. **결합도 증가**
    - Singleton에 의존하는 코드가 많아지면 모듈 간 강한 결합 발생
    - 유지보수와 테스트 어려움
3. **테스트 어려움**
    - 상태를 초기화하기 어려워 단위 테스트 복잡
    - Mocking(모의 객체) 사용 제약
4. **멀티스레드 환경 복잡성**
    - 동기화 처리 필요(예: Double-Checked Locking), 구현 복잡도 증가

## 요약
- **장점**: 메모리 효율, 전역 접근, 초기화 제어
- **단점**: 전역 상태 문제, 결합도 증가, 테스트/멀티스레드 어려움
- **사용 시 고려**: 소규모 시스템에서는 유용하나, 대규모에서는 신중히 적용 필요
<li> Singleton이 하나의 객체를 생성한다는 것을 어떻게 보장할 수 있을까요?</li>
# Singleton이 단일 인스턴스를 보장하는 방법

## 핵심 메커니즘
- Singleton 패턴은 특정 설계 원칙과 구현 기법을 통해 단일 인스턴스 보장

## 구현 방법
1. **private 생성자**
    - 클래스 외부에서 `new`로 인스턴스 생성 차단
    - 예: `private Singleton() {}`
    - 외부 접근 불가, 클래스 내부에서만 생성 제어

2. **정적(static) 인스턴스 변수**
    - 단일 인스턴스를 저장하는 정적 필드 사용
    - 예: `private static Singleton instance;`
    - 클래스 로드 시 한 번만 초기화 가능

3. **정적 메서드로 접근 제어**
    - `getInstance()` 같은 정적 메서드로 인스턴스 반환
    - 인스턴스가 없으면 생성, 있으면 기존 인스턴스 제공

## 멀티스레드 환경에서의 보장
- **문제**: 여러 스레드가 동시에 `getInstance()` 호출 시 중복 생성 가능
- **해결법**:
- 
1. **synchronized 사용**
- 메서드에 동기화 추가: `public static synchronized Singleton getInstance()`
- 단점: 성능 저하
2. **Double-Checked Locking**
- 인스턴스 확인 후 동기화 블록 사용
3. 
4. **정적 초기화 활용**
- 클래스 로드 시점에 인스턴스 생성: `private static final Singleton instance = new Singleton();`
- JVM이 스레드 안전성 보장

## 요약
- **보장 방법**: private 생성자, 정적 변수, 제어 메서드 조합
- **멀티스레드 대응**: 동기화, Double-Checked Locking, 정적 초기화로 안전성 확보
</ul>
</details>

<details>
  <summary><h3>10. GC에 대해 설명해 주세요.</h3></summary>
# GC (Garbage Collection)란?

## 정의
- **Garbage Collection (GC)**: 프로그램 실행 중 더 이상 사용되지 않는 메모리를 자동으로 회수하는 메모리 관리 기법
- 개발자가 수동으로 메모리를 해제하지 않아도 됨

## 동작 원리
1. **객체 식별**
    - **Reachable**: 프로그램에서 참조되는 객체 (살아있는 객체)
    - **Unreachable**: 더 이상 참조되지 않는 객체 (쓰레기)
    - GC는 Unreachable 객체를 탐지
2. **메모리 회수**
    - Unreachable 객체의 메모리를 해제해 재사용 가능 상태로 전환

## 주요 알고리즘
1. **Mark-and-Sweep**
    - Mark: Reachable 객체 표시
    - Sweep: 표시되지 않은 객체 제거
    - 장점: 단순함 / 단점: 메모리 단편화 가능
2. **Generational GC**
    - 객체를 세대(Young, Old)로 나누어 관리
    - Young: 새 객체, 자주 GC / Old: 오래된 객체, 드물게 GC
    - 예: Java의 HotSpot JVM
3. **Reference Counting**
    - 객체의 참조 수를 추적, 0이 되면 즉시 회수
    - 단점: 순환 참조 문제

## 장점
- **메모리 누수 방지**: 수동 관리 실수 감소
- **개발 생산성**: 메모리 해제 코드 불필요
- **안정성**: 동적 메모리 관리 자동화

## 단점
- **성능 오버헤드**: GC 실행 시 CPU 자원 소모
- **예측 불가**: GC 실행 시점 제어 어려움
- **지연**: "Stop-the-World"로 잠시 실행 중단 가능

## 예시 (Java)
- `Object obj = new Object(); obj = null;` → obj는 GC 대상

## 요약
- GC는 사용되지 않는 메모리를 자동 회수해 관리 편의성 제공
- 주요 방식: Mark-and-Sweep, Generational, Reference Counting
<ul>
<li> 본인이 사용하는 언어에서는 GC를 어떻게 구현했나요?</li>
# Java GC (Garbage Collection)

## 정의
- Java의 **Garbage Collection**: JVM에서 실행 중인 프로그램의 사용되지 않는 메모리를 자동 회수
- 개발자가 명시적으로 메모리 해제(`free`) 호출 불필요

## 메모리 구조
- **Heap**: 객체가 저장되는 동적 메모리 영역, GC 대상
    - **Young Generation**: 새 객체 (Eden, Survivor)
    - **Old Generation**: 오래된 객체 (Tenured)
    - **Permanent/Metaspace**: 클래스 메타데이터 (Java 8부터 Metaspace로 변경)

## 동작 과정
1. **객체 식별**
    - **Root Set**: 스택, 메서드 영역 등에서 참조 시작점
    - Reachable 객체 추적, Unreachable 객체를 쓰레기로 판별
2. **메모리 회수**
    - Unreachable 객체 제거, 메모리 재할당 가능 상태로 전환

## 주요 GC 알고리즘
1. **Serial GC**
    - 단일 스레드로 GC 수행, 소규모 애플리케이션 적합
2. **Parallel GC**
    - 여러 스레드로 Young 영역 GC, 처리량 중시
3. **CMS (Concurrent Mark-Sweep)**
    - 애플리케이션과 동시에 GC 수행, 지연 시간 감소
    - 단점: 메모리 단편화
4. **G1 (Garbage-First)**
    - 힙을 지역으로 나누어 우선순위 기반 회수
    - 대규모 애플리케이션, 지연 시간/처리량 균형

## Stop-the-World
- GC 실행 중 애플리케이션 일시 중단
- Young GC는 짧고 빈번, Old GC는 길고 드묾

## 튜닝
- `-Xms`, `-Xmx`: 힙 크기 설정
- `-XX:+UseG1GC`: G1 GC 활성화

## 예시
- `Object obj = new Object(); obj = null;` → GC가 `obj` 회수

## 요약
- Java GC는 힙 메모리를 Young/Old로 나누어 관리
- Serial, Parallel, CMS, G1 등 상황별 알고리즘 제공
- 자동 메모리 관리로 편의성 제공, 성능 튜닝 필요
<li> GC의 장단점에 대해 설명해 주세요.</li>
# Java GC의 장단점

## 장점
1. **메모리 누수 방지**
    - 사용되지 않는 객체 자동 회수로 메모리 누수 위험 감소
    - 개발자가 수동 해제 실수 걱정 불필요
2. **개발 생산성 향상**
    - 메모리 관리 코드 작성 필요 없음
    - 비즈니스 로직에 집중 가능
3. **안정성 증가**
    - 동적 메모리 할당/해제를 JVM이 처리
    - 예: `obj = null` 후 GC가 알아서 정리
4. **현대적 최적화**
    - G1, CMS 등 알고리즘으로 성능/지연 시간 개선

## 단점
1. **성능 오버헤드**
    - GC 실행 시 CPU와 메모리 자원 소모
    - 예: 대규모 힙에서 GC 빈번 시 부하 증가
2. **실행 시점 예측 어려움**
    - GC 발생 시점을 개발자가 제어 불가
    - 실시간 시스템에서 문제 가능
3. **Stop-the-World로 인한 지연**
    - GC 중 애플리케이션 중단, 특히 Old GC에서 두드러짐
    - 사용자 경험에 영향 가능
4. **메모리 단편화**
    - CMS 등 일부 GC에서 회수 후 메모리 조각화 발생
    - 연속된 큰 메모리 할당 어려움

## 요약
- **장점**: 메모리 관리 편의성, 안정성, 생산성 향상
- **단점**: 성능 부담, 예측 불가, 지연 및 단편화 문제
- **결론**: GC는 편리하지만, 대규모/실시간 시스템에서는 튜닝 필요
<li> GC는 어떤 영역에 있는 데이터를 관리하나요?</li>
# GC가 관리하는 메모리 영역

## Java 메모리 구조 개요
- JVM은 메모리를 여러 영역으로 나누어 관리
- GC는 특정 영역의 데이터를 대상으로 동작

## GC 대상 영역: Heap
- **Heap**: 동적으로 할당된 객체가 저장되는 메모리
    - **Young Generation**:
        - **Eden**: 새로 생성된 객체
        - **Survivor (S0, S1)**: Eden에서 살아남은 객체
        - 빈번한 Minor GC 발생
    - **Old Generation (Tenured)**:
        - Young에서 오래 살아남은 객체
        - 드문 Major GC 발생
- **역할**: 객체 인스턴스, 배열 등 동적 데이터 저장

## GC가 관리하지 않는 영역
1. **Stack**
    - 메서드 호출 시 지역 변수, 참조 저장
    - 스레드별로 독립, 호출 종료 시 자동 해제
2. **Method Area (또는 Metaspace)**
    - 클래스 메타데이터, 정적 변수 저장
    - Java 8부터 Metaspace로 분리, GC 대상 아님 (별도 관리)
3. **Native Memory**
    - JVM 외부에서 할당된 메모리 (JNI 등)
    - GC 관할 밖

## 요약
- **GC 관리 영역**: Heap (Young + Old)
- **관리 대상**: 동적 객체 (인스턴스, 배열)
- **비대상**: Stack, Method Area/Metaspace, Native Memory
<li> Reference Counting 방식에 대해 설명하고, 이 알고리즘에서 발생할 수 있는 순환 참조 및 Retain Cycle에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>11. 32비트와 64비트의 차이는 무엇인가요?</h3></summary>
# 32비트와 64비트의 차이

## 정의
- **32비트**: 프로세서가 한 번에 처리할 수 있는 데이터 크기가 32비트(4바이트)
- **64비트**: 프로세서가 한 번에 처리할 수 있는 데이터 크기가 64비트(8바이트)

## 주요 차이점
1. **메모리 주소 공간**
    - **32비트**: 최대 2³² = 4GB 메모리 주소 지정 가능
    - **64비트**: 최대 2⁶⁴ = 18.4엑사바이트(약 16EB), 실질적으로 무제한
    - 결과: 64비트는 더 많은 RAM 사용 가능
2. **레지스터 크기**
    - **32비트**: 32비트 레지스터로 데이터 처리
    - **64비트**: 64비트 레지스터로 더 큰 데이터 한 번에 처리
    - 결과: 64비트가 연산 속도 향상
3. **성능**
    - **32비트**: 작은 데이터 처리에 효율적, 경량 애플리케이션 적합
    - **64비트**: 대규모 데이터, 복잡한 연산에 유리
4. **호환성**
    - **32비트**: 64비트 OS에서 실행 가능 (하위 호환)
    - **64비트**: 32비트 OS에서 실행 불가

## 장단점
- **32비트**
    - 장점: 메모리 사용 적음, 구형 하드웨어 지원
    - 단점: 4GB 메모리 제한, 성능 한계
- **64비트**
    - 장점: 대용량 메모리, 고성능 연산
    - 단점: 메모리 사용량 증가, 구형 시스템 비호환

## 요약
- **32비트 vs 64비트**: 주소 공간, 처리 능력, 호환성 차이
- 현대 시스템은 대부분 64비트로 전환 (더 큰 메모리와 성능 필요)
<ul>
<li> 32비트에서 가용한 메모리의 크기는 최대 4GB라고 하는데, 왜 그런걸까요?</li>
# 32비트에서 최대 메모리 크기가 4GB인 이유

## 근본 원인
- **32비트 주소 지정**: 32비트 시스템은 메모리 주소를 32비트로 표현
- **비트 수와 주소 공간**: 2의 거듭제곱으로 계산

## 계산 과정
- **주소 개수**: 32비트 = 2³² 개의 고유 주소
- **2³² = 4,294,967,296**: 약 43억 개의 주소
- **1 주소 = 1바이트**: 메모리 단위로 바이트 사용
- **총 크기**: 4,294,967,296 바이트 = 4GB
    - 1GB = 2³⁰ 바이트 (1,073,741,824 바이트)
    - 4GB = 4 × 1GB = 4,294,967,296 바이트

## 이유 요약
- **제한된 주소 공간**: 32비트로 표현 가능한 최대 값이 4GB이기 때문
- **비트 수 증가 → 주소 증가**: 64비트는 2⁶⁴로 훨씬 큰 주소 공간 제공

## 추가 설명
- **실제 가용 메모리**: OS와 하드웨어 예약(예: 그래픽 카드)으로 4GB 미만일 수 있음
- **PAE (Physical Address Extension)**: 32비트 OS에서 36비트로 확장해 64GB까지 가능하지만, 애플리케이션별 제한 유지

## 결론
- 32비트의 4GB 한계는 2³² 주소 수에서 비롯된 수학적 제약
</ul>
</details>

<details>
  <summary><h3>12. 인증과 인가의 차이에 대해 설명해 주세요.</h3></summary>
<ul>
<li> OAuth가 무엇인지 설명하고, 이것은 인증인지 인가인지에 대해 설명해 주세요.</li>
# OAuth란?

## 정의
- **OAuth**: 애플리케이션이 사용자를 대신해 보호된 자원(리소스)에 접근할 수 있도록 권한을 부여하는 **인가 프레임워크**
- 주로 제3자 애플리케이션이 사용자의 자격 증명 없이 서비스(예: Google, Facebook)에 접근할 때 사용

## 동작 과정
1. **사용자 동의**: 사용자가 애플리케이션에 권한 부여 승인
2. **토큰 발급**: 서비스가 액세스 토큰(Access Token) 발급
3. **리소스 접근**: 애플리케이션이 토큰으로 API 호출
- **예시**: "Google로 로그인" 시 사용자 비밀번호 공유 없이 권한 부여

## 주요 구성 요소
- **Resource Owner**: 사용자
- **Client**: 제3자 애플리케이션
- **Authorization Server**: 토큰 발급 서버
- **Resource Server**: 보호된 데이터 제공 서버

## 인증(Authentication)인가, 인가(Authorization)인가?
- **OAuth는 인가(Authorization)**
    - **인가**: 특정 주체(애플리케이션)가 리소스에 접근할 권한을 부여받는 과정
    - **인증과의 차이**: 인증은 "사용자가 누구인지" 확인(예: ID/비밀번호), OAuth는 "무엇을 할 수 있는지" 정의
- **혼동 이유**: "OAuth 로그인"처럼 인증처럼 보이지만, 실제로는 인증된 사용자의 권한을 토큰으로 전달하는 인가 과정
- **예**: OpenID Connect는 OAuth 위에 인증 레이어를 추가

## 요약
- **OAuth**: 사용자를 대신해 권한을 위임하는 인가 프레임워크
- **인가 중심**: 인증이 아닌 접근 권한 부여에 초점
- **활용**: 소셜 로그인, API 접근 등에서 널리 사용
</ul>
</details>

<details>
  <summary><h3>13. JWT 인증 방식이 무엇인가요?</h3></summary>
# JWT 인증 방식이란?

## 정의
- **JWT (JSON Web Token)**: 사용자 인증 정보를 JSON 형식으로 담아 토큰으로 전달하는 방식
- 클라이언트와 서버 간 인증을 위해 사용, 주로 stateless 환경에서 활용

## 구조
- **3가지 부분** (`.`으로 구분):
    1. **Header**: 토큰 유형(JWT)과 서명 알고리즘(예: HMAC SHA256)
    2. **Payload**: 사용자 정보(클레임, 예: ID, 역할)와 메타데이터(발급 시간, 만료 시간 등)
    3. **Signature**: Header와 Payload를 비밀 키로 서명한 값, 위변조 방지
- **형식**: `xxxxx.yyyyy.zzzzz` (Base64 URL 인코딩)

## 동작 과정
1. **로그인**: 사용자가 ID/비밀번호로 인증
2. **토큰 발급**: 서버가 JWT 생성 후 클라이언트에 전달
3. **요청**: 클라이언트가 HTTP 헤더(예: `Authorization: Bearer <token>`)에 JWT 포함
4. **검증**: 서버가 서명을 확인해 토큰 유효성 검증 후 접근 허용

## 장점
- **Stateless**: 서버가 세션 저장 없이 토큰만으로 인증 처리
- **확장성**: 분산 시스템에서 토큰으로 인증 공유 용이
- **간단함**: JSON 기반으로 가볍고 읽기 쉬움

## 단점
- **토큰 크기**: Payload에 정보 많을수록 크기 증가
- **보안**: 토큰 탈취 시 만료 전까지 사용 가능 (짧은 유효 기간 권장)
- **취소 불가**: 발급 후 서버에서 즉시 무효화 어려움

## 요약
- **JWT**: 인증 정보를 담은 서명된 토큰으로 stateless 인증 제공
- **사용 사례**: API 인증, Single Sign-On (SSO) 등
<ul>
<li> Signature는 어떻게 만들어지나요?</li>
# JWT Signature 생성 방법

## 정의
- **Signature**: JWT의 Header와 Payload를 비밀 키로 서명해 위변조를 방지하는 부분
- 토큰의 무결성과 발급자 신뢰성을 보장

## 생성 과정
1. **Header와 Payload 준비**
    - **Header**: `{ "alg": "HS256", "typ": "JWT" }` → Base64 URL 인코딩
    - **Payload**: `{ "sub": "user123", "exp": 1698765432 }` → Base64 URL 인코딩
    - 예:
        - Header 인코딩: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`
        - Payload 인코딩: `eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNjk4NzY1NDMyfQ`

2. **데이터 결합**
    - 인코딩된 Header와 Payload를 `.`으로 연결
    - 예: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNjk4NzY1NDMyfQ`

3. **서명 생성**
    - **알고리즘 적용**: Header에 명시된 알고리즘(예: HMAC SHA256) 사용
    - **비밀 키**: 서버가 보유한 고유 키(예: "mysecretkey")
    - **수식**: `HMAC-SHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`
    - 결과: 바이트 배열 → Base64 URL 인코딩
    - 예: `dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk`

4. **최종 JWT**
    - `Header.Payload.Signature` 결합
    - 예: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNjk4NzY1NDMyfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk`

## 검증
- 서버는 동일한 비밀 키로 Signature 재생성 후 비교
- 일치 시 토큰 신뢰, 불일치 시 위조로 판단

## 요약
- **Signature**: Header + Payload를 비밀 키로 해시하여 생성
- **목적**: 데이터 무결성 및 인증 보장
<li> 만약 Access Token이 탈취되면, 어떻게 대응할 수 있을까요?</li>
# Access Token 탈취 시 대응 방법

## 문제 상황
- **Access Token 탈취**: 공격자가 토큰을 획득해 권한을 악용 가능
- JWT는 stateless라 서버에서 즉시 무효화 어려움

## 대응 방안
1. **짧은 유효 기간 설정**
    - **방법**: Access Token의 `exp` (만료 시간)을 짧게 설정 (예: 15분~1시간)
    - **효과**: 탈취 후 사용 가능 시간
<li> 반대로 Refresh Token이 탈취되면, 어떻게 대응해야 할까요?</li>
# Refresh Token 탈취 시 대응 방법

## 문제 상황
- **Refresh Token 탈취**: 공격자가 이를 이용해 새로운 Access Token을 무한 발급 가능
- 유효 기간이 길어 Access Token 탈취보다 피해 심각

## 대응 방안
1. **서버에서 Refresh Token 무효화**
    - **방법**: DB나 캐시에 저장된 Refresh Token을 삭제/무효화
    - **효과**: 탈취된 토큰으로 Access Token 발급 차단
    - **필요 조건**: Refresh Token을 서버에서 관리 (UUID 등 고유 식별자 사용)

2. **사용자 세션 강제 종료**
    - **방법**: 해당 사용자의 모든 Refresh Token과 Access Token 무효화
    - **효과**: 공격자 접근 차단, 재로그인 유도
    - **보완**: 사용자에게 알림 (예: 이메일)

3. **짧은 유효 기간 설정**
    - **방법**: Refresh Token도 Access Token처럼 유효 기간 제한 (예: 1일~1주)
    - **효과**: 탈취 후 사용 가능 시간 단축
    - **단점**: 사용자 경험 저하 가능

4. **토큰 회전 (Token Rotation)**
    - **방법**: Refresh Token 사용 시마다 새 토큰 발급, 기존 토큰 무효화
    - **효과**: 탈취된 토큰 단일 사용으로 제한
    - **주의**: 구현 복잡도 증가

5. **클라이언트 검증 강화**
    - **방법**: IP, 디바이스 지문, 사용자 행동 패턴 확인
    - **효과**: 비정상 접근 탐지 및 차단
    - **한계**: 우회 가능성 존재

## 예방 조치
- **안전한 저장**: HttpOnly, Secure 플래그가 있는 쿠키에 저장
- **암호화**: Refresh Token 자체를 암호화해 탈취 시 사용 불가
- **추가 인증**: MFA로 Refresh Token 사용 시 추가 확인 요구

## 요약
- **대응**: 서버 무효화, 세션 종료, 토큰 회전 등으로 피해 최소화
- **핵심**: Refresh Token 관리와 보안 강화로 탈취 위험 줄이기
</ul>
</details>

<details>
  <summary><h3>14. 암호화 알고리즘에 대해 설명해 주세요.</h3></summary>
# 암호화 알고리즘이란?

## 정의
- **암호화 알고리즘**: 데이터를 읽을 수 없는 형태(암호문)로 변환해 보안을 제공하는 수학적 방법
- 기밀성, 무결성, 인증 보장 목적

## 분류
1. **대칭 키 암호화 (Symmetric Encryption)**
    - 동일한 키로 암호화와 복호화
    - **예시**:
        - **AES (Advanced Encryption Standard)**: 128/192/256비트 키, 블록 암호
        - **DES**: 56비트 키, 현재 취약
    - **장점**: 속도 빠름
    - **단점**: 키 공유 문제
2. **비대칭 키 암호화 (Asymmetric Encryption)**
    - 공개 키(암호화)와 개인 키(복호화) 쌍 사용
    - **예시**:
        - **RSA**: 소인수분해 기반, 키 교환/서명에 사용
        - **ECC (Elliptic Curve Cryptography)**: 작은 키로 높은 보안
    - **장점**: 키 배포 쉬움
    - **단점**: 속도 느림
3. **해시 함수 (Hashing)**
    - 데이터를 고정 길이 값(해시)으로 변환, 복호화 불가
    - **예시**:
        - **SHA-256**: 256비트 해시, 무결성 검증
        - **MD5**: 취약, 사용 지양
    - **용도**: 비밀번호 저장, 데이터 무결성 확인

## 동작 원리
- **암호화**: 평문(Plaintext) → 암호문(Ciphertext)
- **복호화**: 암호문 → 평문 (대칭/비대칭만 해당)
- **키**: 알고리즘의 보안 핵심

## 장단점
- **장점**: 데이터 보호, 인증 강화
- **단점**: 계산 비용, 키 관리 복잡성

## 요약
- **암호화 알고리즘**: 대칭(AES), 비대칭(RSA), 해시(SHA-256)로 나뉨
- **목적**: 보안성 확보, 상황별 적합한 방식 선택 필요
<ul>
</details>

<details>
  <summary><h3>15. 문자열 인코딩에 대해 설명해 주세요.</h3></summary>
# 문자열 인코딩이란?

## 정의
- **문자열 인코딩**: 문자를 컴퓨터가 이해할 수 있는 숫자(바이트)로 변환하는 과정
- 텍스트 데이터를 저장, 전송, 처리하기 위해 사용

## 주요 개념
- **문자 집합(Character Set)**: 사용할 문자 목록 (예: ASCII, Unicode)
- **인코딩 방식**: 문자 집합을 바이트로 표현하는 규칙 (예: UTF-8, UTF-16)

## 대표적인 인코딩 방식
1. **ASCII**
    - 7비트로 128개 문자(영문, 숫자, 기호) 표현
    - 예: `A` → 65 (0x41)
    - 한계: 비영어 문자 지원 안 됨
2. **UTF-8 (Unicode Transformation Format-8)**
    - 가변 길이 인코딩, 1~4바이트로 Unicode 문자 표현
    - 예: `A` → 0x41, `가` → 0xEA 0xB0 0x80
    - 장점: ASCII 호환, 효율적
3. **UTF-16**
    - 2바이트 또는 4바이트로 Unicode 문자 표현
    - 예: `가` → 0xAC 0x00
    - 단점: 영문 처리 시 UTF-8보다 비효율
4. **EUC-KR**
    - 한국어 문자 인코딩, 2바이트로 한글 표현
    - 한계: Unicode에 비해 제한적

## 동작 원리
- **인코딩**: 문자 → 바이트 (예: "Hello" → 48 65 6C 6C 6F in UTF-8)
- **디코딩**: 바이트 → 문자 (역방향)
- 잘못된 인코딩 사용 시 "�" 같은 깨짐 현상 발생

## 장단점
- **장점**: 다양한 언어 지원, 데이터 호환성
- **단점**: 인코딩 불일치 시 오류, 저장 공간 차이

## 요약
- **문자열 인코딩**: 문자를 바이트로 변환해 컴퓨터 처리 가능하게 함
- **주요 방식**: ASCII, UTF-8, UTF-16 등 상황별 선택
<ul>
<li> Base64 인코딩은 일반적인 문자열 인코딩과는 달리, 사용자가 읽기 어려운 알파벳과 숫자 조합으로 변경합니다. 이를 사용하는 이유는 무엇일까요?</li>
# Base64 인코딩을 사용하는 이유

## 정의 복습
- **Base64**: 이진 데이터(바이트)를 64개의 ASCII 문자(A-Z, a-z, 0-9, +, /)로 변환하는 인코딩 방식
- 결과는 사람이 읽기 어렵지만, 텍스트 형식으로 표현됨

## 사용 이유
1. **이진 데이터를 텍스트로 변환**
    - **목적**: 이진 데이터(예: 이미지, 파일)를 텍스트만 허용하는 시스템에서 전송/저장
    - **예시**: 이메일(MIME), JSON, XML에 이진 데이터 포함
    - **효과**: 텍스트 기반 프로토콜 호환성 확보

2. **특수 문자 회피**
    - **문제**: 이진 데이터에 제어 문자(예: NULL, newline)가 포함되면 전송 오류 발생 가능
    - **해결**: Base64는 안전한 ASCII 문자만 사용해 데이터 손상 방지

3. **데이터 무결성 유지**
    - **특징**: Base64는 단순 변환(암호화 아님), 원본 데이터 복원 가능
    - **용도**: 전송 중 변형 없이 이진 데이터 전달

## 왜 읽기 어렵게 보이는가?
- **설계 목표**: 인간 가독성보다 이진-텍스트 호환성 우선
- **결과**: `SGVsbG8=` (Hello)처럼 보이지만, 이는 부수적 현상

## 한계
- **크기 증가**: 3바이트가 4바이트로 변환(33% 증가)
- **보안성 없음**: 암호화가 아닌 인코딩, 누구나 디코딩 가능

## 요약
- **Base64 사용 이유**: 이진 데이터를 텍스트로 안전하게 전달하기 위함
- **핵심**: 호환성과 무결성 보장, 가독성은 의도 아님
</details>

<details>
  <summary><h3>16. Git에 대해 설명해 주세요.</h3></summary>
# Git이란?

## 정의
- **Git**: 분산 버전 관리 시스템(Distributed Version Control System)
- 소스 코드 변경 이력을 추적하고, 여러 개발자가 협업할 수 있게 지원

## 주요 특징
- **분산 구조**: 모든 로컬 저장소가 전체 이력 보유, 중앙 서버 의존도 낮음
- **버전 관리**: 파일 변경 사항을 커밋 단위로 기록
- **브랜치**: 독립적인 작업 흐름 생성 및 병합 가능

## 기본 구성 요소
1. **Repository (저장소)**
    - 코드와 이력을 저장하는 공간 (로컬/원격)
2. **Commit**: 변경 사항의 스냅샷
3. **Branch**: 작업 분기점 (예: main, feature)
4. **Merge**: 브랜치 통합

## 주요 명령어
- `git init`: 새 저장소 생성
- `git clone`: 원격 저장소 복제
- `git add`: 변경 사항 스테이징
- `git commit`: 변경 사항 저장
- `git push`: 로컬 변경 사항 원격으로 업로드
- `git pull`: 원격 변경 사항 로컬로 가져오기
- `git branch`: 브랜치 관리

## 장점
- **협업 효율성**: 여러 개발자 동시 작업 가능
- **이력 관리**: 언제든 이전 상태 복원
- **오프라인 작업**: 인터넷 없이도 사용 가능

## 단점
- **학습 곡선**: 초보자에게 명령어 복잡
- **충돌**: 병합 시 수동 해결 필요 가능

## 요약
- **Git**: 분산형 버전 관리 도구로 코드 이력 관리와 협업 최적화
- **활용**: GitHub, GitLab 등 플랫폼과 결합해 널리 사용
<ul>
<li> 여러 브랜치를 합쳐야 할 때, 어떤 방법을 사용할 수 있는지 "모두" 설명해 주세요.</li>

# Git에서 여러 브랜치를 합치는 방법

## 개요
- Git에서 브랜치를 합치는 주요 목표: 변경 사항 통합, 충돌 해결
- 다양한 상황에 따라 적합한 방법 선택 가능

## 1. Merge (병합)
- **설명**: 두 브랜치의 변경 사항을 결합, 새로운 병합 커밋 생성

- **특징**:
- 브랜치 이력 유지
- 충돌 시 수동 해결 필요
- **옵션**:
- `--no-ff`: Fast-Forward 방지, 명시적 병합 커밋 생성
- **사용 시기**: 이력을 명확히 남기고 싶을 때

## 2. Rebase (리베이스)
- **설명**: 한 브랜치의 커밋을 다른 브랜치 위로 재배치, 선형 이력 생성
- **특징**:
- 깔끔한 선형 이력
- 기존 커밋 수정, 공유 브랜치 사용 주의
- **사용 시기**: 깨끗한 이력을 선호할 때

## 3. Fast-Forward Merge
- **설명**: 대상 브랜치가 분기된 이후 변경 없을 시, 포인터만 이동
- **특징**:
- 병합 커밋 없음, 단순 이동
- 이력이 간소화됨
- **사용 시기**: 간단한 브랜치 통합 시

## 4. Cherry-Pick
- **설명**: 특정 커밋만 선택해 현재 브랜치에 적용
- **특징**:
- 개별 커밋 단위 통합
- 전체 브랜치 병합 불필요
- **사용 시기**: 특정 변경만 가져오고 싶을 때

## 5. Squash Merge
- **설명**: 여러 커밋을 하나의 커밋으로 압축해 병합
- **특징**:
- 이력 간소화, 세부 커밋 이력 삭제
- **사용 시기**: 작은 기능 단위로 통합 시

## 6. Octopus Merge
- **설명**: 3개 이상 브랜치를 한 번에 병합
- **특징**:
- 단일 병합 커밋으로 다수 브랜치 통합
- 복잡한 충돌 가능성 증가
- **사용 시기**: 여러 브랜치를 동시에 통합할 때

## 요약
- **Merge**: 이력 유지 병합
- **Rebase**: 선형 이력 재배치
- **Fast-Forward**: 간단 포인터 이동
- **Cherry-Pick**: 선택적 커밋 적용
- **Squash**: 커밋 압축 통합
- **Octopus**: 다중 브랜치 병합
- 상황에 맞는 방법 선택 필요
</details>