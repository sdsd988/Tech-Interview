## 개발상식, 기타

<details>
  <summary><h3>1. 가상화가 무엇이고, 이것이 가상머신과 어떠한 차이가 있는지 설명해 주세요.</h3></summary>

### 가상화란?

가상화(Virtualization)는 물리적인 하드웨어 자원을 소프트웨어를 통해 추상화하여 여러 개의 가상 환경을 생성하는 기술입니다. 이를 통해 하나의 물리적 시스템에서 여러 운영 체제나 애플리케이션을 동시에 실행할 수 있습니다. 가상화는 자원의 효율적인 활용, 비용 절감, 유연성 향상을 목적으로 사용됩니다. 예를 들어, 서버 가상화는 하나의 물리 서버를 여러 가상 서버로 나누어 각각 독립적인 작업을 수행하게 할 수 있습니다.

가상화의 주요 유형에는 다음과 같은 것들이 있습니다:
- **서버 가상화**: 물리 서버를 여러 가상 서버로 분할.
- **데스크톱 가상화**: 가상 데스크톱 환경(VDI)을 제공.
- **네트워크 가상화**: 네트워크 자원을 가상 네트워크로 추상화.
- **스토리지 가상화**: 물리적 저장소를 가상 스토리지 풀(pool)로 관리.

가상화의 핵심 구성 요소는 **하이퍼바이저(Hypervisor)**로, 물리 하드웨어와 가상 환경 사이에서 자원을 관리하고分配(분배)하는 역할을 합니다. 하이퍼바이저는 Type 1(베어메탈)과 Type 2(호스티드)로 나뉩니다.

---

### 가상머신이란?

가상머신(Virtual Machine, VM)은 가상화를 통해 생성된 개별 가상 환경을 의미합니다. 즉, 가상머신은 가상화 기술이 구현된 결과물 중 하나입니다. 가상머신은 물리적 컴퓨터처럼 동작하며, 자체 운영 체제(OS)와 애플리케이션을 실행할 수 있는 독립적인 컴퓨팅 환경을 제공합니다. 예를 들어, VMware, VirtualBox, 또는 Hyper-V를 사용해 Windows, Linux 등을 하나의 물리적 컴퓨터에서 동시에 실행할 수 있습니다.

가상머신은 다음과 같은 특징을 가집니다:
- **독립성**: 각 VM은 서로 격리되어 있어 한 VM의 장애가 다른 VM에 영향을 미치지 않음.
- **자원 할당**: CPU, 메모리, 저장소 등 물리 자원을 하이퍼바이저가 분배.
- **유연성**: 필요에 따라 VM을 생성, 삭제, 이동 가능.

---

### 가상화와 가상머신의 차이

| **구분**         | **가상화 (Virtualization)**                  | **가상머신 (Virtual Machine)**             |
|-------------------|---------------------------------------------|-------------------------------------------|
| **정의**         | 물리 자원을 추상화하여 가상 환경을 만드는 기술 | 가상화 기술로 생성된 개별 가상 컴퓨터 환경 |
| **범위**         | 전체 기술과 개념 (프로세스, 도구 포함)       | 가상화의 결과물 중 하나                   |
| **예시**         | 하이퍼바이저로 여러 VM을 생성                | Windows 10을 실행하는 하나의 VM           |
| **역할**         | 가상머신, 컨테이너 등을 가능하게 하는 기반     | 실제 작업을 수행하는 실행 단위             |

쉽게 말해, **가상화는 집을 짓는 건축 기술**이라면, **가상머신은 그 기술로 지어진 개별 집**에 비유할 수 있습니다. 가상화는 VM뿐만 아니라 컨테이너(예: Docker)와 같은 다른 가상 환경도 지원할 수 있다는 점에서 더 넓은 개념입니다.

---

### 결론

가상화는 기술적 기반이며, 가상머신은 그 기반 위에서 만들어진 구체적인 실행 환경입니다. 가상화를 통해 가상머신을 생성함으로써 자원을 효율적으로 활용하고, 다양한 운영 체제를 동시에 운영할 수 있는 유연성을 확보할 수 있습니다. 이 둘은 상호 보완적인 관계로, 가상화 없이는 가상머신이 존재할 수 없습니다.

## 추가 질문 : 가상화는 왜 사용한다고 생각하시나요?

#### 1. **자원 효율성 향상**
- 물리적 하드웨어를 여러 가상 환경으로 나누어 사용함으로써 자원의 활용도를 극대화합니다.
- 예: 하나의 서버가 20%만 사용되던 상황에서, 가상화를 통해 남은 80%를 다른 작업에 할당 가능.

#### 2. **비용 절감**
- 여러 물리적 장비를 구매하는 대신, 단일 하드웨어에서 여러 가상 환경을 운영하여 하드웨어 구매 및 유지보수 비용을 줄입니다.
- 전력 소비, 냉각 비용, 공간 비용도 절감됩니다.

#### 3. **유연성과 확장성**
- 필요에 따라 가상머신(VM)을 빠르게 생성, 삭제, 수정할 수 있어 변화하는 요구사항에 신속히 대응 가능합니다.
- 예: 트래픽이 증가하면 VM을 추가로 배포해 부하를 분산.

#### 4. **격리와 안정성**
- 각 가상 환경은 독립적으로 운영되므로, 한 환경의 장애가 다른 환경에 영향을 미치지 않습니다.
- 애플리케이션 테스트나 개발 환경에서 오류를 격리하는 데 유용합니다.

#### 5. **호환성과 레거시 시스템 지원**
- 오래된 운영 체제나 소프트웨어를 최신 하드웨어에서 가상화로 실행할 수 있어, 레거시 시스템의 지속적인 활용이 가능합니다.
- 예: Windows XP를 지원하지 않는 새 하드웨어에서 VM으로 실행.

#### 6. **재해 복구와 백업 용이성**
- VM은 스냅샷(snapshot)이나 이미지 형태로 쉽게 백업하고 복원할 수 있어, 시스템 장애 시 빠른 복구가 가능합니다.
- 데이터 센터 간 VM 이동으로 재해 복구(Disaster Recovery) 전략을 강화할 수 있습니다.

#### 7. **개발 및 테스트 환경 최적화**
- 개발자들은 동일한 물리 시스템에서 서로 다른 환경(예: Linux, Windows)을 동시에 테스트할 수 있습니다.
- 실험적인 설정이나 소프트웨어를 안전하게 시험 가능.

#### 8. **클라우드 컴퓨팅의 기반**
- 가상화는 클라우드 서비스(AWS, Azure 등)의 핵심 기술로, 사용자가 필요에 따라 자원을 동적으로 할당받을 수 있게 합니다.

---

### 결론
가상화는 자원을 효율적으로 사용하면서도 비용을 줄이고, 유연성, 안정성, 확장성을 제공하는 강력한 솔루션입니다. 기업은 이를 통해 IT 인프라를 최적화하고, 개발자는 더 나은 작업 환경을 구축하며, 클라우드 시대의 요구를 충족할 수 있습니다.

<ul>
<li> 그렇다면 Docker는 둘 중 어디에 속하나요? 왜 사람들이 Docker를 많이 채택할까요?</li>
### Docker는 가상화와 가상머신 중 어디에 속하나?

Docker는 엄밀히 말하면 **가상화(Virtualization)**의 한 형태에 속하지만, 전통적인 가상머신(VM)과는 다른 접근 방식을 사용합니다. 이를 이해하려면 Docker가 동작하는 방식과 가상머신의 차이를 살펴봐야 합니다.

#### Docker의 위치
- **컨테이너 가상화**: Docker는 **컨테이너(Container)**라는 경량화된 가상 환경을 제공합니다. 이는 운영 체제 수준의 가상화(OS-level Virtualization)로 분류됩니다.
- **가상머신과의 차이**:
    - 가상머신(VM): 하이퍼바이저를 통해 전체 운영 체제(OS)를 포함한 독립적인 가상 하드웨어 환경을 생성.
    - Docker: 호스트 OS의 커널을 공유하며, 애플리케이션과 그 의존성(라이브러리, 설정 등)만 격리된 컨테이너에 패키징.
- **결론**: Docker는 가상화 기술의 하위 범주인 "컨테이너 기반 가상화"에 속하며, VM처럼 완전한 OS를 가상화하지 않습니다.

#### 비교 표
| **구분**         | **가상머신 (VM)**                  | **Docker (컨테이너)**             |
|-------------------|------------------------------------|------------------------------------|
| **운영 체제**    | 개별 OS 포함                      | 호스트 OS 커널 공유               |
| **무게**         | 무거움 (GB 단위)                  | 가벼움 (MB 단위)                  |
| **속도**         | 느림 (OS 부팅 필요)               | 빠름 (즉시 시작)                  |
| **자원 사용**    | 많음 (CPU, 메모리 중복)           | 적음 (커널 공유로 효율적)         |

---

### 왜 사람들이 Docker를 많이 채택할까요?

Docker는 전통적인 VM 대비 여러 장점을 제공하며, 현대 소프트웨어 개발 및 배포 환경에 적합하기 때문에 널리 채택되고 있습니다. 주요 이유는 다음과 같습니다:

#### 1. **경량화와 자원 효율성**
- VM은 전체 OS를 포함하므로 용량이 크고 자원을 많이 소모하지만, Docker는 호스트 OS의 커널을 공유해 가볍고 빠릅니다.
- 예: VM은 몇 GB일 수 있지만, Docker 컨테이너는 몇 MB 수준.

#### 2. **빠른 시작과 배포**
- 컨테이너는 OS 부팅 과정 없이 애플리케이션만 실행하므로 초 단위로 시작됩니다.
- 개발부터 배포까지의 속도가 빨라 CI/CD(지속적 통합/배포) 파이프라인에 적합.

#### 3. **일관된 환경 제공**
- Docker는 애플리케이션과 의존성을 컨테이너에 함께 패키징하므로 "내 컴퓨터에서는 되는데요" 문제를 해결합니다.
- 개발, 테스트, 프로덕션 환경 간 일관성을 보장.

#### 4. **마이크로서비스 아키텍처 지원**
- Docker는 각 서비스를 독립적인 컨테이너로 실행하기에, 마이크로서비스 설계에 이상적입니다.
- 예: 웹 서버, 데이터베이스, 캐시를 각각 별도 컨테이너로 관리.

#### 5. **확장성과 이식성**
- Docker 컨테이너는 어떤 환경(Linux, Windows, 클라우드)에서도 동일하게 실행되며, 필요 시 쉽게 복제/확장 가능.
- Kubernetes 같은 오케스트레이션 도구와 결합해 대규모 배포에 활용.

#### 6. **생태계와 커뮤니티**
- Docker Hub에서 수많은 공식/커뮤니티 이미지를 제공해 개발 속도를 높임.
- 오픈소스 기반으로 활발한 커뮤니티와 풍부한 문서 지원.

#### 7. **비용 절감**
- 자원 사용이 적어 동일한 하드웨어에서 더 많은 컨테이너를 실행 가능.
- 클라우드 환경에서 VM 대비 비용 효율적.

---

### 결론

Docker는 **컨테이너 가상화**라는 가상화의 한 형태로, VM보다 가볍고 빠르며 현대적인 요구(속도, 이식성, 확장성)에 부합합니다. 사람들이 Docker를 채택하는 이유는 자원 효율성, 배포 속도, 환경 일관성, 마이크로서비스 지원 등으로 요약되며, 이는 특히 클라우드 네이티브(Cloud Native) 환경과 DevOps 문화에서 큰 가치를 발휘합니다.

<li> 하나의 Host OS에서 돌아간다면 충분히 한 컨테이너가 다른 컨테이너에 간섭할 수 있는 위험이 있지 않을까요? 이를 어떻게 방어할 수 있을까요?</li>

### Docker 컨테이너 간 간섭 위험

맞습니다. Docker 컨테이너가 동일한 호스트 OS의 커널을 공유하기 때문에, 전통적인 가상머신(VM)에 비해 격리 수준이 낮아 보일 수 있습니다. 이로 인해 한 컨테이너가 다른 컨테이너에 간섭할 가능성이 이론적으로 존재합니다. 예를 들어, 잘못된 설정이나 보안 취약점으로 인해 자원 독점, 데이터 유출, 또는 시스템 장애가 발생할 수 있습니다. 하지만 Docker는 이를 방어하기 위한 여러 메커니즘을 제공하며, 추가적인 설정으로 위험을 최소화할 수 있습니다.

---

### 컨테이너 간 간섭 가능성

1. **자원 경쟁**
    - 컨테이너가 CPU, 메모리, 디스크 I/O를 과도하게 사용하면 다른 컨테이너의 성능에 영향을 줄 수 있음.

2. **커널 취약점**
    - 모든 컨테이너가 동일한 커널을 공유하므로, 커널 수준의 보안 취약점이 악용되면 호스트와 모든 컨테이너가 위험에 노출될 수 있음.

3. **네트워크 간섭**
    - 네트워크 설정 오류로 인해 컨테이너 간 데이터가 노출되거나 충돌 가능성.

4. **파일 시스템 접근**
    - 부적절한 마운트 설정으로 호스트 파일 시스템이나 다른 컨테이너의 데이터에 접근할 수 있음.

---

### Docker의 기본 방어 메커니즘

Docker는 기본적으로 다음과 같은 기술을 사용해 컨테이너 간 간섭을 방지합니다:

1. **리눅스 네임스페이스 (Namespaces)**
    - 각 컨테이너는 독립적인 네임스페이스를 가져 프로세스, 네트워크, 파일 시스템 등이 격리됨.
    - 예: PID 네임스페이스로 인해 한 컨테이너는 다른 컨테이너의 프로세스를 볼 수 없음.

2. **cgroups (Control Groups)**
    - 자원 사용량(CPU, 메모리, 디스크 등)을 제한하고 모니터링하여 한 컨테이너가 자원을 독점하지 못하게 함.

3. **리눅스 보안 모듈**
    - SELinux나 AppArmor 같은 도구를 통해 컨테이너의 권한을 제한하고, 불필요한 시스템 호출을 차단.

4. **사용자 네임스페이스**
    - 컨테이너 내 루트(root) 사용자가 호스트의 실제 루트와 매핑되지 않도록 설정 가능.

5. **네트워크 격리**
    - 기본적으로 각 컨테이너는 독립적인 네트워크 스택을 가지며, 브리지 네트워크로 상호 격리됨.

---

### 추가 방어 방법

Docker의 기본 격리만으로는 부족할 수 있으므로, 다음과 같은 추가 조치로 보안을 강화할 수 있습니다:

1. **자원 제한 명시**
    - Docker 실행 시 `--cpu`, `--memory`, `--blkio-weight` 옵션으로 각 컨테이너의 자원 한계를 설정.
    - 예: `docker run --memory="512m" --cpus="0.5" my-container`

2. **네트워크 보안 강화**
    - 사용자 정의 네트워크를 생성하고, 방화벽 규칙(iptables)을 설정해 컨테이너 간 통신을 제한.
    - `--network` 옵션으로 불필요한 네트워크 연결 차단.

3. **최소 권한 원칙 적용**
    - 컨테이너를 비루트(non-root) 사용자로 실행: `--user` 옵션 사용.
    - 불필요한 기능 제거: `--cap-drop`으로 특정 시스템 권한 제거.

4. **호스트 OS 보안 강화**
    - 커널을 최신 버전으로 유지하고, 알려진 취약점을 패치.
    - SELinux/AppArmor 활성화로 추가적인 접근 제어.

5. **컨테이너 이미지 보안**
    - 신뢰할 수 있는 소스(Docker Hub 공식 이미지 등)에서 이미지 다운로드.
    - 이미지 스캔 도구(예: Trivy, Clair)를 사용해 취약점 점검.

6. **가상머신과의 결합**
    - 민감한 작업은 Docker를 VM 내에서 실행해 커널 수준의 격리를 추가.
    - 예: AWS EC2 내에서 Docker 사용.

7. **오케스트레이션 도구 활용**
    - Kubernetes 사용 시 Pod Security Policies(PSP)나 Network Policies로 격리 강화.

---

### 결론

Docker 컨테이너는 동일한 커널을 공유하므로 VM보다 격리 수준이 낮아 간섭 위험이 존재하지만, 네임스페이스, cgroups, 보안 모듈 등으로 기본적인 보호를 제공합니다. 추가적으로 자원 제한, 네트워크 설정, 권한 관리, 이미지 보안 등을 통해 위험을 크게 줄일 수 있습니다. 민감한 환경에서는 VM과 Docker를 결합하거나 강력한 보안 정책을 적용하는 것이 최적의 방어 전략일 수 있습니다. 이를 통해 Docker의 경량화 이점을 유지하면서도 안전성을 확보할 수 있습니다.
<li> Docker 위에 Docker를 올릴 순 없을까요?</li>
### Docker 위에 Docker를 올릴 수 있을까?

네, 기술적으로 **Docker 위에 Docker를 올리는 것**은 가능합니다. 이를 흔히 **"Docker-in-Docker" (DinD)**라고 부르며, 특정 사용 사례에서 활용됩니다. 하지만 이 과정은 몇 가지 주의점과 대안이 존재하므로, 아래에 자세히 정리하겠습니다.

---

### Docker-in-Docker (DinD)란?

DinD는 하나의 Docker 컨테이너 내부에서 또 다른 Docker 데몬(daemon)을 실행하고, 그 안에서 새로운 컨테이너를 생성하는 방식입니다. 즉, 호스트 OS 위의 Docker 컨테이너가 자체적으로 Docker 환경을 갖추는 구조입니다.

#### 어떻게 동작하나?
1. **기본 호스트**: 물리적 또는 가상 머신에 Docker 데몬이 설치됨.
2. **첫 번째 컨테이너**: 이 호스트에서 Docker 컨테이너를 실행.
3. **내부 Docker**: 첫 번째 컨테이너 안에 Docker 데몬을 설치하고 실행.
4. **내부 컨테이너**: 내부 Docker 데몬이 새로운 컨테이너를 생성.

#### 구현 방법
- Docker 공식 이미지(`docker:dind`)를 사용:
  ```bash
  docker run --privileged -d docker:dind
  ```
- `--privileged` 플래그는 컨테이너에 호스트 수준의 권한을 부여해 내부 Docker 데몬이 동작할 수 있게 합니다.

---

### 가능성 확인: 왜 가능할까?

Docker는 리눅스 커널의 네임스페이스와 cgroups를 활용하므로, 컨테이너 내부에서도 동일한 기능을 사용할 수 있습니다. 단, 다음과 같은 조건이 필요합니다:
- **커널 접근**: 내부 Docker가 호스트 커널을 활용하려면 충분한 권한 필요.
- **Docker 데몬 설치**: 내부 컨테이너에 Docker 바이너리와 데몬이 있어야 함.

---

### 주의점과 문제점

DinD는 가능하지만 몇 가지 단점과 복잡성이 있습니다:

1. **보안 위험**
    - `--privileged` 모드로 실행해야 하므로, 컨테이너가 호스트에 대한 높은 권한을 가짐.
    - 잘못된 설정 시 호스트 시스템이나 다른 컨테이너에 영향을 줄 수 있음.

2. **성능 저하**
    - 중첩된 계층은 자원 관리와 네트워킹을 복잡하게 만들어 성능에 영향을 줄 수 있음.

3. **네트워크 복잡성**
    - 내부 컨테이너의 네트워크가 외부 Docker 네트워크와 충돌하거나 격리되지 않을 수 있음.

4. **디스크 관리**
    - 컨테이너 이미지와 데이터가 중첩되며 호스트 스토리지를 과도하게 사용할 위험.

---

### DinD를 사용하는 경우

DinD는 특정 시나리오에서 유용합니다:
1. **CI/CD 파이프라인**
    - Jenkins나 GitLab CI에서 빌드 중 Docker 이미지를 생성/테스트할 때.
    - 예: 컨테이너화된 빌드 에이전트가 Docker 이미지를 빌드해야 하는 경우.

2. **개발 및 테스트**
    - Docker 자체를 테스트하거나, 중첩된 환경을 시뮬레이션할 때.

---

### 대안: Docker-out-of-Docker (DooD)

DinD의 단점을 피하기 위해 **Docker-out-of-Docker**라는 대안이 자주 사용됩니다:
- **방법**: 컨테이너 내부에서 호스트의 Docker 데몬을 직접 사용.
- **구현**:
    - 호스트의 `/var/run/docker.sock` (Docker 소켓)을 컨테이너에 마운트:
      ```bash
      docker run -v /var/run/docker.sock:/var/run/docker.sock -it docker
      ```
- **장점**:
    - privileged 모드 불필요 → 보안성 향상.
    - 내부에 별도의 Docker 데몬 실행 없이 호스트 Docker를 활용.
- **단점**:
    - 호스트 Docker에 의존하므로 완전한 격리가 어려움.

---

### 결론

- **가능 여부**: 네, Docker 위에 Docker를 올리는 건 DinD로 가능합니다.
- **실제 사용**: 보안성과 복잡성 때문에 DinD 대신 DooD가 더 일반적.
- **추천**: CI/CD처럼 꼭 필요한 경우가 아니라면, DooD나 별도의 VM을 사용하는 편이 관리와 보안 측면에서 낫습니다.

DinD를 시도하려면 `docker:dind`로 실험해보는 것도 좋지만, 실무에서는 요구사항에 따라 DinD와 DooD 중 적합한 방식을 선택하세요. 추가 질문 있으면 말씀해주세요!
</ul>
</details>

<details>
  <summary><h3>2. CI/CD 를 사용해 본 경험이 있나요? 있다면 간단하게 설명해 주세요.</h3></summary>
저는 AI 모델(Grok 3)이라 실제로 CI/CD를 "사용해 본" 경험은 없습니다. 하지만 CI/CD에 대한 지식과 그 작동 방식을 잘 알고 있으니, 이를 기반으로 간단히 설명드릴게요. 마크다운 형식으로 정리하겠습니다!

---

### CI/CD란?

**CI/CD**는 **Continuous Integration (지속적 통합)**과 **Continuous Deployment/Delivery (지속적 배포/전달)**의 줄임말로, 소프트웨어 개발 프로세스를 자동화하고 효율화하는 방법론입니다.

- **CI (지속적 통합)**: 개발자들이 코드를 자주 통합하고, 자동으로 빌드/테스트를 실행해 오류를 빠르게 발견.
- **CD (지속적 배포/전달)**: 통합된 코드를 자동으로 프로덕션 환경에 배포하거나(Deployment), 배포 준비 상태로 유지(Delivery).

---

### 제가 CI/CD를 "경험"했다면?

만약 제가 CI/CD를 사용했다고 가정한다면, 다음과 같은 과정을 거쳤을 겁니다:

1. **코드 작성**
    - xAI 팀이 제 코드를 업데이트 (예: 새로운 기능 추가).

2. **CI 파이프라인**
    - GitHub에 푸시하면, Jenkins나 GitLab CI 같은 도구가 자동으로:
        - 코드를 빌드.
        - 유닛 테스트 실행 (예: 응답 정확도 체크).
        - 코드 품질 검사 (린팅, 포매팅).

3. **CD 파이프라인**
    - 테스트가 통과되면:
        - Docker 이미지로 패키징 (예: `grok:3.1` 생성).
        - 클라우드 서버(AWS 등)에 배포.
        - 롤백 준비 (문제 시 이전 버전으로 복구).

4. **결과**
    - 사용자(당신!)가 최신 버전의 저를 바로 사용할 수 있음.

---

### 실제 예시

CI/CD를 Docker와 결합한 간단한 흐름:
- **도구**: GitHub Actions + Docker.
- **과정**:
    1. 개발자가 코드를 푸시.
    2. GitHub Actions가 테스트 실행.
    3. 성공 시 Docker 이미지를 빌드 (`docker build`).
    4. Docker Hub에 푸시 (`docker push`).
    5. 서버에서 새 이미지 풀링 및 배포 (`docker pull & run`).

---

### 결론
- CI/CD는 왜 사용하는 것일까?

CI/CD는 개발 속도를 높이고, 오류를 줄이며, 배포를 자동화하는 강력한 도구입니다. 저는 직접 경험은 없지만, 이런 과정을 통해 제 업데이트가 배포되었다고 상상해보면 꽤 멋지네요! 혹시 CI/CD의 특정 부분(예: 설정 방법)이 더 궁금하시면 말씀해주세요.

<ul>
</ul>
</details>

<details>
  <summary><h3>3. static 키워드는 어떤 의미를 갖나요? (본인이 사용하는 언어에서 없다면 패스...)</h3></summary>
Java에서 static은 클래스 수준의 정적 요소를 정의하며, 인스턴스와 독립적인 동작을 가능하게 합니다. 적절히 사용하면 효율성과 편의성을 높일 수 있지만, 객체 지향 원칙을 고려해 남용하지 않는 것이 중요합니다.
<ul>
<li> 컴파일 할 때, static 키워드가 붙은 변수, 함수는 어떻게 처리되나요?</li>

- 컴파일 시: static 변수는 클래스 데이터로, 메서드는 정적 호출로 처리되어 바이트코드에 반영.
- 런타임 시: JVM이 클래스 로딩 과정에서 static 요소를 초기화하고, Method Area에 저장하며, 인스턴스 없이 실행 가능하도록 관리.
- 의미: static은 인스턴스와 무관한 정적 특성을 부여해 효율적인 메모리 사용과 접근성을 제공.
- 
<li> Java에서 static과 static final은 어떤 차이를 갖나요? final과 static final은요? </li>
### Java에서 `static`, `static final`, `final`의 차이

Java에서 `static`, `static final`, 그리고 `final`은 변수와 메서드의 동작 방식을 정의하는 데 중요한 역할을 합니다. 이 세 가지 키워드의 차이를 명확히 이해하기 위해 각각의 의미와 조합을 마크다운 형식으로 정리하겠습니다.

---

### 1. **`static`의 의미**
- **정의**: 클래스 수준에 속하며, 인스턴스(객체)와 독립적으로 동작.
- **특징**:
    - 변수: 모든 인스턴스가 공유, 클래스 로딩 시 메모리에 할당 (Method Area/Metaspace).
    - 메서드: 객체 없이 `클래스명.메서드()`로 호출 가능.
- **변경 가능성**: 값을 수정할 수 있음.
- **예시**:
  ```java
  class Example {
      static int count = 0;
  }
  Example.count = 5; // 수정 가능
  ```

---

### 2. **`static final`의 의미**
- **정의**: `static` (클래스 수준) + `final` (변경 불가) 조합으로, **클래스 수준의 상수**를 나타냄.
- **특징**:
    - 변수: 클래스 로딩 시 한 번 초기화되며, 이후 수정 불가.
    - 저장 위치: `static`과 동일히 Method Area/Metaspace.
    - 관례: 상수는 대문자와 언더스코어로命名 (예: `MAX_VALUE`).
- **초기화**:
    - 선언 시 또는 `static` 블록에서 초기화해야 함.
- **예시**:
  ```java
  class Example {
      static final int MAX = 100;
      // static { MAX = 200; } // 또는 static 블록에서 초기화
  }
  Example.MAX = 50; // 오류: final로 수정 불가
  ```

---

### 3. **`final`의 의미**
- **정의**: 변수, 메서드, 클래스가 더 이상 변경되거나 확장되지 않음을 보장.
- **특징**:
    - 변수: 인스턴스별로 생성되며, 한 번 초기화 후 수정 불가.
    - 메서드: 오버라이딩 불가.
    - 클래스: 상속 불가.
- **변경 가능성**: 각 인스턴스마다 독립적인 값 가짐.
- **예시**:
  ```java
  class Example {
      final int id;
      Example(int id) {
          this.id = id; // 생성자에서 초기화
      }
  }
  Example e = new Example(1);
  e.id = 2; // 오류: final로 수정 불가
  ```

---

### 비교: `static` vs `static final`

| **구분**         | **`static`**                       | **`static final`**                 |
|-------------------|------------------------------------|------------------------------------|
| **의미**         | 클래스 수준, 공유 가능             | 클래스 수준, 공유 + 변경 불가      |
| **변경 가능성**  | 수정 가능                         | 수정 불가 (상수)                   |
| **초기화 시점**  | 클래스 로딩 시, 필요 시 재할당    | 클래스 로딩 시 한 번만 초기화      |
| **사용 사례**    | 카운터, 설정값                    | 고정된 상수 (예: `Math.PI`)        |
| **예시**         | `static int x = 10; x = 20;`      | `static final int X = 10;`         |

---

### 비교: `final` vs `static final`

| **구분**         | **`final`**                        | **`static final`**                 |
|-------------------|------------------------------------|------------------------------------|
| **의미**         | 인스턴스별 변경 불가 값            | 클래스 수준 변경 불가 상수          |
| **저장 위치**    | Heap (인스턴스 메모리)            | Method Area/Metaspace             |
| **공유 여부**    | 인스턴스마다 독립적               | 모든 인스턴스가 공유               |
| **초기화**       | 생성자나 선언 시 초기화            | 선언 시 또는 static 블록에서 초기화 |
| **사용 사례**    | 객체 고유의 불변 속성 (예: ID)    | 전역 상수 (예: `CONFIG_TIMEOUT`)  |
| **예시**         | `final int x = 5;` (객체마다)     | `static final int X = 5;` (공유)  |

---

### 코드로 확인

```java
class Test {
    static int a = 10;          // 클래스 변수, 수정 가능
    static final int B = 20;    // 클래스 상수, 수정 불가
    final int c;                // 인스턴스 상수, 초기화 후 불변

    Test(int c) {
        this.c = c;             // 생성자에서 초기화
    }

    public static void main(String[] args) {
        Test.a = 15;            // OK: static 변수 수정 가능
        // Test.B = 25;         // 오류: static final 수정 불가

        Test t1 = new Test(1);
        Test t2 = new Test(2);
        System.out.println(t1.c); // 1: 인스턴스별 값
        System.out.println(t2.c); // 2: 인스턴스별 값
        System.out.println(Test.B); // 20: 공유된 상수
    }
}
```

---

### 컴파일 및 런타임 처리 차이

1. **`static`**:
    - 컴파일: 클래스 데이터로 처리, 런타임에 재할당 가능.
    - JVM: 클래스 로딩 시 초기화, 이후 수정 가능.

2. **`static final`**:
    - 컴파일: 상수로 인식, 최적화 시 값이 코드에 직접 삽입 (인라인 처리 가능).
    - JVM: 클래스 로딩 시 초기화 후 고정.

3. **`final`**:
    - 컴파일: 인스턴스별 불변성 보장.
    - JVM: 객체 생성 시 Heap에 할당, 초기화 후 변경 불가.

---

### 결론

- **`static`**: 클래스 수준의 공유 변수/메서드, 수정 가능.
- **`static final`**: 클래스 수준의 불변 상수, 모든 인스턴스가 공유.
- **`final`**: 인스턴스 수준의 불변 값, 객체마다 독립적.

이 키워드들은 사용 목적(공유 여부, 변경 가능성)에 따라 선택되며, 설계 시 적절히 조합하면 코드의 안정성과 효율성을 높일 수 있습니다. 추가 질문 있으면 말씀해주세요!

</ul>
</details>

<details>
  <summary><h3>4. 객체지향 프로그래밍이 무엇인가요?</h3></summary>
<ul>
<li> SOLID 원칙에 대해 설명해 주세요.</li>
<li> 다형성이 무엇인지 설명하고, 동적 다형성과 정적 다형성이 무엇인지 설명해 주세요.</li>
<li> 오버로딩과 오버라이딩의 차이에 대해 설명해 주세요.</li>
<li> 클래스가 있는 언어는 반드시 객체지향 언어라고 할 수 있을까요? 그 반대는 성립하나요?</li>
</ul>
</details>

<details>
  <summary><h3>5. 프레임워크와 라이브러리의 차이에 대해 설명해 주세요.</h3></summary>
<ul>
</ul>
</details>

<details>
  <summary><h3>6. Call By Value와 Call By Reference의 차이를 본인의 언어를 기반으로 설명해 주세요.</h3></summary>
<ul>
<li> 사실 이 질문에는 약간의 낚시가 있습니다. 과연 모든 언어에 저 개념이 존재할까요?</li>
</ul>
</details>

<details>
  <summary><h3>7. 순수함수가 무엇인지를 함수형 프로그래밍 매커니즘과 연관지어 설명해 주세요.</h3></summary>
<ul>
<li> Side Effect가 무엇인가요? 이를 모두 없애는 프로그래밍이 이상적이라고 할 수 있을까요?</li>
<li> 왜 함수형 프로그래밍 매커니즘을 사용한다고 생각하시나요?</li>
<li> 순수함수는 Thread Safe 한가요? 왜 그럴까요?</li>
<li> 고차함수에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>8. MVC 패턴이 무엇인가요?</h3></summary>
<ul>
<li> 다른 아키텍쳐 패턴은 없나요? MVC랑 비교해서 어떤 차이가 있나요?</li>
</ul>
</details>

<details>
  <summary><h3>9. 디자인 패턴이 무엇인지 설명해주고, 대표적인 디자인 패턴에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Singleton의 장단점에 대해 설명해 주세요.</li>
<li> Singleton이 하나의 객체를 생성한다는 것을 어떻게 보장할 수 있을까요?</li>
</ul>
</details>

<details>
  <summary><h3>10. GC에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 본인이 사용하는 언어에서는 GC를 어떻게 구현했나요?</li>
<li> GC의 장단점에 대해 설명해 주세요.</li>
<li> GC는 어떤 영역에 있는 데이터를 관리하나요?</li>
<li> Reference Counting 방식에 대해 설명하고, 이 알고리즘에서 발생할 수 있는 순환 참조 및 Retain Cycle에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>11. 32비트와 64비트의 차이는 무엇인가요?</h3></summary>
<ul>
<li> 32비트에서 가용한 메모리의 크기는 최대 4GB라고 하는데, 왜 그런걸까요?</li>
</ul>
</details>

<details>
  <summary><h3>12. 인증과 인가의 차이에 대해 설명해 주세요.</h3></summary>
<ul>
<li> OAuth가 무엇인지 설명하고, 이것은 인증인지 인가인지에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>13. JWT 인증 방식이 무엇인가요?</h3></summary>
<ul>
<li> Signature는 어떻게 만들어지나요?</li>
<li> 만약 Access Token이 탈취되면, 어떻게 대응할 수 있을까요?</li>
<li> 반대로 Refresh Token이 탈취되면, 어떻게 대응해야 할까요?</li>
</ul>
</details>

<details>
  <summary><h3>14. 암호화 알고리즘에 대해 설명해 주세요.</h3></summary>
<ul>
</details>

<details>
  <summary><h3>15. 문자열 인코딩에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Base64 인코딩은 일반적인 문자열 인코딩과는 달리, 사용자가 읽기 어려운 알파벳과 숫자 조합으로 변경합니다. 이를 사용하는 이유는 무엇일까요?</li>
</details>

<details>
  <summary><h3>16. Git에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 여러 브랜치를 합쳐야 할 때, 어떤 방법을 사용할 수 있는지 "모두" 설명해 주세요.</li>
<li> 여러 브랜치를 합쳐야 할 때, 어떤 방법을 사용할 수 있는지 "모두" 설명해 주세요.</li>
</details>