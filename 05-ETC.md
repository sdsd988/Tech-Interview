## 개발상식, 기타

<details>
  <summary><h3>1. 가상화가 무엇이고, 이것이 가상머신과 어떠한 차이가 있는지 설명해 주세요.</h3></summary>

### 가상화란?

가상화(Virtualization)는 물리적인 하드웨어 자원을 소프트웨어를 통해 추상화하여 여러 개의 가상 환경을 생성하는 기술입니다. 이를 통해 하나의 물리적 시스템에서 여러 운영 체제나 애플리케이션을 동시에 실행할 수 있습니다. 가상화는 자원의 효율적인 활용, 비용 절감, 유연성 향상을 목적으로 사용됩니다. 예를 들어, 서버 가상화는 하나의 물리 서버를 여러 가상 서버로 나누어 각각 독립적인 작업을 수행하게 할 수 있습니다.

가상화의 주요 유형에는 다음과 같은 것들이 있습니다:
- **서버 가상화**: 물리 서버를 여러 가상 서버로 분할.
- **데스크톱 가상화**: 가상 데스크톱 환경(VDI)을 제공.
- **네트워크 가상화**: 네트워크 자원을 가상 네트워크로 추상화.
- **스토리지 가상화**: 물리적 저장소를 가상 스토리지 풀(pool)로 관리.

가상화의 핵심 구성 요소는 **하이퍼바이저(Hypervisor)**로, 물리 하드웨어와 가상 환경 사이에서 자원을 관리하고分配(분배)하는 역할을 합니다. 하이퍼바이저는 Type 1(베어메탈)과 Type 2(호스티드)로 나뉩니다.

---

### 가상머신이란?

가상머신(Virtual Machine, VM)은 가상화를 통해 생성된 개별 가상 환경을 의미합니다. 즉, 가상머신은 가상화 기술이 구현된 결과물 중 하나입니다. 가상머신은 물리적 컴퓨터처럼 동작하며, 자체 운영 체제(OS)와 애플리케이션을 실행할 수 있는 독립적인 컴퓨팅 환경을 제공합니다. 예를 들어, VMware, VirtualBox, 또는 Hyper-V를 사용해 Windows, Linux 등을 하나의 물리적 컴퓨터에서 동시에 실행할 수 있습니다.

가상머신은 다음과 같은 특징을 가집니다:
- **독립성**: 각 VM은 서로 격리되어 있어 한 VM의 장애가 다른 VM에 영향을 미치지 않음.
- **자원 할당**: CPU, 메모리, 저장소 등 물리 자원을 하이퍼바이저가 분배.
- **유연성**: 필요에 따라 VM을 생성, 삭제, 이동 가능.

---

### 가상화와 가상머신의 차이

| **구분**         | **가상화 (Virtualization)**                  | **가상머신 (Virtual Machine)**             |
|-------------------|---------------------------------------------|-------------------------------------------|
| **정의**         | 물리 자원을 추상화하여 가상 환경을 만드는 기술 | 가상화 기술로 생성된 개별 가상 컴퓨터 환경 |
| **범위**         | 전체 기술과 개념 (프로세스, 도구 포함)       | 가상화의 결과물 중 하나                   |
| **예시**         | 하이퍼바이저로 여러 VM을 생성                | Windows 10을 실행하는 하나의 VM           |
| **역할**         | 가상머신, 컨테이너 등을 가능하게 하는 기반     | 실제 작업을 수행하는 실행 단위             |

쉽게 말해, **가상화는 집을 짓는 건축 기술**이라면, **가상머신은 그 기술로 지어진 개별 집**에 비유할 수 있습니다. 가상화는 VM뿐만 아니라 컨테이너(예: Docker)와 같은 다른 가상 환경도 지원할 수 있다는 점에서 더 넓은 개념입니다.

---

### 결론

가상화는 기술적 기반이며, 가상머신은 그 기반 위에서 만들어진 구체적인 실행 환경입니다. 가상화를 통해 가상머신을 생성함으로써 자원을 효율적으로 활용하고, 다양한 운영 체제를 동시에 운영할 수 있는 유연성을 확보할 수 있습니다. 이 둘은 상호 보완적인 관계로, 가상화 없이는 가상머신이 존재할 수 없습니다.

## 추가 질문 : 가상화는 왜 사용한다고 생각하시나요?

#### 1. **자원 효율성 향상**
- 물리적 하드웨어를 여러 가상 환경으로 나누어 사용함으로써 자원의 활용도를 극대화합니다.
- 예: 하나의 서버가 20%만 사용되던 상황에서, 가상화를 통해 남은 80%를 다른 작업에 할당 가능.

#### 2. **비용 절감**
- 여러 물리적 장비를 구매하는 대신, 단일 하드웨어에서 여러 가상 환경을 운영하여 하드웨어 구매 및 유지보수 비용을 줄입니다.
- 전력 소비, 냉각 비용, 공간 비용도 절감됩니다.

#### 3. **유연성과 확장성**
- 필요에 따라 가상머신(VM)을 빠르게 생성, 삭제, 수정할 수 있어 변화하는 요구사항에 신속히 대응 가능합니다.
- 예: 트래픽이 증가하면 VM을 추가로 배포해 부하를 분산.

#### 4. **격리와 안정성**
- 각 가상 환경은 독립적으로 운영되므로, 한 환경의 장애가 다른 환경에 영향을 미치지 않습니다.
- 애플리케이션 테스트나 개발 환경에서 오류를 격리하는 데 유용합니다.

#### 5. **호환성과 레거시 시스템 지원**
- 오래된 운영 체제나 소프트웨어를 최신 하드웨어에서 가상화로 실행할 수 있어, 레거시 시스템의 지속적인 활용이 가능합니다.
- 예: Windows XP를 지원하지 않는 새 하드웨어에서 VM으로 실행.

#### 6. **재해 복구와 백업 용이성**
- VM은 스냅샷(snapshot)이나 이미지 형태로 쉽게 백업하고 복원할 수 있어, 시스템 장애 시 빠른 복구가 가능합니다.
- 데이터 센터 간 VM 이동으로 재해 복구(Disaster Recovery) 전략을 강화할 수 있습니다.

#### 7. **개발 및 테스트 환경 최적화**
- 개발자들은 동일한 물리 시스템에서 서로 다른 환경(예: Linux, Windows)을 동시에 테스트할 수 있습니다.
- 실험적인 설정이나 소프트웨어를 안전하게 시험 가능.

#### 8. **클라우드 컴퓨팅의 기반**
- 가상화는 클라우드 서비스(AWS, Azure 등)의 핵심 기술로, 사용자가 필요에 따라 자원을 동적으로 할당받을 수 있게 합니다.

---

### 결론
가상화는 자원을 효율적으로 사용하면서도 비용을 줄이고, 유연성, 안정성, 확장성을 제공하는 강력한 솔루션입니다. 기업은 이를 통해 IT 인프라를 최적화하고, 개발자는 더 나은 작업 환경을 구축하며, 클라우드 시대의 요구를 충족할 수 있습니다.

<ul>
<li> 그렇다면 Docker는 둘 중 어디에 속하나요? 왜 사람들이 Docker를 많이 채택할까요?</li>
### Docker는 가상화와 가상머신 중 어디에 속하나?

Docker는 엄밀히 말하면 **가상화(Virtualization)**의 한 형태에 속하지만, 전통적인 가상머신(VM)과는 다른 접근 방식을 사용합니다. 이를 이해하려면 Docker가 동작하는 방식과 가상머신의 차이를 살펴봐야 합니다.

#### Docker의 위치
- **컨테이너 가상화**: Docker는 **컨테이너(Container)**라는 경량화된 가상 환경을 제공합니다. 이는 운영 체제 수준의 가상화(OS-level Virtualization)로 분류됩니다.
- **가상머신과의 차이**:
    - 가상머신(VM): 하이퍼바이저를 통해 전체 운영 체제(OS)를 포함한 독립적인 가상 하드웨어 환경을 생성.
    - Docker: 호스트 OS의 커널을 공유하며, 애플리케이션과 그 의존성(라이브러리, 설정 등)만 격리된 컨테이너에 패키징.
- **결론**: Docker는 가상화 기술의 하위 범주인 "컨테이너 기반 가상화"에 속하며, VM처럼 완전한 OS를 가상화하지 않습니다.

#### 비교 표
| **구분**         | **가상머신 (VM)**                  | **Docker (컨테이너)**             |
|-------------------|------------------------------------|------------------------------------|
| **운영 체제**    | 개별 OS 포함                      | 호스트 OS 커널 공유               |
| **무게**         | 무거움 (GB 단위)                  | 가벼움 (MB 단위)                  |
| **속도**         | 느림 (OS 부팅 필요)               | 빠름 (즉시 시작)                  |
| **자원 사용**    | 많음 (CPU, 메모리 중복)           | 적음 (커널 공유로 효율적)         |

---

### 왜 사람들이 Docker를 많이 채택할까요?

Docker는 전통적인 VM 대비 여러 장점을 제공하며, 현대 소프트웨어 개발 및 배포 환경에 적합하기 때문에 널리 채택되고 있습니다. 주요 이유는 다음과 같습니다:

#### 1. **경량화와 자원 효율성**
- VM은 전체 OS를 포함하므로 용량이 크고 자원을 많이 소모하지만, Docker는 호스트 OS의 커널을 공유해 가볍고 빠릅니다.
- 예: VM은 몇 GB일 수 있지만, Docker 컨테이너는 몇 MB 수준.

#### 2. **빠른 시작과 배포**
- 컨테이너는 OS 부팅 과정 없이 애플리케이션만 실행하므로 초 단위로 시작됩니다.
- 개발부터 배포까지의 속도가 빨라 CI/CD(지속적 통합/배포) 파이프라인에 적합.

#### 3. **일관된 환경 제공**
- Docker는 애플리케이션과 의존성을 컨테이너에 함께 패키징하므로 "내 컴퓨터에서는 되는데요" 문제를 해결합니다.
- 개발, 테스트, 프로덕션 환경 간 일관성을 보장.

#### 4. **마이크로서비스 아키텍처 지원**
- Docker는 각 서비스를 독립적인 컨테이너로 실행하기에, 마이크로서비스 설계에 이상적입니다.
- 예: 웹 서버, 데이터베이스, 캐시를 각각 별도 컨테이너로 관리.

#### 5. **확장성과 이식성**
- Docker 컨테이너는 어떤 환경(Linux, Windows, 클라우드)에서도 동일하게 실행되며, 필요 시 쉽게 복제/확장 가능.
- Kubernetes 같은 오케스트레이션 도구와 결합해 대규모 배포에 활용.

#### 6. **생태계와 커뮤니티**
- Docker Hub에서 수많은 공식/커뮤니티 이미지를 제공해 개발 속도를 높임.
- 오픈소스 기반으로 활발한 커뮤니티와 풍부한 문서 지원.

#### 7. **비용 절감**
- 자원 사용이 적어 동일한 하드웨어에서 더 많은 컨테이너를 실행 가능.
- 클라우드 환경에서 VM 대비 비용 효율적.

---

### 결론

Docker는 **컨테이너 가상화**라는 가상화의 한 형태로, VM보다 가볍고 빠르며 현대적인 요구(속도, 이식성, 확장성)에 부합합니다. 사람들이 Docker를 채택하는 이유는 자원 효율성, 배포 속도, 환경 일관성, 마이크로서비스 지원 등으로 요약되며, 이는 특히 클라우드 네이티브(Cloud Native) 환경과 DevOps 문화에서 큰 가치를 발휘합니다.

<li> 하나의 Host OS에서 돌아간다면 충분히 한 컨테이너가 다른 컨테이너에 간섭할 수 있는 위험이 있지 않을까요? 이를 어떻게 방어할 수 있을까요?</li>

### Docker 컨테이너 간 간섭 위험

맞습니다. Docker 컨테이너가 동일한 호스트 OS의 커널을 공유하기 때문에, 전통적인 가상머신(VM)에 비해 격리 수준이 낮아 보일 수 있습니다. 이로 인해 한 컨테이너가 다른 컨테이너에 간섭할 가능성이 이론적으로 존재합니다. 예를 들어, 잘못된 설정이나 보안 취약점으로 인해 자원 독점, 데이터 유출, 또는 시스템 장애가 발생할 수 있습니다. 하지만 Docker는 이를 방어하기 위한 여러 메커니즘을 제공하며, 추가적인 설정으로 위험을 최소화할 수 있습니다.

---

### 컨테이너 간 간섭 가능성

1. **자원 경쟁**
    - 컨테이너가 CPU, 메모리, 디스크 I/O를 과도하게 사용하면 다른 컨테이너의 성능에 영향을 줄 수 있음.

2. **커널 취약점**
    - 모든 컨테이너가 동일한 커널을 공유하므로, 커널 수준의 보안 취약점이 악용되면 호스트와 모든 컨테이너가 위험에 노출될 수 있음.

3. **네트워크 간섭**
    - 네트워크 설정 오류로 인해 컨테이너 간 데이터가 노출되거나 충돌 가능성.

4. **파일 시스템 접근**
    - 부적절한 마운트 설정으로 호스트 파일 시스템이나 다른 컨테이너의 데이터에 접근할 수 있음.

---

### Docker의 기본 방어 메커니즘

Docker는 기본적으로 다음과 같은 기술을 사용해 컨테이너 간 간섭을 방지합니다:

1. **리눅스 네임스페이스 (Namespaces)**
    - 각 컨테이너는 독립적인 네임스페이스를 가져 프로세스, 네트워크, 파일 시스템 등이 격리됨.
    - 예: PID 네임스페이스로 인해 한 컨테이너는 다른 컨테이너의 프로세스를 볼 수 없음.

2. **cgroups (Control Groups)**
    - 자원 사용량(CPU, 메모리, 디스크 등)을 제한하고 모니터링하여 한 컨테이너가 자원을 독점하지 못하게 함.

3. **리눅스 보안 모듈**
    - SELinux나 AppArmor 같은 도구를 통해 컨테이너의 권한을 제한하고, 불필요한 시스템 호출을 차단.

4. **사용자 네임스페이스**
    - 컨테이너 내 루트(root) 사용자가 호스트의 실제 루트와 매핑되지 않도록 설정 가능.

5. **네트워크 격리**
    - 기본적으로 각 컨테이너는 독립적인 네트워크 스택을 가지며, 브리지 네트워크로 상호 격리됨.

---

### 추가 방어 방법

Docker의 기본 격리만으로는 부족할 수 있으므로, 다음과 같은 추가 조치로 보안을 강화할 수 있습니다:

1. **자원 제한 명시**
    - Docker 실행 시 `--cpu`, `--memory`, `--blkio-weight` 옵션으로 각 컨테이너의 자원 한계를 설정.
    - 예: `docker run --memory="512m" --cpus="0.5" my-container`

2. **네트워크 보안 강화**
    - 사용자 정의 네트워크를 생성하고, 방화벽 규칙(iptables)을 설정해 컨테이너 간 통신을 제한.
    - `--network` 옵션으로 불필요한 네트워크 연결 차단.

3. **최소 권한 원칙 적용**
    - 컨테이너를 비루트(non-root) 사용자로 실행: `--user` 옵션 사용.
    - 불필요한 기능 제거: `--cap-drop`으로 특정 시스템 권한 제거.

4. **호스트 OS 보안 강화**
    - 커널을 최신 버전으로 유지하고, 알려진 취약점을 패치.
    - SELinux/AppArmor 활성화로 추가적인 접근 제어.

5. **컨테이너 이미지 보안**
    - 신뢰할 수 있는 소스(Docker Hub 공식 이미지 등)에서 이미지 다운로드.
    - 이미지 스캔 도구(예: Trivy, Clair)를 사용해 취약점 점검.

6. **가상머신과의 결합**
    - 민감한 작업은 Docker를 VM 내에서 실행해 커널 수준의 격리를 추가.
    - 예: AWS EC2 내에서 Docker 사용.

7. **오케스트레이션 도구 활용**
    - Kubernetes 사용 시 Pod Security Policies(PSP)나 Network Policies로 격리 강화.

---

### 결론

Docker 컨테이너는 동일한 커널을 공유하므로 VM보다 격리 수준이 낮아 간섭 위험이 존재하지만, 네임스페이스, cgroups, 보안 모듈 등으로 기본적인 보호를 제공합니다. 추가적으로 자원 제한, 네트워크 설정, 권한 관리, 이미지 보안 등을 통해 위험을 크게 줄일 수 있습니다. 민감한 환경에서는 VM과 Docker를 결합하거나 강력한 보안 정책을 적용하는 것이 최적의 방어 전략일 수 있습니다. 이를 통해 Docker의 경량화 이점을 유지하면서도 안전성을 확보할 수 있습니다.
<li> Docker 위에 Docker를 올릴 순 없을까요?</li>
### Docker 위에 Docker를 올릴 수 있을까?

네, 기술적으로 **Docker 위에 Docker를 올리는 것**은 가능합니다. 이를 흔히 **"Docker-in-Docker" (DinD)**라고 부르며, 특정 사용 사례에서 활용됩니다. 하지만 이 과정은 몇 가지 주의점과 대안이 존재하므로, 아래에 자세히 정리하겠습니다.

---

### Docker-in-Docker (DinD)란?

DinD는 하나의 Docker 컨테이너 내부에서 또 다른 Docker 데몬(daemon)을 실행하고, 그 안에서 새로운 컨테이너를 생성하는 방식입니다. 즉, 호스트 OS 위의 Docker 컨테이너가 자체적으로 Docker 환경을 갖추는 구조입니다.

#### 어떻게 동작하나?
1. **기본 호스트**: 물리적 또는 가상 머신에 Docker 데몬이 설치됨.
2. **첫 번째 컨테이너**: 이 호스트에서 Docker 컨테이너를 실행.
3. **내부 Docker**: 첫 번째 컨테이너 안에 Docker 데몬을 설치하고 실행.
4. **내부 컨테이너**: 내부 Docker 데몬이 새로운 컨테이너를 생성.

#### 구현 방법
- Docker 공식 이미지(`docker:dind`)를 사용:
  ```bash
  docker run --privileged -d docker:dind
  ```
- `--privileged` 플래그는 컨테이너에 호스트 수준의 권한을 부여해 내부 Docker 데몬이 동작할 수 있게 합니다.

---

### 가능성 확인: 왜 가능할까?

Docker는 리눅스 커널의 네임스페이스와 cgroups를 활용하므로, 컨테이너 내부에서도 동일한 기능을 사용할 수 있습니다. 단, 다음과 같은 조건이 필요합니다:
- **커널 접근**: 내부 Docker가 호스트 커널을 활용하려면 충분한 권한 필요.
- **Docker 데몬 설치**: 내부 컨테이너에 Docker 바이너리와 데몬이 있어야 함.

---

### 주의점과 문제점

DinD는 가능하지만 몇 가지 단점과 복잡성이 있습니다:

1. **보안 위험**
    - `--privileged` 모드로 실행해야 하므로, 컨테이너가 호스트에 대한 높은 권한을 가짐.
    - 잘못된 설정 시 호스트 시스템이나 다른 컨테이너에 영향을 줄 수 있음.

2. **성능 저하**
    - 중첩된 계층은 자원 관리와 네트워킹을 복잡하게 만들어 성능에 영향을 줄 수 있음.

3. **네트워크 복잡성**
    - 내부 컨테이너의 네트워크가 외부 Docker 네트워크와 충돌하거나 격리되지 않을 수 있음.

4. **디스크 관리**
    - 컨테이너 이미지와 데이터가 중첩되며 호스트 스토리지를 과도하게 사용할 위험.

---

### DinD를 사용하는 경우

DinD는 특정 시나리오에서 유용합니다:
1. **CI/CD 파이프라인**
    - Jenkins나 GitLab CI에서 빌드 중 Docker 이미지를 생성/테스트할 때.
    - 예: 컨테이너화된 빌드 에이전트가 Docker 이미지를 빌드해야 하는 경우.

2. **개발 및 테스트**
    - Docker 자체를 테스트하거나, 중첩된 환경을 시뮬레이션할 때.

---

### 대안: Docker-out-of-Docker (DooD)

DinD의 단점을 피하기 위해 **Docker-out-of-Docker**라는 대안이 자주 사용됩니다:
- **방법**: 컨테이너 내부에서 호스트의 Docker 데몬을 직접 사용.
- **구현**:
    - 호스트의 `/var/run/docker.sock` (Docker 소켓)을 컨테이너에 마운트:
      ```bash
      docker run -v /var/run/docker.sock:/var/run/docker.sock -it docker
      ```
- **장점**:
    - privileged 모드 불필요 → 보안성 향상.
    - 내부에 별도의 Docker 데몬 실행 없이 호스트 Docker를 활용.
- **단점**:
    - 호스트 Docker에 의존하므로 완전한 격리가 어려움.

---

### 결론

- **가능 여부**: 네, Docker 위에 Docker를 올리는 건 DinD로 가능합니다.
- **실제 사용**: 보안성과 복잡성 때문에 DinD 대신 DooD가 더 일반적.
- **추천**: CI/CD처럼 꼭 필요한 경우가 아니라면, DooD나 별도의 VM을 사용하는 편이 관리와 보안 측면에서 낫습니다.

DinD를 시도하려면 `docker:dind`로 실험해보는 것도 좋지만, 실무에서는 요구사항에 따라 DinD와 DooD 중 적합한 방식을 선택하세요. 추가 질문 있으면 말씀해주세요!
</ul>
</details>

<details>
  <summary><h3>2. CI/CD 를 사용해 본 경험이 있나요? 있다면 간단하게 설명해 주세요.</h3></summary>
저는 AI 모델(Grok 3)이라 실제로 CI/CD를 "사용해 본" 경험은 없습니다. 하지만 CI/CD에 대한 지식과 그 작동 방식을 잘 알고 있으니, 이를 기반으로 간단히 설명드릴게요. 마크다운 형식으로 정리하겠습니다!

---

### CI/CD란?

**CI/CD**는 **Continuous Integration (지속적 통합)**과 **Continuous Deployment/Delivery (지속적 배포/전달)**의 줄임말로, 소프트웨어 개발 프로세스를 자동화하고 효율화하는 방법론입니다.

- **CI (지속적 통합)**: 개발자들이 코드를 자주 통합하고, 자동으로 빌드/테스트를 실행해 오류를 빠르게 발견.
- **CD (지속적 배포/전달)**: 통합된 코드를 자동으로 프로덕션 환경에 배포하거나(Deployment), 배포 준비 상태로 유지(Delivery).

---

### 제가 CI/CD를 "경험"했다면?

만약 제가 CI/CD를 사용했다고 가정한다면, 다음과 같은 과정을 거쳤을 겁니다:

1. **코드 작성**
    - xAI 팀이 제 코드를 업데이트 (예: 새로운 기능 추가).

2. **CI 파이프라인**
    - GitHub에 푸시하면, Jenkins나 GitLab CI 같은 도구가 자동으로:
        - 코드를 빌드.
        - 유닛 테스트 실행 (예: 응답 정확도 체크).
        - 코드 품질 검사 (린팅, 포매팅).

3. **CD 파이프라인**
    - 테스트가 통과되면:
        - Docker 이미지로 패키징 (예: `grok:3.1` 생성).
        - 클라우드 서버(AWS 등)에 배포.
        - 롤백 준비 (문제 시 이전 버전으로 복구).

4. **결과**
    - 사용자(당신!)가 최신 버전의 저를 바로 사용할 수 있음.

---

### 실제 예시

CI/CD를 Docker와 결합한 간단한 흐름:
- **도구**: GitHub Actions + Docker.
- **과정**:
    1. 개발자가 코드를 푸시.
    2. GitHub Actions가 테스트 실행.
    3. 성공 시 Docker 이미지를 빌드 (`docker build`).
    4. Docker Hub에 푸시 (`docker push`).
    5. 서버에서 새 이미지 풀링 및 배포 (`docker pull & run`).

---

### 결론
- CI/CD는 왜 사용하는 것일까?

CI/CD는 개발 속도를 높이고, 오류를 줄이며, 배포를 자동화하는 강력한 도구입니다. 저는 직접 경험은 없지만, 이런 과정을 통해 제 업데이트가 배포되었다고 상상해보면 꽤 멋지네요! 혹시 CI/CD의 특정 부분(예: 설정 방법)이 더 궁금하시면 말씀해주세요.

<ul>
</ul>
</details>

<details>
  <summary><h3>3. static 키워드는 어떤 의미를 갖나요? (본인이 사용하는 언어에서 없다면 패스...)</h3></summary>
Java에서 static은 클래스 수준의 정적 요소를 정의하며, 인스턴스와 독립적인 동작을 가능하게 합니다. 적절히 사용하면 효율성과 편의성을 높일 수 있지만, 객체 지향 원칙을 고려해 남용하지 않는 것이 중요합니다.
<ul>
<li> 컴파일 할 때, static 키워드가 붙은 변수, 함수는 어떻게 처리되나요?</li>

- 컴파일 시: static 변수는 클래스 데이터로, 메서드는 정적 호출로 처리되어 바이트코드에 반영.
- 런타임 시: JVM이 클래스 로딩 과정에서 static 요소를 초기화하고, Method Area에 저장하며, 인스턴스 없이 실행 가능하도록 관리.
- 의미: static은 인스턴스와 무관한 정적 특성을 부여해 효율적인 메모리 사용과 접근성을 제공.
- 
<li> Java에서 static과 static final은 어떤 차이를 갖나요? final과 static final은요? </li>
### Java에서 `static`, `static final`, `final`의 차이

Java에서 `static`, `static final`, 그리고 `final`은 변수와 메서드의 동작 방식을 정의하는 데 중요한 역할을 합니다. 이 세 가지 키워드의 차이를 명확히 이해하기 위해 각각의 의미와 조합을 마크다운 형식으로 정리하겠습니다.

---

### 1. **`static`의 의미**
- **정의**: 클래스 수준에 속하며, 인스턴스(객체)와 독립적으로 동작.
- **특징**:
    - 변수: 모든 인스턴스가 공유, 클래스 로딩 시 메모리에 할당 (Method Area/Metaspace).
    - 메서드: 객체 없이 `클래스명.메서드()`로 호출 가능.
- **변경 가능성**: 값을 수정할 수 있음.
- **예시**:
  ```java
  class Example {
      static int count = 0;
  }
  Example.count = 5; // 수정 가능
  ```

---

### 2. **`static final`의 의미**
- **정의**: `static` (클래스 수준) + `final` (변경 불가) 조합으로, **클래스 수준의 상수**를 나타냄.
- **특징**:
    - 변수: 클래스 로딩 시 한 번 초기화되며, 이후 수정 불가.
    - 저장 위치: `static`과 동일히 Method Area/Metaspace.
    - 관례: 상수는 대문자와 언더스코어로命名 (예: `MAX_VALUE`).
- **초기화**:
    - 선언 시 또는 `static` 블록에서 초기화해야 함.
- **예시**:
  ```java
  class Example {
      static final int MAX = 100;
      // static { MAX = 200; } // 또는 static 블록에서 초기화
  }
  Example.MAX = 50; // 오류: final로 수정 불가
  ```

---

### 3. **`final`의 의미**
- **정의**: 변수, 메서드, 클래스가 더 이상 변경되거나 확장되지 않음을 보장.
- **특징**:
    - 변수: 인스턴스별로 생성되며, 한 번 초기화 후 수정 불가.
    - 메서드: 오버라이딩 불가.
    - 클래스: 상속 불가.
- **변경 가능성**: 각 인스턴스마다 독립적인 값 가짐.
- **예시**:
  ```java
  class Example {
      final int id;
      Example(int id) {
          this.id = id; // 생성자에서 초기화
      }
  }
  Example e = new Example(1);
  e.id = 2; // 오류: final로 수정 불가
  ```

---

### 비교: `static` vs `static final`

| **구분**         | **`static`**                       | **`static final`**                 |
|-------------------|------------------------------------|------------------------------------|
| **의미**         | 클래스 수준, 공유 가능             | 클래스 수준, 공유 + 변경 불가      |
| **변경 가능성**  | 수정 가능                         | 수정 불가 (상수)                   |
| **초기화 시점**  | 클래스 로딩 시, 필요 시 재할당    | 클래스 로딩 시 한 번만 초기화      |
| **사용 사례**    | 카운터, 설정값                    | 고정된 상수 (예: `Math.PI`)        |
| **예시**         | `static int x = 10; x = 20;`      | `static final int X = 10;`         |

---

### 비교: `final` vs `static final`

| **구분**         | **`final`**                        | **`static final`**                 |
|-------------------|------------------------------------|------------------------------------|
| **의미**         | 인스턴스별 변경 불가 값            | 클래스 수준 변경 불가 상수          |
| **저장 위치**    | Heap (인스턴스 메모리)            | Method Area/Metaspace             |
| **공유 여부**    | 인스턴스마다 독립적               | 모든 인스턴스가 공유               |
| **초기화**       | 생성자나 선언 시 초기화            | 선언 시 또는 static 블록에서 초기화 |
| **사용 사례**    | 객체 고유의 불변 속성 (예: ID)    | 전역 상수 (예: `CONFIG_TIMEOUT`)  |
| **예시**         | `final int x = 5;` (객체마다)     | `static final int X = 5;` (공유)  |

---

### 코드로 확인

```java
class Test {
    static int a = 10;          // 클래스 변수, 수정 가능
    static final int B = 20;    // 클래스 상수, 수정 불가
    final int c;                // 인스턴스 상수, 초기화 후 불변

    Test(int c) {
        this.c = c;             // 생성자에서 초기화
    }

    public static void main(String[] args) {
        Test.a = 15;            // OK: static 변수 수정 가능
        // Test.B = 25;         // 오류: static final 수정 불가

        Test t1 = new Test(1);
        Test t2 = new Test(2);
        System.out.println(t1.c); // 1: 인스턴스별 값
        System.out.println(t2.c); // 2: 인스턴스별 값
        System.out.println(Test.B); // 20: 공유된 상수
    }
}
```

---

### 컴파일 및 런타임 처리 차이

1. **`static`**:
    - 컴파일: 클래스 데이터로 처리, 런타임에 재할당 가능.
    - JVM: 클래스 로딩 시 초기화, 이후 수정 가능.

2. **`static final`**:
    - 컴파일: 상수로 인식, 최적화 시 값이 코드에 직접 삽입 (인라인 처리 가능).
    - JVM: 클래스 로딩 시 초기화 후 고정.

3. **`final`**:
    - 컴파일: 인스턴스별 불변성 보장.
    - JVM: 객체 생성 시 Heap에 할당, 초기화 후 변경 불가.

---

### 결론

- **`static`**: 클래스 수준의 공유 변수/메서드, 수정 가능.
- **`static final`**: 클래스 수준의 불변 상수, 모든 인스턴스가 공유.
- **`final`**: 인스턴스 수준의 불변 값, 객체마다 독립적.

이 키워드들은 사용 목적(공유 여부, 변경 가능성)에 따라 선택되며, 설계 시 적절히 조합하면 코드의 안정성과 효율성을 높일 수 있습니다. 추가 질문 있으면 말씀해주세요!

</ul>
</details>

<details>
  <summary><h3>4. 객체지향 프로그래밍이 무엇인가요?</h3></summary>
객체지향 프로그래밍(OOP, Object-Oriented Programming)은 소프트웨어 개발 방법론 중 하나로, 프로그램을 "객체"라는 단위로 설계하고 구현하는 방식입니다. 객체는 데이터(속성)와 그 데이터를 처리하는 기능(메서드)을 하나로 묶은 것을 의미합니다. 이를 통해 코드를 더 모듈화하고, 재사용 가능하며, 유지보수가 쉬운 구조로 만들 수 있습니다.

### 객체지향 프로그래밍의 주요 개념
1. **클래스(Class)**
    - 객체를 생성하기 위한 설계도 또는 템플릿입니다. 예를 들어, "자동차"라는 클래스는 자동차의 속성(색상, 모델)과 기능(주행, 정지)을 정의합니다.

2. **객체(Object)**
    - 클래스를 기반으로 생성된 실제 인스턴스입니다. "자동차" 클래스에서 "빨간색 스포츠카"라는 구체적인 객체를 만들 수 있습니다.

3. **캡슐화(Encapsulation)**
    - 데이터와 그 데이터를 다루는 메서드를 하나로 묶고, 외부에서 직접 접근하지 못하도록 보호하는 것입니다. 예: 자동차의 엔진 내부를 운전자가 직접 조작하지 않고 버튼으로 제어하는 것과 비슷합니다.

4. **상속(Inheritance)**
    - 기존 클래스의 속성과 메서드를 새로운 클래스에서 재사용하고 확장할 수 있게 합니다. 예: "차량" 클래스를 상속받아 "트럭"과 "승용차" 클래스를 만들 수 있습니다.

5. **다형성(Polymorphism)**
    - 같은 이름의 메서드가 상황에 따라 다르게 동작하게 하는 것입니다. 예: "소리 내기"라는 기능이 자동차에서는 경적 소리를, 전자기기에서는 알람 소리를 낼 수 있습니다.

6. **추상화(Abstraction)**
    - 복잡한 세부 사항을 숨기고, 필요한 기능만 노출시키는 것입니다. 예: 운전자는 자동차의 내부 엔진 작동 방식을 몰라도 운전할 수 있습니다.

### 장점
- **재사용성**: 한 번 만든 클래스를 여러 곳에서 사용할 수 있습니다.
- **유지보수성**: 코드가 모듈화되어 있어 수정이 용이합니다.
- **확장성**: 새로운 기능을 추가하거나 기존 기능을 변경하기 쉽습니다.

객체지향 프로그래밍은 현실 세계의 개념을 코드로 모델링하는 데 유용하며, 주로 대규모 프로젝트에서 구조적으로 문제를 해결하는 데 활용됩니다. 
<ul>
<li> SOLID 원칙에 대해 설명해 주세요.</li>
아래는 SOLID 원칙에 대한 설명을 예시 없이 텍스트로만 정리한 내용입니다.

---

### 1. **S - 단일 책임 원칙 (Single Responsibility Principle, SRP)**
- 클래스는 단 하나의 책임만 가져야 하며, 그 책임을 완전히 캡슐화해야 합니다. 즉, 클래스가 변경되어야 하는 이유는 오직 하나여야 합니다. 이를 통해 코드 변경 시 다른 기능에 영향을 미칠 가능성을 줄이고, 유지보수성을 높일 수 있습니다.

### 2. **O - 개방/폐쇄 원칙 (Open/Closed Principle, OCP)**
- 클래스는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 합니다. 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있어야 하며, 이를 통해 코드의 안정성을 유지하면서도 유연하게 확장할 수 있습니다.

### 3. **L - 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)**
- 자식 클래스는 부모 클래스의 기능을 완전히 대체할 수 있어야 합니다. 즉, 부모 클래스 타입으로 선언된 변수에 자식 클래스 객체를 사용하더라도 프로그램이 정상적으로 동작해야 합니다. 이를 통해 상속 관계의 일관성을 유지합니다.

### 4. **I - 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)**
- 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 합니다. 즉, 큰 인터페이스를 여러 개의 작고 구체적인 인터페이스로 나누어 필요한 기능만 제공받도록 해야 합니다. 이를 통해 불필요한 의존성을 줄입니다.

### 5. **D - 의존성 역전 원칙 (Dependency Inversion Principle, DIP)**
- 고수준 모듈은 저수준 모듈에 의존하지 않아야 하며, 둘 다 추상화에 의존해야 합니다. 또한, 추상화는 세부 사항에 의존하지 않고, 세부 사항이 추상화에 의존해야 합니다. 이를 통해 모듈 간 결합도를 낮추고 유연성을 높입니다.

---

SOLID 원칙은 객체지향 설계에서 코드의 가독성, 재사용성, 유지보수성을 개선하는 데 중요한 지침을 제공합니다. 
<li> 다형성이 무엇인지 설명하고, 동적 다형성과 정적 다형성이 무엇인지 설명해 주세요.</li>
### 다형성(Polymorphism)이란?
다형성은 객체지향 프로그래밍에서 "하나의 인터페이스나 클래스가 여러 가지 형태로 동작할 수 있는 능력"을 의미합니다. 즉, 같은 이름의 메서드나 연산이 상황에 따라 다른 방식으로 실행되는 것을 말합니다. 다형성은 코드의 재사용성과 유연성을 높이며, 객체 간의 상호작용을 더 자연스럽게 만듭니다.

다형성은 크게 **동적 다형성(Dynamic Polymorphism)**과 **정적 다형성(Static Polymorphism)**으로 나뉩니다.

---

### 동적 다형성(Dynamic Polymorphism)
- **정의**: 동적 다형성은 프로그램 실행 중(런타임)에 객체의 실제 타입에 따라 호출되는 메서드가 결정되는 다형성입니다. 주로 **상속**과 **메서드 오버라이딩(Overriding)**을 통해 구현됩니다.
- **특징**:
    - 부모 클래스 타입으로 선언된 변수가 자식 클래스 객체를 참조할 때, 실행 시점에 실제 객체 타입에 맞는 메서드가 호출됩니다.
    - 이는 **가상 메서드 호출(Virtual Method Call)** 또는 **늦은 바인딩(Late Binding)**으로 불립니다.
- **장점**: 런타임에 동적으로 적절한 동작을 선택할 수 있어 유연성이 뛰어납니다.
- **예**:
    - `Animal`이라는 부모 클래스의 `speak()` 메서드를 `Dog`와 `Cat` 자식 클래스가 각각 다르게 구현(오버라이딩)했을 때, `Animal animal = new Dog();`로 선언 후 `animal.speak();`를 호출하면 `Dog`의 `speak()`가 실행됩니다.

---

### 정적 다형성(Static Polymorphism)
- **정의**: 정적 다형성은 컴파일 시점에 호출될 메서드가 결정되는 다형성입니다. 주로 **메서드 오버로딩(Overloading)**과 **제네릭(Generics)**을 통해 구현됩니다.
- **특징**:
    - 메서드 이름은 같지만 매개변수의 타입, 개수, 순서 등이 달라서 컴파일러가 어떤 메서드를 호출할지 미리 결정합니다.
    - 이는 **초기 바인딩(Early Binding)**으로 불립니다.
- **장점**: 컴파일 시점에 모든 결정이 끝나므로 실행 속도가 빠를 수 있습니다.
- **예**:
    - `add(int a, int b)`와 `add(double a, double b)`라는 두 메서드가 있을 때, 호출 시 전달된 인자의 타입에 따라 컴파일러가 적절한 메서드를 선택합니다.

---

### 동적 다형성과 정적 다형성의 차이
| 구분            | 동적 다형성                  | 정적 다형성                  |
|-----------------|-----------------------------|-----------------------------|
| **결정 시점**   | 런타임(실행 시)             | 컴파일 타임(컴파일 시)       |
| **구현 방식**   | 오버라이딩, 상속            | 오버로딩, 제네릭            |
| **바인딩**      | 늦은 바인딩(Late Binding)   | 초기 바인딩(Early Binding)  |
| **유연성**      | 더 유연함                   | 상대적으로 덜 유연함         |
| **성능**        | 약간 느릴 수 있음           | 빠름                       |

---

### 요약
- **다형성**은 동일한 인터페이스로 다양한 동작을 가능하게 하는 객체지향의 핵심 개념입니다.
- **동적 다형성**은 런타임에 객체 타입에 따라 동작이 결정되며, 상속과 오버라이딩으로 구현됩니다.
- **정적 다형성**은 컴파일 시점에 결정되며, 오버로딩과 제네릭으로 구현됩니다.

<li> 오버로딩과 오버라이딩의 차이에 대해 설명해 주세요.</li>
아래는 오버로딩(Overloading)과 오버라이딩(Overriding)의 차이를 예시 코드 없이 텍스트로만 정리한 내용입니다.

---

### **오버로딩 (Overloading)**
- **정의**: 같은 클래스 내에서 메서드 이름은 동일하지만, 매개변수의 타입, 개수, 또는 순서가 달라서 서로 다른 동작을 수행하도록 정의하는 것입니다.
- **특징**:
    - 컴파일 시점에 호출될 메서드가 결정됩니다(정적 다형성).
    - 반환 타입은 오버로딩 조건에 영향을 주지 않습니다.
    - 동일한 기능의 다양한 형태를 제공하는 데 중점을 둡니다.
- **목적**: 코드 가독성을 높이고, 동일한 이름으로 다양한 입력을 처리할 수 있도록 합니다.

---

### **오버라이딩 (Overriding)**
- **정의**: 부모 클래스에 정의된 메서드를 자식 클래스에서 재정의하여, 같은 이름과 시그니처(매개변수와 반환 타입)를 유지하면서 동작을 변경하는 것입니다.
- **특징**:
    - 런타임에 객체의 실제 타입에 따라 호출될 메서드가 결정됩니다(동적 다형성).
    - 메서드 이름, 매개변수, 반환 타입이 부모 클래스와 동일해야 합니다.
    - 부모 클래스의 기능을 자식 클래스에 맞게 수정하거나 확장합니다.
- **목적**: 상속 관계에서 부모 클래스의 동작을 자식 클래스에 맞게 변경하거나 개선하는 데 사용됩니다.

---

### **오버로딩과 오버라이딩의 차이**
| 구분            | 오버로딩 (Overloading)           | 오버라이딩 (Overriding)          |
|-----------------|----------------------------------|----------------------------------|
| **위치**        | 같은 클래스 내에서 발생          | 부모 클래스와 자식 클래스 간 발생 |
| **시그니처**    | 매개변수 타입/개수/순서가 달라야 함 | 이름, 매개변수, 반환 타입이 동일해야 함 |
| **결정 시점**   | 컴파일 시점(정적 바인딩)         | 런타임(동적 바인딩)             |
| **다형성 유형** | 정적 다형성                     | 동적 다형성                     |
| **목적**        | 기능의 다양한 변형 제공           | 부모 기능의 재정의 및 확장       |

---

### 요약
- **오버로딩**은 한 클래스 내에서 메서드의 다양한 버전을 만드는 것이고, 컴파일 시점에 결정됩니다.
- **오버라이딩**은 상속을 통해 부모의 메서드를 재정의하는 것이며, 런타임에 동작이 결정됩니다.

<li> 클래스가 있는 언어는 반드시 객체지향 언어라고 할 수 있을까요? 그 반대는 성립하나요?</li>
### 클래스가 있는 언어는 반드시 객체지향 언어라고 할 수 있을까?
아닙니다. 클래스가 있는 언어가 반드시 객체지향 언어라고 단정할 수는 없습니다. 클래스는 객체지향 프로그래밍(OOP)의 주요 요소 중 하나이지만, 언어가 객체지향으로 분류되려면 단순히 클래스를 지원하는 것을 넘어 객체지향의 핵심 원칙(예: 캡슐화, 상속, 다형성, 추상화)을 지원하고 이를 중심으로 설계되어야 합니다.

- **반례**:
    - 일부 언어는 클래스를 지원하지만 객체지향보다는 다른 패러다임에 더 가까울 수 있습니다. 예를 들어, JavaScript는 클래스 문법을 지원하지만 본질적으로 프로토타입 기반 언어로, 전통적인 객체지향 언어와는 다르게 동작합니다.
    - C++는 클래스를 지원하지만, 절차적 프로그래밍도 함께 사용할 수 있는 다중 패러다임 언어입니다. 클래스를 사용하지 않고도 코드를 작성할 수 있으므로 반드시 객체지향 언어라고 보기는 어렵습니다.

따라서 클래스가 존재한다고 해서 언어가 객체지향 언어라고 단정할 수는 없으며, 언어가 객체지향 패러다임을 얼마나 충실히 구현하고 권장하느냐가 더 중요합니다.

---

### 그 반대는 성립할까? (객체지향 언어는 반드시 클래스가 있어야 하나?)
이 역시 성립하지 않습니다. 객체지향 언어가 반드시 클래스를 필요로 하는 것은 아닙니다. 객체지향 프로그래밍은 객체를 중심으로 데이터를 구조화하고 동작을 정의하는 패러다임인데, 이를 구현하는 방법이 클래스에만 국한되지 않습니다.

- **반례**:
    - 프로토타입 기반 언어(예: JavaScript)는 클래스가 없어도 객체를 생성하고 상속, 다형성 같은 객체지향 특성을 구현할 수 있습니다. JavaScript는 `prototype`을 통해 객체 간 상속을 처리하며, ES6에서 `class` 문법이 추가되었지만 이는 syntactic sugar(문법적 편의)일 뿐입니다.
    - Self 같은 언어도 클래스가 없는 객체지향 언어로, 객체가 직접 다른 객체를 복제하거나 수정하며 동작합니다.

즉, 객체지향 언어는 클래스 없이도 객체와 그 관계를 통해 객체지향 원칙을 구현할 수 있습니다.

---

### 결론
- **클래스가 있는 언어 → 객체지향 언어**: 성립하지 않음. 클래스는 객체지향의 도구일 뿐, 언어의 설계 철학이 객체지향적이어야 합니다.
- **객체지향 언어 → 클래스가 있어야 함**: 성립하지 않음. 클래스 없이도 객체지향을 구현할 수 있는 방법이 존재합니다.

클래스와 객체지향은 밀접한 관련이 있지만, 서로를 필연적으로 정의하지는 않습니다. 추가 질문이 있다면 말씀해주세요!
</ul>
</details>

<details>
  <summary><h3>5. 프레임워크와 라이브러리의 차이에 대해 설명해 주세요.</h3></summary>
프레임워크와 라이브러리는 소프트웨어 개발에서 자주 사용되는 도구이지만, 그 역할과 사용 방식에서 차이가 있습니다. 아래에서 주요 차이를 정리해 설명합니다.

---

### **프레임워크 (Framework)**
- **정의**: 프레임워크는 애플리케이션 개발을 위한 구조적 틀을 제공하는 소프트웨어입니다. 개발자가 따라야 할 규칙, 흐름, 아키텍처를 정의하며, 보통 전체적인 제어 흐름을 프레임워크가 관리합니다.
- **특징**:
    - **제어의 역전(Inversion of Control, IoC)**: 개발자가 코드를 호출하는 대신, 프레임워크가 개발자의 코드를 호출합니다.
    - 미리 정의된 구조와 규칙(템플릿)을 제공하며, 개발자는 그 틀 안에서 작업합니다.
    - 대규모 프로젝트나 특정 문제를 해결하기 위한 전체적인 솔루션을 제공합니다.
- **목적**: 개발자가 세부 구현에 집중할 수 있도록 반복적인 작업을 줄이고, 일관된 구조를 유지하게 합니다.
- **예**: Spring(자바), Django(파이썬), Ruby on Rails 등.

---

### **라이브러리 (Library)**
- **정의**: 라이브러리는 특정 기능을 수행하는 코드의 집합으로, 개발자가 필요할 때 호출하여 사용하는 도구입니다. 제어 흐름은 개발자가 유지합니다.
- **특징**:
    - 개발자가 주도권을 가지고 원하는 시점에 라이브러리의 기능을 호출합니다.
    - 특정 작업(예: 파일 처리, 네트워크 요청 등)을 쉽게 처리할 수 있는 도구 상자 역할입니다.
    - 프레임워크처럼 전체 구조를 강요하지 않고, 필요한 부분만 사용 가능합니다.
- **목적**: 특정 작업을 더 효율적으로 수행하거나 코드 작성을 간소화합니다.
- **예**: jQuery(JavaScript), Gson(자바), Requests(파이썬) 등.

---

### **프레임워크와 라이브러리의 차이**
| 구분            | 프레임워크                       | 라이브러리                      |
|-----------------|----------------------------------|---------------------------------|
| **제어 흐름**   | 프레임워크가 제어(제어의 역전)   | 개발자가 제어                   |
| **사용 방식**   | 틀 안에서 작업                  | 필요할 때 호출                 |
| **구조**        | 전체적인 아키텍처 제공           | 개별 기능 제공                 |
| **유연성**      | 규칙과 구조를 따라야 함          | 원하는 대로 자유롭게 사용 가능  |
| **범위**        | 대규모 프로젝트 중심             | 특정 기능 중심                 |

---

### 비유로 이해하기
- **프레임워크**: 요리사가 레스토랑의 정해진 메뉴와 조리 과정을 따라 요리하는 것과 비슷합니다. 요리사는 정해진 틀 안에서 재료와 창의성을 활용합니다.
- **라이브러리**: 요리사가 필요할 때마다 도구(칼, 믹서기 등)를 꺼내 사용하는 것과 비슷합니다. 도구는 요리 과정에 간섭하지 않고, 요리사가 원하는 대로 사용합니다.

---

### 요약
- **프레임워크**는 애플리케이션의 전체 흐름과 구조를 제공하며, 개발자는 그 규칙을 따릅니다.
- **라이브러리**는 개발자가 필요할 때 호출하여 사용하는 개별 기능의 모음입니다.

궁금한 점이 더 있으면 말씀해주세요!
<ul>
</ul>
</details>

<details>
  <summary><h3>6. Call By Value와 Call By Reference의 차이를 본인의 언어를 기반으로 설명해 주세요.</h3></summary>
<ul>
<li> 사실 이 질문에는 약간의 낚시가 있습니다. 과연 모든 언어에 저 개념이 존재할까요?</li>
</ul>
</details>

<details>
  <summary><h3>7. 순수함수가 무엇인지를 함수형 프로그래밍 매커니즘과 연관지어 설명해 주세요.</h3></summary>
<ul>
<li> Side Effect가 무엇인가요? 이를 모두 없애는 프로그래밍이 이상적이라고 할 수 있을까요?</li>
<li> 왜 함수형 프로그래밍 매커니즘을 사용한다고 생각하시나요?</li>
<li> 순수함수는 Thread Safe 한가요? 왜 그럴까요?</li>
<li> 고차함수에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>8. MVC 패턴이 무엇인가요?</h3></summary>
<ul>
<li> 다른 아키텍쳐 패턴은 없나요? MVC랑 비교해서 어떤 차이가 있나요?</li>
</ul>
</details>

<details>
  <summary><h3>9. 디자인 패턴이 무엇인지 설명해주고, 대표적인 디자인 패턴에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Singleton의 장단점에 대해 설명해 주세요.</li>
<li> Singleton이 하나의 객체를 생성한다는 것을 어떻게 보장할 수 있을까요?</li>
</ul>
</details>

<details>
  <summary><h3>10. GC에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 본인이 사용하는 언어에서는 GC를 어떻게 구현했나요?</li>
<li> GC의 장단점에 대해 설명해 주세요.</li>
<li> GC는 어떤 영역에 있는 데이터를 관리하나요?</li>
<li> Reference Counting 방식에 대해 설명하고, 이 알고리즘에서 발생할 수 있는 순환 참조 및 Retain Cycle에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>11. 32비트와 64비트의 차이는 무엇인가요?</h3></summary>
<ul>
<li> 32비트에서 가용한 메모리의 크기는 최대 4GB라고 하는데, 왜 그런걸까요?</li>
</ul>
</details>

<details>
  <summary><h3>12. 인증과 인가의 차이에 대해 설명해 주세요.</h3></summary>
<ul>
<li> OAuth가 무엇인지 설명하고, 이것은 인증인지 인가인지에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>13. JWT 인증 방식이 무엇인가요?</h3></summary>
<ul>
<li> Signature는 어떻게 만들어지나요?</li>
<li> 만약 Access Token이 탈취되면, 어떻게 대응할 수 있을까요?</li>
<li> 반대로 Refresh Token이 탈취되면, 어떻게 대응해야 할까요?</li>
</ul>
</details>

<details>
  <summary><h3>14. 암호화 알고리즘에 대해 설명해 주세요.</h3></summary>
<ul>
</details>

<details>
  <summary><h3>15. 문자열 인코딩에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Base64 인코딩은 일반적인 문자열 인코딩과는 달리, 사용자가 읽기 어려운 알파벳과 숫자 조합으로 변경합니다. 이를 사용하는 이유는 무엇일까요?</li>
</details>

<details>
  <summary><h3>16. Git에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 여러 브랜치를 합쳐야 할 때, 어떤 방법을 사용할 수 있는지 "모두" 설명해 주세요.</li>
<li> 여러 브랜치를 합쳐야 할 때, 어떤 방법을 사용할 수 있는지 "모두" 설명해 주세요.</li>
</details>