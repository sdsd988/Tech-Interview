## 네트워크

<details>
  <summary>
    <h3>1. 쿠키와 세션의 차이에 대해 설명해 주세요.</h3>
- HTTP는 무상태 프로토콜입니다. 그렇기에, 서버와 클라이언트의 통신은 연속적이지 않습니다. 이를 보완하는 도구가 쿠키와 세션 

| **구분**              | **쿠키 (Cookie)**                                                                | **세션 (Session)**                                                                |
|-----------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| **저장 위치**         | 클라이언트(브라우저) 측에 저장.                                                   | 서버 측에 저장.                                                                 |
| **저장 데이터**       | 문자열(주로 키-값 쌍).                                                           | 클라이언트에 대한 정보를 서버의 메모리나 데이터베이스에 저장.                     |
| **보안**              | 보안에 취약 (클라이언트가 수정 가능).                                              | 상대적으로 보안이 강함 (클라이언트는 세션 ID만 소유).                             |
| **유효 기간**         | 유효 기간을 설정할 수 있으며, 설정에 따라 브라우저 종료 후에도 유지 가능.          | 브라우저가 닫히거나, 세션 타임아웃(기본적으로 일정 시간 동안 활동이 없을 때) 시 삭제. |
| **속도**              | 클라이언트에서 처리되므로 서버 부하가 적음.                                        | 서버에서 관리하므로 서버 부하가 증가할 수 있음.                                    |
| **용량 제한**         | 각 쿠키는 최대 4KB, 도메인당 약 20개 제한.                                          | 제한 없음 (서버 자원에 따라 다름).                                               |
| **주 사용 목적**      | 사용자 설정 정보(예: 테마, 언어), 자동 로그인 등.                                   | 로그인 정보 관리, 사용자 상태 유지 등.                                           |
| **전송 방식**         | HTTP 요청 시마다 클라이언트에서 서버로 자동 전송.                                    | 세션 ID만 전송되며, 정보는 서버에서 관리.                                         |
| **수정 가능 여부**    | 클라이언트 측에서 수정 가능 (브라우저 개발자 도구로 변경 가능).                     | 클라이언트가 직접 수정할 수 없음.                                               |
| **예시**              |  장바구니 유지, 자동 로그인.                                                      |  로그인 상태 유지, 사용자 맞춤 환경 제공.                                        |
</summary>
<ul>
<li> 세션 방식의 로그인 과정에 대해 설명해 주세요.</li>

1. 사용자 인증
   사용자가 로그인 폼에 ID와 비밀번호를 입력하고 서버에 요청을 보냅니다.
   서버는 전달받은 자격 증명을 검증합니다(예: 데이터베이스에 저장된 사용자 정보와 비교).
2. 세션 생성
   인증이 성공하면 서버는 사용자를 고유하게 식별할 수 있는 세션 객체를 생성합니다.
   세션 객체에는 사용자 정보를 저장하거나, 이를 참조할 수 있는 세션 ID가 생성됩니다.
3. 세션 ID 전달
   서버는 생성된 세션 ID를 쿠키를 사용해 클라이언트 브라우저에 전달합니다.
   쿠키에 저장된 세션 ID는 브라우저가 서버에 요청을 보낼 때마다 포함됩니다.
4. 서버에서 세션 관리
   서버는 클라이언트로부터 전달받은 세션 ID를 확인하여, 요청을 보낸 사용자를 식별합니다.
   세션 ID를 통해 저장된 사용자 정보를 참조하여 권한을 확인하거나 특정 작업을 수행합니다.
5. 세션 종료
   사용자가 로그아웃하거나, 세션이 만료되면 서버에서 세션 객체를 삭제합니다.
   세션 만료는 보통 일정 시간이 지나면 자동으로 이루어지며, 이를 세션 타임아웃이라고 합니다.


<li> HTTP의 특성인 Stateless에 대해 설명해 주세요.</li>

HTTP의 특성 중 하나인 `Stateless(무상태성)`는 HTTP 프로토콜이 각 요청(Request)과 응답(Response)을 독립적으로 처리하며, 이전 요청의 상태 정보를 유지하지 않는다는 특징을 말합니다. 이 특성은 HTTP가 간단하고 확장 가능한 프로토콜이 되도록 설계된 중요한 이유 중 하나입니다.

 Stateless의 주요 특징
요청 간 독립성

각 HTTP 요청은 독립적입니다. 이전 요청이나 이후 요청과는 관계없이, 각 요청은 필요한 모든 정보를 포함해야 합니다.
예를 들어, 서버는 이전 요청의 정보를 저장하지 않으므로, 클라이언트는 매 요청마다 인증 정보와 필요한 데이터를 포함해야 합니다.
서버의 상태 관리 없음

서버는 클라이언트와의 세션 상태를 기본적으로 유지하지 않습니다.
클라이언트가 요청을 보낼 때마다, 서버는 요청만 처리하고 응답을 반환한 뒤 상태 정보를 저장하지 않습니다.
확장성(Scalability)

무상태성 덕분에 서버는 클라이언트 상태를 관리할 필요가 없으므로, 서버 간 요청 처리가 간단해지고 확장성이 높아집니다.
서버가 분산 환경이나 로드 밸런싱 환경에서 효율적으로 동작할 수 있습니다.
### 장점

단순함
HTTP가 단순하게 동작하며, 상태를 관리하지 않아도 되는 구조를 유지합니다.

확장성
상태를 저장하지 않으므로, 서버 부하가 줄고 분산 처리나 스케일 아웃(Scale-out)이 쉽습니다.

표준화된 설계
모든 요청이 독립적이기 때문에, 특정 요청이나 응답에 대해 예측 가능하고 명확한 처리가 가능합니다.

단점
상태 유지의 어려움
클라이언트와 서버 간 지속적인 상태를 유지해야 하는 경우, 별도의 상태 관리 기술(세션, 쿠키, JWT 등)이 필요합니다.

데이터 중복
클라이언트는 매 요청마다 필요한 모든 데이터를 서버로 보내야 하므로 데이터가 중복될 수 있습니다.

Stateless 문제 해결 방법
Stateless의 단점을 극복하기 위해 다양한 상태 관리 기법이 활용됩니다:

쿠키(Cookie)
클라이언트가 서버로부터 받은 상태 정보를 브라우저에 저장하고, 이후 요청 시 이를 서버에 다시 전달합니다.

세션(Session)
서버가 상태 정보를 유지하기 위해 고유한 세션 ID를 생성하고, 클라이언트는 이를 쿠키를 통해 서버에 전달합니다.

JWT(Json Web Token)
클라이언트가 상태 정보를 토큰 형태로 저장하고, 요청마다 이를 서버에 전달하여 상태를 관리합니다.

<li> Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?</li>
- 세션은 HTTP의 Stateless 특성과 다소 상반되는 동작을 하지만, HTTP의 설계 원칙을 깨는 것이 아니라 Stateless 특성을 보완하여 인증과 상태 유지를 가능하게 하는 기술입니다. 다만, 애플리케이션의 규모, 보안 요구사항, 성능 요구사항에 따라 세션이 적절하지 않은 경우에는 JWT와 같은 Stateless 인증 방식을 선택하는 것이 더 나을 수 있습니다.
<li> 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?</li>
1. 세션 스티키(Sticky Session)
스티키 세션은 사용자가 처음 연결된 서버와 지속적으로 연결되도록 설정하는 방식입니다.

동작 원리
로드 밸런서가 클라이언트 요청을 항상 동일한 서버로 전달합니다.
이를 위해 로드 밸런서는 클라이언트의 식별자(예: 쿠키, IP)를 기반으로 세션을 "고정"합니다.
장점
구현이 간단하고 추가 저장소가 필요 없습니다.
기존 세션 관리 방식(서버 메모리 사용)을 그대로 사용할 수 있습니다.
단점
특정 서버에 부하가 집중될 수 있습니다.
서버가 장애로 다운되면 해당 사용자의 세션 정보가 손실됩니다.
2. 세션 복제(Session Replication)
   세션 데이터를 서버 간에 공유하는 방식입니다.

동작 원리
각 서버가 생성한 세션 데이터를 클러스터 내의 다른 서버로 복제합니다.
사용자가 요청을 보낸 서버가 달라지더라도, 다른 서버에서 동일한 세션 데이터를 사용할 수 있습니다.
장점
사용자가 어떤 서버에 요청을 보내더라도 동일한 세션 데이터에 접근 가능합니다.
서버 장애 시에도 세션 데이터가 손실되지 않습니다.
단점
서버 간 데이터 동기화로 인해 네트워크 트래픽과 성능 부담이 증가합니다.
구현과 관리가 복잡합니다.
3. 외부 세션 저장소(Distributed Session Store)
   세션 데이터를 서버가 아닌 외부 저장소에 저장하고 모든 서버가 이를 참조하는 방식입니다. Redis, Memcached와 같은 인메모리 데이터베이스가 주로 사용됩니다.

동작 원리
세션 데이터는 중앙 집중형 저장소(예: Redis, Memcached)에 저장됩니다.
서버는 클라이언트 요청에서 전달받은 세션 ID를 사용하여 외부 저장소에서 세션 데이터를 가져옵니다.
장점
확장성이 뛰어나며, 서버가 추가되더라도 세션 관리에 영향을 받지 않습니다.
서버 간 동기화가 필요 없으므로 간단하고 효율적입니다.
세션 데이터를 복구하거나 분석하기 용이합니다.
단점
외부 저장소가 병목이 될 가능성이 있습니다(고성능 저장소가 필요).
저장소 장애 시 모든 세션 데이터가 손실될 수 있으므로 고가용성(HA) 구성이 필요합니다.
4. 세션 없는 인증 방식(JWT 기반 인증)
   세션 관리의 복잡성을 피하기 위해, 서버가 상태를 전혀 유지하지 않는 방식으로 JWT를 사용하는 인증 방법입니다.

동작 원리
인증 정보를 포함한 JWT를 클라이언트에게 전달합니다.
클라이언트는 이후 요청마다 JWT를 포함하여 서버에 보냅니다.
서버는 JWT를 검증하여 사용자 상태를 확인합니다.
장점
서버는 세션 데이터를 유지할 필요가 없으므로 완전한 Stateless를 구현할 수 있습니다.
확장성이 뛰어나며, 분산 환경에 적합합니다.
단점
JWT가 클라이언트에 저장되므로 만료 시간을 짧게 설정하거나, 토큰 재발급 로직을 추가해야 합니다.
JWT 크기가 커지면 네트워크 트래픽에 영향을 미칠 수 있습니다.
</ul>   
</details>

<details>
  <summary><h3>2. HTTP 응답코드에 대해 설명해 주세요.</h3></summary>

HTTP 응답 코드는 클라이언트의 요청에 대한 서버의 처리 결과를 나타내며, 상태 및 오류 상황을 전달하는 데 사용됩니다. 응답 코드는 3자리 숫자로 구성되며, 첫 번째 숫자는 응답의 종류를 나타냅니다. 


<ul>
<li> 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?</li>
- 401은 인증되지 않은 사용자의 접근을, 403은 인증은 되었지만 권한이 없는 경우 응답

<li> 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.</li>
이 둘의 차이점은 200은 이미 존재하는 resource에 대한 요청을 성공적으로 처리했을 때 주로 사용되며, 201은 새로운 resource를 생성하는데에 성공했을 때 사용됩니다.
<li> 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요. </li>
- 그렇지 않다고 생각, 응답 코드는 전체적으로 합의된 코드이다. 이는 사과를 나혼자만 배라고 부르는 것과 같음. 중요한 것은 공유된 지식
</ul>
</details>

<details>
  <summary><h3>3. HTTP Method 에 대해 설명해 주세요.</h3></summary>
- 클라이언트가 서버에 원하는 요청을 나타내는 방법
<ul>
<li> HTTP Method의 멱등성에 대해 설명해 주세요.</li>
- Http Method 요청이 이전과 같은 결과를 보장한다는 뜻, 따라서 생성(POST), 부분수정(PATCH)의 경우 멱등성을 보장하지 않는다.
<li> GET과 POST의 차이는 무엇인가요?</li>
1. 캐시 여부 : Get의 경우 캐싱이 가능하고, Post는 불가
2. 요청 길이의 제한 : Get의 경우 브라우저 별 제한이 있고, POST 없다.
3. 요청 Body의 유무 : GET의 경우 없지만, POST 있다.
4. 멱등성
<li> POST와 PUT, PATCH의 차이는 무엇인가요?</li>
POST는 새로운 자원을 생성한다. PUT은 기존의 데이터를 전체 수정한다.(새로운 자원을 생성하지 않는다.) PATCH는 부분 수정
<li> HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?</li>
캐시 가능성: HTTP GET 요청은 종종 웹 브라우저에 의해 캐시된다. GET 요청을 간단하고 예측 가능하게 유지함으로써, 이러한 시스템이 캐시를 보다 쉽게 관리하고 검색할 수 있다.

안전성: GET 요청은 "안전(safe)" 및 "멱등(idempotent)"이어야 합니다. 이것은 서버에서 어떠한 데이터도 수정하지 않고 부작용이 없어야 함을 의미합니다. GET 요청에서 메시지 바디를 허용하지 않음으로써, GET 요청이 안전하고 멱등하게 유지되도록 보장합니다.

보안성: GET 요청은 종종 서버 로그, 브라우저 히스토리 및 다른 시스템에서 기록됩니다. 데이터를 URL에 유지함으로써, 이를 쉽게 볼 수 있으며, 제3자에게 잠재적으로 가로챌 수 있습니다. 반면, 메시지 바디에 데이터를 포함하는 POST 요청은 덜 가시적이며, 추가적인 보안 계층을 제공할 수 있습니다.
</ul>
</details>

<details>
  <summary><h3>4. HTTP에 대해 설명해 주세요.</h3></summary>
HTTP는 인터넷에서 데이터를 주고받기 위해 사용되는 프로토콜이다. 클라이언트와 서버 간의 통신을 담당하며, 웹 브라우저와 웹 서버 간의 데이터 전송을 위해 주로 사용된다.

HTTP는 요청(Request)과 응답(Response)의 형태로 이루어져 있다. 클라이언트는 HTTP 요청 메시지를 서버에 전송하고, 서버는 이 요청에 대한 응답 메시지를 클라이언트에게 전송한다. 요청과 응답은 각각 헤더와 바디로 구성된다. 헤더는 요청이나 응답에 대한 메타데이터를 포함하고, 바디는 요청이나 응답에 대한 실제 데이터를 포함한다
<ul>
<li> 공개키와 대칭키에 대해 설명해 주세요.</li>
대칭키 암호화 방식은 암복호화에 사용하는 키가 동일한 암호화 방식을 말한다.
공개키 암호화 방식은 암복호화에 사용하는 키가 서로 다른 암호화 방식을 말한다. (비대칭키 암호화라고도 한다.)<li> 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?</li>
<li> SSL과 TLS의 차이는 무엇인가요?</li>
보안 소켓 계층(SSL)은 네트워크상의 두 디바이스 또는 애플리케이션 간에 보안 연결을 생성하는 통신 프로토콜 또는 규칙 세트입니다. 인터넷을 통해 보안 인증이나 데이터를 공유하기 전에 신뢰를 구축하고 상대방을 인증하는 것이 중요합니다. SSL은 애플리케이션 또는 브라우저가 모든 네트워크에서 안전하고 암호화된 통신 채널을 만드는 데 사용할 수 있는 기술입니다. 그러나 SSL은 몇 가지 보안 결함이 있는 오래된 기술입니다. 전송 계층 보안(TLS)은 기존 SSL 취약성을 수정하는 업그레이드된 SSL 버전입니다. TLS는 더 효율적으로 인증하고 암호화된 통신 채널을 계속 지원합니다.</ul>
</details>
<details>
  <summary><h3>5. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.</h3></summary>
웹소켓과 소켓 통신은 네트워크 프로그래밍에서 중요한 역할을 합니다. 이 두 가지는 모두 서버와 클라이언트 간의 데이터 전송을 가능하게 하지만, 그 방식과 용도에서 차이가 있습니다.

소켓 통신은 TCP나 UDP 프로토콜을 사용하여 양방향으로 데이터를 송수신할 수 있는 특징을 가지고 있습니다. 이는 실시간성이 중요한 메신저와 같은 애플리케이션에서 주로 사용됩니다.

웹소켓은 웹 애플리케이션이 서버와 양방향으로 지속적인 통신을 하기 위해 개발된 프로토콜입니다. 이는 주로 웹 브라우저와 서버 간의 실시간 통신을 위해 사용됩니다.

왜냐하면 웹소켓은 기존 소켓보다 경량화되어 있어 메신저와 같은 애플리케이션에서 많이 사용되기 때문입니다.
<ul>
<li> 소켓과 포트의 차이가 무엇인가요?</li>
소켓은 네트워크에서 두 대의 디바이스간의 데이터 송수신을 위한 엔드포인트를 의미하고, 포트는 엔드포인트를 식별할 수 있는 값이다.
<li> 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?</li>
- 답 : 모두 다를 수도 있고, 포트 번호가 같은 소켓이 있을 수도 있습니다. 포트 번호는 하나의 호스트내에서 고유하지만, 하나의 프로세스는 여러 개의 소켓을 열 수 있으므로 같은 IP, 같은 포트수를 가지고 있다 하더라도 여러 개의 소켓이 존재할 수 있습니다.
<li> 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?</li>
</ul>
</details>

<details>
  <summary><h3>6. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?</h3></summary>
답 : HTTP/2의 핵심은 새롭게 추가된 바이너리 프레이밍 계층을 사용해 요청과 응답의 멀티플렉싱을 지원한다는 것입니다. 기존에 HTTP/1.1에서는 연속해서 보낸 요청에 대해서 앞의 요청이 처리 되지 않으면 뒤의 요청의 응답이 지연되는 HOL Blocking 문제가 있었습니다. 하지만 HTTP/2에서는 메시지를 바이너리 형태의 프레임으로 나누고 전송 후, 받은 쪽에서 다시 조립하는 형식을 사용해 HTTP 단의 HOL Blocking 문제를 해결했습니다. 또한 스트림의 우선 순위를 설정해 우선 순위가 더 높은 리소스를 먼저 응답할 수 있으며, HPACK 압축 형식을 사용해 요청과 응답에 쓰이는 헤더의 메타데이터를 압축해서 주고 받는다는 차이가 있습니다.
<ul>
<li> HOL Blocking 에 대해 설명해 주세요.</li>
답 : HTTP/1.1 에서는 Pipelining을 이용해 하나의 요청에 대해 응답을 받고 다음 요청을 보내는 것이 아니라 연속으로 요청을 보내고 그 응답을 차례로 받을 수 있습니다. 하지만 첫 번째 요청에 대한 작업과 응답이 느려지게 되면 그 다음 요청들의 작업들이 완료되어도 지연되는 첫 번째 응답때문에 전체가 느려지게 되는데 이러한 현상을 HOL Blocking이라고 합니다. 물론 HTTP/2에서 이러한 HTTP 단의 HOL Blocking 문제를 해결했지만 결국 TCP 단에서 봤을때는 이는 모두 패킷으로 처리되기 때문에 패킷이 유실되어 발생하는 HOL Blocking 문제는 여전하고 최근에는 이를 해결하는 HTTP/3이 대두되고 있습니다.
<li> HTTP/3.0의 주요 특징에 대해 설명해 주세요.</li>
답 : 가장 큰 특징은 기존에 TCP 기반으로 사용되던 HTTP와 다르게 UDP 기반의 Quick UDP Internet Connection이라 불리는 QUIC 프로토콜을 사용하는 것입니다. 또한 선택적으로 사용했던 TLS를 HTTP/3에서는 필수적으로 사용해야 되며, 첫 연결에는 1RTT의 시간, 이후의 연결에는 이전의 연결에서 사용한 정보를 그대로 사용하기 때문에 0RTT가 필요한 굉장히 빠른 속도를 가지고 있습니다.
</ul>
</details>

<details>
  <summary><h3>7. TCP와 UDP의 차이에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Checksum이 무엇인가요?</li>
답 : 체크섬은 전송된 데이터에 대해서 오류가 있는지 확인하는 수단 중 하나입니다. IP헤더를 예로 들면 패킷을 수신 받은 측은 IP 헤더를 16비트로 모두 나눠 체크섬 값을 제외한 값을 모두 더합니다. 이때 캐리 값이 발생하면 가장 아래에 더하며 마지막에 1의 보수를 취해 주는데 이 값이 수신된 체크섬값과 일치한다면 정상, 아니라면 손실이 발생했다는 것을 짐작할 수 있습니다.
<li> TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?</li>
답 : 둘 다 체크섬을 수행할 수 있지만 TCP의 경우 필수적으로 요구되며, UDP는 선택적입니다.
<li> 그렇다면, Checksum을 통해 오류를 정정할 수 있나요? </li>
답 : 체크섬은 자체는 단순히 오류를 검출하는 역할을 수행합니다. 하지만 TCP에서는 체크섬을 통해 오류가 검출되는 경우 해당 패킷을 버림으로서 해당 패킷의 재전송을 요청할 수 있습니다.
<li> TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.</li>
답 : TCP는 신뢰성을 보장하기 위해 각 데이터에 대해 확인이 되면 다음 데이터를 보내는 방식을 사용합니다. TCP는 데이터 패킷를 세그먼트라는 단위로 쪼개 전송하게 되는데 이 세그먼트들에게 시퀀스 넘버를 부여해 전송합니다. 수신측에서는 받은 세그먼트의 checksum을 계산해 손상되지 않은 데이터인지를 확인하며, 손상 유무에 따라 TCP Flag 응답을 다르게 해 손상된 데이터는 재전송을 요청합니다. 이후 쪼개져서 전달된 세그먼트들은 시퀀스 넘버에 의해 각 순서에 맞게 재조립되기 때문에 신뢰성을 보장할 수 있습니다
<li> TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.</li>
답 : TCP에서는 데이터를 전송하는 윈도우의 크기를 조절함으로서 혼잡 제어를 합니다. 원론적인 방법으로는 윈도우의 크기를 1씩 증가시키다가 혼잡을 감지하면 그 절반으로 줄이는 작업을 반복하는 AIMD 기법과 윈도우의 크기를 두배씩 증가시키다가 혼잡을 감지하면 1로 줄이는 작업을 반복하는 Slow Start 기법이 있습니다. 물론 해당 방법을 그대로 쓰지는 않고 적절하게 조합해서 사용하는데, 대표적으로 Tahoe 방식과 Reno 방식이 있습니다. 이중 하나인 Reno 방식은 윈도우의 크기를 지수적으로 증가시키다가 일정수준이 되면 선형으로 증가시키는데, 이 일정수준을 임계점이라고 합니다. 이후, 3중복-ACK를 감지하게 되면 임계점과 윈도우의 수를 혼잡이 발생한 지점의 절반으로 재설정하고 윈도우의 크기를 선형으로 증가시킵니다. 만약 Time-out이 감지된다면 임계점은 그대로 유지하되, 윈도우의 크기를 1로 드롭시킨 후, 지수적 증가를 하며 혼잡 제어를 하는 기법입니다. 하지만 네트워크 대역폭이 커진 최근에는 Cubic, REC, Elastic TCP 등의 방법이 많이 사용된다고 합니다.
<li> 왜 HTTP는 TCP를 사용하나요?</li>
답 : HTTP는 웹상에서 웹상에서 여러 데이터를 주고받기 위해 사용됩니다. 즉, 사용자에게 제공되어야 할 리소스들을 받게 되는데 이러한 정보들은 유실되거나 손상되면 안됩니다. 때문에 가상 회선 방식으로 데이터를 보내 데이터의 순서를 보장하며, 손실된 패킷에 대해서는 재전송을 요청하는 신뢰도 있는 프로토콜인 TCP를 사용합니다.
<li> 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?</li>
답 : UDP기반의 QUIC 프로토콜을 사용하는 HTTP/3이 이전의 HTTP와 다른 점은 TCP 기반의 HTTP들이 가지는 고질적인 문제인 속도와 HOL Bocking 문제를 해결했다는 것입니다. 위에서 언급한 문제에 대해서는 복수의 스트림을 사용하는 것으로 해결했습니다. 각 데이터에 대해 독립적인 스트림을 사용하기 때문에 어떠한 데이터를 나타내는 패킷이 손상되거나 유실됐다고 하더라도 해당 스트림에만 문제가 있는 것이지, 다른 데이터들의 전송 스트림은 정상적이기 때문에 안전하게 받아 사용할 수 있습니다.
<li> 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?</li>
<li> 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?</li>
답 : UDP를 사용하겠습니다. 기존에 TCP와 UDP는 간단하게 느리지만 신뢰성이 높은 프로토콜과 빠르지만 신뢰성이 낮은 프로토콜로 여겨져왔습니다. 하지만 UDP는 흔히 말하든 흰 도화지같은 프로토콜이기 때문에 개발자의 커스터마이징에 따라 TCP와 비슷한 성능을 낼 수도 있습니다. 개발을 진행할 때, 좋은 기능이 모두 들어간 무거운 라이브러리보다는 필요한 기능만 가지고 있는 가벼운 라이브러리를 선호하는 것과 같이 저 또한 UDP를 선택할 것 <같습니다></같습니다>
</ul>
</details>

<details>
  <summary><h3>8. DHCP가 무엇인지 설명해 주세요.</h3></summary>

정의 : DHCP(Dynamic Host Configuration Protocol)는 네트워크에서 IP 주소를 자동으로 할당하고 관리하는 프로토콜입니다. 
일반적으로 새 장치를 네트워크에 연결하거나 기존 장치의 IP 주소를 변경할 때 사용된다.
장치가 네트워크에 연결되면 IP 주소를 얻기 위해 DHCP 요청을 보내고, 네트워크의 DHCP 서버가 장치가 사용할 수 있는 IP 주소로 응답한다.             
<ul>
<li> DHCP는 몇 계층 프로토콜인가요? </li>

- 애플리케이션 계층 (7계층) 프로토콜 입니다.
<li> DHCP는 어떻게 동작하나요?</li>
1. DHCP discover! 클라이언트가 네트워크에 접속 시도(DHCP 서버에 IP 요청) 
2. DHCP offer(DHCP가 클라이언트의 discover 메세지 수신하고 사용가능한 IP 주소 중 하나를 할당 Offer) 
3. 클라이언트는 서버로부터 부여받은 IP가 사용 가능한지 검증하고, request 메세지를 서버로 보낸다.
4. DHCP 서버는 클라이언트에 인정메세지 보냄
<li> DHCP에서 UDP를 사용하는 이유가 무엇인가요?</li>
DHCP는 기본적으로 일시적 연결을 위한 프로토콜이므로, TCP보다 UDP를 사용한다.
<li> DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?</li>
- 서브넷 마스크, 기본게이트웨이, DNS 정보, 등등
<li> DHCP의 유효기간은 얼마나 긴가요?</li>
- 설정마다 다르다.
</ul>
</details>

<details>
  <summary><h3>9. IP 주소는 무엇이며, 어떤 기능을 하고 있나요?</h3></summary>

<ul>
<li> IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?</li>
<li> IPv4와 IPv6의 차이에 대해 설명해 주세요.</li>
<li> 수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?</li>
<li> IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요? </li>
<li> IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?</li>
<li> IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?</li>
<li> TTL(Hop Limit)이란 무엇인가요? </li>
<li> IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>10. OSI 7계층에 대해 설명해 주세요.</h3></summary>
# OSI 7 계층 정리

OSI 7 계층(Open Systems Interconnection 7 Layer)은 네트워크 통신을 7개의 계층으로 나눈 모델입니다.  
각 계층은 특정 기능을 담당하며, 계층 간에 데이터를 주고받으며 통신이 이루어집니다.

## 🏛 OSI 7 계층 구조

| 계층 | 이름 (한글) | 주요 기능 | 프로토콜 및 장비 |
|------|------------|----------|----------------|
| 7 | 응용 계층 (Application Layer) | 사용자와 네트워크 간 인터페이스 제공 | HTTP, FTP, SMTP, DNS |
| 6 | 표현 계층 (Presentation Layer) | 데이터 형식 변환, 암호화, 압축 | JPEG, GIF, SSL, TLS |
| 5 | 세션 계층 (Session Layer) | 통신 세션 설정, 유지, 종료 | NetBIOS, RPC, PPTP |
| 4 | 전송 계층 (Transport Layer) | 데이터의 신뢰성 보장 (패킷 분할/재조립, 흐름제어, 오류제어) | TCP, UDP |
| 3 | 네트워크 계층 (Network Layer) | 최적의 경로 선택, 논리적 주소(IP) 관리 | IP, ICMP, ARP, 라우터 |
| 2 | 데이터 링크 계층 (Data Link Layer) | MAC 주소를 기반으로 데이터 전송, 오류 감지 및 수정 | Ethernet, MAC, 스위치, 브리지 |
| 1 | 물리 계층 (Physical Layer) | 실제 전기적 신호, 물리적 매체를 통한 데이터 전송 | LAN 케이블, 허브, 리피터 |

## 🔹 계층별 상세 설명

### 1️⃣ 물리 계층 (Physical Layer)
- 데이터가 **전기적 신호(0,1)**로 변환되어 전송됨
- 네트워크 장비 간 **물리적 연결**을 담당
- 대표적인 장비: **LAN 케이블, 허브, 리피터**

### 2️⃣ 데이터 링크 계층 (Data Link Layer)
- **MAC 주소**를 사용하여 같은 네트워크 내 장치 간 데이터 전송
- **오류 감지 및 수정** 기능 제공
- 대표적인 프로토콜 및 장비: **Ethernet, 스위치, 브리지**

### 3️⃣ 네트워크 계층 (Network Layer)
- **IP 주소**를 기반으로 목적지까지 **최적의 경로** 선택
- **라우팅 기능** 제공 (경로 설정 및 패킷 전달)
- 대표적인 프로토콜 및 장비: **IP, ICMP, ARP, 라우터**

### 4️⃣ 전송 계층 (Transport Layer)
- **패킷을 분할 및 재조립**하여 신뢰성 있는 데이터 전송 보장
- **흐름 제어, 오류 제어** 수행
- 대표적인 프로토콜: **TCP(신뢰성 있음), UDP(빠르지만 신뢰성 낮음)**

### 5️⃣ 세션 계층 (Session Layer)
- **통신 세션을 생성, 유지, 종료**하는 역할
- **동기화(Synchronization) 및 체크포인트 기능** 제공
- 대표적인 프로토콜: **NetBIOS, RPC, PPTP**

### 6️⃣ 표현 계층 (Presentation Layer)
- 데이터의 **형식 변환, 암호화, 압축** 수행
- 서로 다른 시스템 간의 **데이터 표현 방식 차이 해결**
- 대표적인 프로토콜: **SSL, TLS, JPEG, GIF**

### 7️⃣ 응용 계층 (Application Layer)
- 사용자와 네트워크 간 **인터페이스 제공**
- 이메일, 웹, 파일 전송 등의 서비스를 담당
- 대표적인 프로토콜: **HTTP, FTP, SMTP, DNS**

## 📝 정리
- OSI 7 계층은 **각각의 역할을 명확하게 분리하여 네트워크 통신을 체계적으로 관리**함.
- 실제 네트워크에서는 **TCP/IP 4계층 모델**이 더 많이 사용됨. (OSI 7계층을 기반으로 단순화된 모델)

<ul>
<li> Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.</li>
# 🚀 Transport Layer vs Network Layer

## ✅ 차이점 요약

| 계층 | 역할 | 주요 기능 | 대표 프로토콜 |
|------|------|----------|--------------|
| **Transport Layer (전송 계층)** | 송·수신 장치 간 **데이터 전송 보장** | 패킷 분할/재조립, 흐름 제어, 오류 제어 | TCP, UDP |
| **Network Layer (네트워크 계층)** | **목적지까지 패킷 전달** | 최적 경로 선택(라우팅), IP 주소 기반 통신 | IP, ICMP, ARP |

## 🎯 쉽게 비유하면?
- **Network Layer** = 📍 "택배사가 최적의 경로로 물건을 배송"
- **Transport Layer** = 📦 "택배가 안전하게 포장되고 손상 없이 도착했는지 확인"

<li> L3 Switch와 Router의 차이에 대해 설명해 주세요.</li>


# 🚀 L3 Switch vs Router
## ✅ 차이점 요약

| 장비 | 역할 | 주요 기능 | 사용 계층 | 주요 사용처 |
|------|------|----------|----------|------------|
| **L3 Switch (레이어 3 스위치)** | 내부 네트워크 간 데이터 전달 (빠름) | VLAN 간 라우팅, MAC + IP 기반 전송 | **3계층 (네트워크 계층)** | 기업 내부망, 데이터센터 |
| **Router (라우터)** | 서로 다른 네트워크 연결 (인터넷 포함) | 최적 경로 선택(라우팅), NAT, 방화벽 기능 | **3계층 (네트워크 계층)** | 인터넷 연결, 광역 네트워크(WAN) |

## 🎯 쉽게 비유하면?
- **L3 Switch** = 🏢 "건물 내부에서 층 간 이동을 빠르게 도와주는 엘리베이터"
- **Router** = 🌍 "다른 도시(네트워크)로 가는 길을 안내하는 내비게이션"

<li> 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.</li>

# 🚀 OSI 7 계층별 데이터 명칭

네트워크에서 데이터가 전송될 때 **각 계층마다 다른 명칭**으로 불립니다.

## ✅ 계층별 데이터 단위

| 계층 | 명칭 | 설명 |
|------|------|----------------------------|
| **7. 응용 계층 (Application Layer)** | 데이터 (Data) | 사용자가 입력한 데이터 |
| **6. 표현 계층 (Presentation Layer)** | 데이터 (Data) | 암호화, 압축된 데이터 |
| **5. 세션 계층 (Session Layer)** | 데이터 (Data) | 세션 관리된 데이터 |
| **4. 전송 계층 (Transport Layer)** | 세그먼트 (Segment, TCP) / 데이터그램 (Datagram, UDP) | 패킷 분할 및 재조립 |
| **3. 네트워크 계층 (Network Layer)** | 패킷 (Packet) | IP 주소 기반 라우팅 |
| **2. 데이터 링크 계층 (Data Link Layer)** | 프레임 (Frame) | MAC 주소 기반 전송 |
| **1. 물리 계층 (Physical Layer)** | 비트 (Bit) | 0과 1의 전기적 신호 |

## 🎯 쉽게 비유하면?
데이터가 목적지까지 가는 과정을 택배 배송 과정에 비유할 수 있습니다.

- **데이터(Data)** → 📝 주문서 작성
- **세그먼트/데이터그램** → 📦 택배 포장
- **패킷(Packet)** → 🚚 배송지 주소 확인
- **프레임(Frame)** → 🏢 건물 내부 배달
- **비트(Bit)** → 📡 전기 신호로 변환 및 전달


<li> 각각의 Header의 Packing Order에 대해 설명해 주세요.</li>



<li> ARP에 대해 설명해 주세요.</li>
# 🚀 ARP (Address Resolution Protocol)

- **ARP**는 **IP 주소**를 **MAC 주소**로 변환하는 프로토콜입니다.
- 네트워크 내에서 **IP 주소**를 알고 있지만 **MAC 주소**를 모를 때 사용됩니다.
- ARP 요청을 브로드캐스트로 보내면, 해당 **IP 주소**를 가진 장치가 **MAC 주소**로 응답합니다.
- 이 정보를 **ARP 테이블**에 저장하여 이후 통신에 사용됩니다.
- ARP는 **로컬 네트워크** 내에서만 동작합니다.

</ul>
</details>

<details>
  <summary><h3>11. 3-Way Handshake에 대해 설명해 주세요.</h3></summary>

# 🚀 3-Way Handshake

- **3-Way Handshake**는 **TCP 연결**을 설정하는 과정입니다.
- **Step 1:** 클라이언트가 **SYN** 패킷을 서버에 보냅니다.
- **Step 2:** 서버는 **SYN-ACK** 패킷으로 응답합니다.
- **Step 3:** 클라이언트가 **ACK** 패킷을 보내면 연결이 확립됩니다.
- 이 과정은 **신뢰성 있는 연결**을 보장하기 위해 사용됩니다.

<ul>
<li> ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?</li>
# 🚀 ACK, SYN 정보 전달

- **전송 방식**: 이 정보들은 **TCP 패킷**의 헤더에 포함되어 전송됩니다.
- **플래그 비트**: SYN, ACK는 **TCP 헤더의 제어 비트**로 설정되어 해당 상태를 나타냅니다.

<li> 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.</li>

# 🚀 2-Way Handshaking을 하지 않는 이유


- **신뢰성 부족**: 2-Way Handshaking은 연결을 설정할 때 **상태 확인**을 하지 않기 때문에 **신뢰성**이 부족합니다.
- **동기화 문제**: 2-Way에서는 클라이언트와 서버 간에 **순서**나 **타이밍**을 확인할 방법이 없어서 통신이 안정적이지 않습니다.
- **연결 확립 부족**: 3-Way Handshaking은 **양쪽 모두**가 연결을 확인하며, 2-Way에서는 한쪽만 연결을 확인할 수 있습니다.
- **3-Way Handshaking**은 양쪽이 연결을 확실하게 설정하여 안정적이고 오류 없는 통신을 보장합니다.

<li> 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?</li>

# 🚀 두 호스트가 동시에 연결을 시도하면 연결이 가능한가요?

- **네, 가능합니다.** TCP 연결은 3-Way Handshake를 통해 이루어지며, 두 호스트가 동시에 연결을 시도할 때도 문제없이 연결을 설정할 수 있습니다.

## ✅ 동시 연결 시 통신 연결 수행 과정

1. A와 B가 동시에 서로에게 SYN 패킷을 보낸다.
   각 호스트의 SYN 패킷에는 자신의 초기 시퀀스 번호(ISN)가 포함되어 있다. 이는 통상적인 연결 요청과 같으나, 양쪽 모두에서 동시에 발생한다.
2. A는 B로부터 SYN 패킷을 받고, 이에 대한 응답으로 SYN-ACK 패킷을 보냔다.
   마찬가지로, B도 A로부터 SYN 패킷을 받고, SYN-ACK 패킷으로 응답한다. 이 단계에서 각 호스트는 상대방의 SYN에 대해 ACK를 보내면서 동시에 자신의 SYN에 대한 ACK도 기대한다.

3. A와 B 모두, 상대방으로부터 받은 SYN-ACK 패킷에 대해 ACK 패킷으로 응답한다.
이때, 각 ACK 패킷은 상대방의 초기 시퀀스 번호에 1을 더한 값을 포함하여, 상대방의 SYN-ACK를 올바르게 수신했음을 확인한다.

이 과정에서 **양쪽 모두** 서로의 연결 요청을 처리하며, 정상적으로 **3-Way Handshake**가 이루어집니다.

<li> SYN Flooding 에 대해 설명해 주세요.</li>
SYN Flooding 은 DDos 의 공격의 한 형태로, 악의적인 목적으로 네트워크 서비스를 중단시키기 위해 사용된다. 이 공격은 3-way handshake 연결 설정 과정을 악용하여 수행된다.
1. 공격자는 대량의 SYN 요청을 목표 서버에게 보내어 서버의 연결 대기 큐를 가득 채운다.
2. 각각의 SYN 요청에 대해 서버는 SYN-ACK 응답을 보내고 클라이언트로부터 ACK 응답을 기다리며 Half-open connection 으로 유지한다.
3. 공격자는 일부러 최종 ACK 를 보내지 않아, 서버의 자원을 소모시키고 새로운 연결 요청을 처리할 수 없게 만든다.

<li> 위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?</li>
- 클라이언트와 서버가 이전에 연결된 적이 있는 경우 사용 가능한 전략, 이전 연결에서 받은 PSK or 세션 티켓을 활용하여 서버와의 재연결을 시도
</ul>
</details>

<details>
  <summary><h3>12. 4-Way Handshake에 대해 설명해 주세요.</h3></summary>
- 4 Way Handshake 는 TCP(Transmission Control Protocol)를 사용하여 클라이언트와 서버 간의 데이터 통신이 완료된 후, 연결을 안전하게 종료하기 위한 과정입니다. 이 과정에서 클라이언트와 서버는 총 4단계의 패킷 교환을 통해 서로에게 연결 종료를 알리고, 자원을 정리하여 다른 연결에 사용할 수 있게 됩니다.
<ul>
<li> 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?</li>
<li> 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?</li>
<li> 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?</li>
<li> 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요? </li>
</ul>
</details>

<details>
  <summary><h3>13. www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.</h3></summary>
   # www.github.com 입력 후 발생하는 네트워크 과정

1. **DNS 조회**: 브라우저는 `www.github.com`의 IP 주소를 알아내기 위해 로컬 DNS 캐시를 확인하거나, 없으면 설정된 DNS 서버에 질의한다.
2. **TCP 3-way 핸드셰이크**: 클라이언트(브라우저)는 서버와 연결을 설정하기 위해 SYN 패킷을 보내고, 서버는 SYN-ACK 패킷으로 응답하며, 클라이언트는 ACK를 보내 연결을 완료한다.
3. **TLS 핸드셰이크**: HTTPS를 사용하므로 TLS 핸드셰이크를 수행하여 암호화된 통신을 위한 보안 세션을 설정한다.
4. **HTTP 요청 전송**: 브라우저는 `GET / HTTP/1.1` 요청을 `github.com`의 서버에 전송한다.
5. **웹 서버 처리**: GitHub의 웹 서버는 요청을 받아 필요한 데이터를 조회하고 응답을 생성한다.
6. **HTTP 응답 전송**: 서버는 HTML, CSS, JavaScript 등의 리소스를 포함한 HTTP 응답을 브라우저에 보낸다.
7. **브라우저 렌더링**: 브라우저는 HTML을 파싱하고, CSS 및 JavaScript를 로드하여 페이지를 렌더링한다.
8. **추가 리소스 요청**: 필요한 이미지, 글꼴 등의 추가 리소스를 서버에서 가져와 완전한 페이지를 구성한다.
9. **인터랙션 가능 상태**: 사용자는 GitHub 웹사이트를 탐색하고 추가 요청을 보낼 수 있다.

<ul>
<li> DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?</li>

DNS 쿼리란
# DNS 쿼리란?

1. **DNS(도메인 네임 시스템) 역할**: 도메인 이름(예: `www.github.com`)을 IP 주소(예: `140.82.113.3`)로 변환하는 시스템이다.
2. **DNS 쿼리란?**: 사용자가 웹사이트에 접속하려 할 때, 브라우저나 OS가 해당 도메인의 IP 주소를 찾기 위해 DNS 서버에 보내는 요청이다. 즉 도메인 이름을 IP 주소로 변환하는 요청.
3. **쿼리 과정**:
   - 브라우저는 먼저 로컬 DNS 캐시에서 IP 주소를 찾는다.
   - 없으면 OS가 설정된 DNS 리졸버(예: ISP 제공 DNS 서버)에 요청을 보낸다.
   - 리졸버가 응답을 모르면 루트 네임서버 → TLD 네임서버 → 권한 있는 네임서버 순으로 조회한다.
4. **쿼리 유형**:
   - **재귀 쿼리**: 클라이언트가 최종 응답을 받을 때까지 DNS 리졸버가 대신 조회하는 방식.
   - **반복 쿼리**: 클라이언트가 직접 여러 DNS 서버에 요청을 보내면서 IP를 찾는 방식.
5. **응답 종류**:
   - **정상 응답**: 요청한 도메인의 IP 주소 반환.
   - **NXDOMAIN**: 해당 도메인이 존재하지 않음을 의미.
   - **SERVFAIL**: DNS 서버 문제로 조회 실패.
6. **캐싱**: 조회된 IP 주소는 성능 최적화를 위해 일정 시간 동안 캐싱된다(TTL 설정에 따라 다름).

# DNS 쿼리를 통해 얻어진 IP의 목적지

1. **CDN 및 로드 밸런서**: `www.github.com`의 DNS 조회 결과는 단일 서버가 아닌, GitHub의 컨텐츠 전송 네트워크(CDN) 또는 로드 밸런서를 가리킨다.
2. **GitHub의 서버 인프라**: GitHub는 자체 데이터 센터뿐만 아니라 AWS와 같은 클라우드 서비스를 활용하여 서버를 운영한다.
3. **지리적 최적화**: 사용자의 위치에 따라 가장 가까운 서버로 연결하여 응답 속도를 최적화한다.
4. **IP 주소 예시**: `github.com`의 DNS 조회 결과는 `140.82.113.3` 같은 IPv4 주소 또는 `2606:50c0:8003::153` 같은 IPv6 주소를 반환할 수 있다.
5. **TLS 종료 지점**: 반환된 IP는 HTTPS 트래픽을 처리하는 엔드포인트로, TLS 핸드셰이크를 수행하는 서버일 가능성이 크다.
6. **리버스 프록시 서버**: GitHub의 백엔드 서비스로 요청을 전달하는 리버스 프록시 역할을 할 수도 있다.
7. **실제 웹 애플리케이션 서버**: 최종적으로 GitHub의 애플리케이션 코드가 실행되는 서버로 요청이 전달된다.


<li> Web Server와 Web Application Server의 차이에 대해 설명해 주세요. </li>
# Web Server vs. Web Application Server 차이점

1. **Web Server**: 정적 콘텐츠(HTML, CSS, JavaScript, 이미지 등)를 클라이언트(브라우저)에 제공하는 역할을 하며, 대표적으로 Nginx, Apache 등이 있다.
2. **Web Application Server (WAS)**: 동적 요청(비즈니스 로직, 데이터베이스 조회 등)을 처리하는 서버로, Spring Boot, Tomcat, JBoss 등이 사용된다.
3. **주요 차이점**: Web Server는 정적 파일을 제공하는 반면, WAS는 애플리케이션 로직을 실행하여 동적 데이터를 생성한다.
4. **연동 방식**: WAS는 보통 Web Server 뒤에서 동작하며, Web Server가 정적 요청을 처리하고 동적 요청은 WAS에 전달한다.
5. **예시**: Nginx(Web Server) + Spring Boot(WAS) 조합으로 배포하면, Nginx가 요청을 받아 정적 리소스를 제공하고, API 요청은 Spring Boot가 처리한다.

<li> URL, URI, URN은 어떤 차이가 있나요? </li>
# URL vs. URI vs. URN 차이점

1. **URI (Uniform Resource Identifier)**: 인터넷에서 특정 리소스를 식별하는 모든 형태의 문자열(URN과 URL 포함).
2. **URL (Uniform Resource Locator)**: 리소스의 위치를 나타내는 URI의 한 형태로, 프로토콜(https, ftp 등)과 경로를 포함함. (예: `https://github.com`)
3. **URN (Uniform Resource Name)**: 리소스의 **고유한 이름**을 나타내며, 위치 정보 없이 식별만 가능. (예: `urn:isbn:0451450523` → ISBN 번호)
4. **주요 차이점**: URL은 **위치 기반**, URN은 **이름 기반**, URI는 둘을 포함하는 **상위 개념**이다.
5. **예시 관계**: 모든 URL과 URN은 URI에 속하지만, 모든 URI가 반드시 URL이나 URN은 아니다.
6. **쉽게 이해하면**: URL = "어디에 있는지", URN = "무엇인지", URI = "둘 다 포함하는 개념"

</ul>
</details>

<details>
  <summary><h3>14. DNS에 대해 설명해 주세요.</h3></summary>
# DNS (Domain Name System)란?

1. **역할**: 도메인 이름(예: `www.github.com`)을 IP 주소(예: `140.82.113.3`)로 변환하는 시스템.
2. **작동 방식**: 브라우저가 DNS 서버에 쿼리를 보내면, 서버는 해당 도메인의 IP 주소를 반환.
3. **DNS 계층 구조**:
   - **루트 네임서버** (`.`) → **TLD 네임서버** (`.com`, `.org`) → **권한 있는 네임서버** (도메인 관리 서버)
4. **쿼리 유형**:
   - **재귀 쿼리**: 클라이언트가 최종 IP를 받을 때까지 DNS 서버가 대신 조회.
   - **반복 쿼리**: 클라이언트가 직접 여러 DNS 서버를 거쳐 조회.
5. **캐싱**: 성능 향상을 위해 조회된 결과를 일정 시간(TTL 설정)에 따라 저장하여 빠른 응답 제공.

<ul>
<li> DNS는 몇 계층 프로토콜인가요? </li>
- 7계층 프로토콜
<li> UDP와 TCP 중 어떤 것을 사용하나요?</li>
- 기본적으로 UDP를 사용. 
UDP 사용 이유
DNS 쿼리와 응답이 대부분 짧기 때문에 속도가 중요한 상황에 적합합니다. 
연결 상태를 유지하지 않고 정보 기록을 최소화하여 많은 클라이언트 수용이 가능합니다. 
'핸드셰이크'가 필요하지 않거나 데이터가 제대로 도착하는지 확인하지 않기 때문에 TCP보다 훨씬 빠르게 데이터를 전송할 수 있습니다. 

<li> DNS Recursive Query, Iterative Query가 무엇인가요?</li>
- **재귀 쿼리**: 클라이언트가 최종 IP를 받을 때까지 DNS 서버가 대신 조회.
   - **반복 쿼리**: 클라이언트가 직접 여러 DNS 서버를 거쳐 조회.
<li> DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?</li>

<li> 캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?</li>
<li> DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.</li>
<li> hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?</li>
</ul>
</details>

<details>
  <summary><h3>15. SOP 정책에 대해 설명해 주세요.</h3></summary>
## SOP(Same-Origin Policy)란?

SOP(Same-Origin Policy, 동일 출처 정책)는 **웹 보안 정책**으로,  
서로 다른 출처(Origin) 간의 리소스 접근을 제한하는 규칙이다.

### 🔹 Origin(출처) 정의
- **Schema(프로토콜)**: `http`, `https`
- **Host(도메인)**: `example.com`
- **Port(포트 번호)**: `:80`, `:443` (기본 포트 포함)
- 동일한 프로토콜, 도메인, 포트를 가진 경우에만 같은 Origin으로 간주

### 🔹 SOP 적용 예시
✅ `https://example.com/page1.html` → `https://example.com/page2.html` (허용)  
❌ `https://example.com` → `http://example.com` (차단, 프로토콜 다름)  
❌ `https://example.com` → `https://api.example.com` (차단, 서브도메인 다름)  
❌ `https://example.com:443` → `https://example.com:8443` (차단, 포트 다름)

### 🔹 예외 처리 방법
- **CORS(Cross-Origin Resource Sharing)**: 서버에서 허용된 도메인만 접근 허용
- **JSONP**: `<script>` 태그를 활용한 우회 방식 (비권장)

📌 **목적**: 악의적인 스크립트가 다른 사이트의 중요한 데이터에 접근하는 것을 방지

<ul>
<li> CORS 정책이 무엇인가요?</li>
## CORS(Cross-Origin Resource Sharing)란?

CORS는 **다른 출처(Origin) 간의 리소스 공유를 제어하는 보안 정책**이다.  
기본적으로 SOP(Same-Origin Policy)로 인해 **교차 출처 요청이 차단**되지만,  
CORS를 사용하면 서버가 특정 출처의 요청을 허용할 수 있다.

### 🔹 CORS 동작 방식
1. **Preflight 요청(사전 요청)**:
   - `OPTIONS` 메서드로 서버에 CORS 허용 여부를 미리 확인
2. **서버 응답**:
   - 적절한 CORS 헤더를 포함하여 응답 (`Access-Control-Allow-Origin`)
3. **실제 요청**:
   - 서버가 허용한 경우 클라이언트에서 본 요청을 수행

### 🔹 주요 CORS 응답 헤더
- `Access-Control-Allow-Origin: *` → 모든 출처 허용
- `Access-Control-Allow-Origin: https://example.com` → 특정 출처만 허용
- `Access-Control-Allow-Methods: GET, POST, PUT` → 허용할 HTTP 메서드 지정
- `Access-Control-Allow-Headers: Content-Type` → 허용할 요청 헤더 지정

📌 **목적**: 보안 강화를 유지하면서, 신뢰할 수 있는 출처에 한해 리소스를 공유

<li> Preflight에 대해 설명해 주세요.</li>
## Preflight 요청이란?

Preflight 요청은 **CORS(Cross-Origin Resource Sharing)** 정책의 일부로,  
브라우저가 **실제 요청**을 보내기 전에 서버에 **허용 여부를 확인**하는 **사전 요청**이다.  
이는 **HTTP OPTIONS 메서드**를 사용하여 서버에 보내지며, 서버의 응답에 따라 실제 요청이 실행된다.
</ul>
</details>

<details>
  <summary><h3>16. Stateless와 Connectionless에 대해 설명해 주세요.</h3></summary>

## Stateless vs. Connectionless

### 🔹 Stateless (무상태)
- 서버가 클라이언트의 이전 요청 상태를 저장하지 않는 방식
- 각 요청은 독립적으로 처리되며, 이전 요청과의 연관성이 없음
- 예시: HTTP (기본적으로 Stateless), REST API

### 🔹 Connectionless (비연결형)
- 통신 전에 별도의 연결을 설정하지 않고 데이터를 전송하는 방식
- 패킷은 독립적으로 전송되며, 순서 보장이나 재전송 처리가 없음
- 예시: UDP(User Datagram Protocol)

📌 **차이점**: Stateless는 **서버의 상태 유지 여부**, Connectionless는 **네트워크 연결 방식**과 관련됨

<ul>
<li> 왜 HTTP는 Stateless 구조를 채택하고 있을까요?</li>
## HTTP가 Stateless 구조를 채택한 이유

### 🔹 1. 확장성(Scalability) 향상
- 서버가 클라이언트의 상태를 저장하지 않으므로 많은 요청을 효율적으로 처리 가능

### 🔹 2. 서버 부담 감소
- 상태 정보를 관리하지 않아 서버 리소스(CPU, 메모리) 소모가 적음

### 🔹 3. 요청 간 독립성 유지
- 각 요청이 독립적으로 처리되어, 장애 발생 시 특정 세션에 영향 없음

### 🔹 4. 캐싱(Cache) 최적화
- Stateless 구조 덕분에 중간 캐시 서버를 활용하여 성능 향상 가능

📌 **단점 해결**: 쿠키, 세션, 토큰(JWT) 등을 활용해 상태 유지 필요 시 보완

<li> Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?</li>
## Connectionless 성능 개선 방법

### 🔹 1. 오류 감지 및 재전송
- **UDP + 애플리케이션 레벨 오류 검출** (예: RTP, QUIC)
- 패킷 손실 감지 후 필요한 경우 재전송

### 🔹 2. 순서 보장 메커니즘
- **시퀀스 번호 활용**하여 데이터 순서 보장 (예: QUIC, TFTP)

### 🔹 3. 혼잡 제어 및 흐름 제어
- 네트워크 과부하 방지를 위한 **혼잡 제어 알고리즘 적용**
- 예: QUIC(UDP 기반)에서 TCP와 유사한 흐름 제어 적용

### 🔹 4. 로드 밸런싱 및 병렬 처리
- 여러 경로로 패킷을 전송하여 성능 향상
- 예: **멀티패스 UDP(Multipath UDP)**

📌 **결론**: Connectionless 환경에서도 **애플리케이션 레벨에서 최적화 기법**을 적용하면 성능을 보완할 수 있음

<li> TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?</li>
## TCP Keep-Alive vs. HTTP Keep-Alive 차이점

### 🔹 TCP Keep-Alive
- **목적**: 장기간 비활성 상태에서도 연결이 유지되는지 확인
- **동작 방식**: 일정 시간 동안 데이터 전송이 없으면 작은 패킷(Keep-Alive 메시지) 전송
- **사용 이유**: 네트워크 장애 감지, 유휴 연결 종료 방지
- **예시**: SSH, 장시간 유지되는 TCP 연결

### 🔹 HTTP Keep-Alive
- **목적**: 여러 HTTP 요청을 하나의 TCP 연결에서 처리하여 성능 최적화
- **동작 방식**: `Connection: keep-alive` 헤더를 사용해 연결을 유지
- **사용 이유**: 새로운 TCP 연결 수립 비용 절감, 성능 향상
- **예시**: 웹 페이지에서 여러 리소스(CSS, JS, 이미지) 로딩 시

📌 **차이점**:
- TCP Keep-Alive는 **연결 유지를 위한 네트워크 레벨**에서 작동
- HTTP Keep-Alive는 **애플리케이션(HTTP) 레벨**에서 다수의 요청을 최적화

</ul>
</details>

<details>
  <summary><h3>17. 라우터 내의 포워딩 과정에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 라우팅과 포워딩의 차이는 무엇인가요?</li>
<li> 라우팅 알고리즘에 대해 설명해 주세요.</li>
<li> 포워딩 테이블의 구조에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>18. 로드밸런서가 무엇인가요?</h3></summary>
## 로드 밸런서(Load Balancer)란?

로드 밸런서는 **서버들 간의 트래픽을 균등하게 분배**하여 시스템의 **성능**과 **신뢰성**을 향상시키는 장치나 소프트웨어이다.  
이는 여러 서버로 요청을 분배하여 **과부하를 방지**하고 **서버 장애 대응**을 가능하게 한다.

### 🔹 주요 기능
1. **트래픽 분배**: 들어오는 요청을 여러 서버로 나누어 분배
2. **서버 장애 감지**: 서버가 다운되면 해당 서버로의 요청을 차단하고 다른 서버로 분배
3. **성능 최적화**: 서버 간 부하 균형을 맞춰 리소스를 효율적으로 사용
4. **확장성 지원**: 서버 추가 및 제거 시 자동으로 트래픽 분배 조정

### 🔹 로드 밸런서 유형
- **클라이언트-서버 사이에 위치**하여 요청을 분배
- **하드웨어 로드 밸런서**: 전용 장비로 제공되는 로드 밸런서
- **소프트웨어 로드 밸런서**: 클라우드 서비스나 소프트웨어로 제공되는 로드 밸런서 (예: Nginx, HAProxy)

📌 **목적**: 서비스의 고가용성, 성능, 확장성을 제공하여 **트래픽 과부하 및 장애를 예방**

<ul>
<li> L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.</li>
## L4 로드 밸런서 vs L7 로드 밸런서

### 🔹 L4 로드 밸런서 (Layer 4)
- **작동 레벨**: OSI 모델의 **전송 계층(Transport Layer)**
- **기능**: IP 주소와 포트 번호를 기반으로 트래픽을 분배
- **사용 프로토콜**: TCP, UDP 등 전송 계층 프로토콜 사용
- **장점**: 빠른 속도, 단순한 트래픽 분배
- **예시**: HAProxy, AWS Elastic Load Balancer (Classic)

### 🔹 L7 로드 밸런서 (Layer 7)
- **작동 레벨**: OSI 모델의 **애플리케이션 계층(Application Layer)**
- **기능**: HTTP/HTTPS 요청 헤더, URL, 쿠키, 세션 정보 등을 기반으로 트래픽을 분배
- **사용 프로토콜**: HTTP, HTTPS, WebSocket 등 애플리케이션 계층 프로토콜 사용
- **장점**: 고급 트래픽 분배 및 라우팅, 콘텐츠 기반 분배 가능
- **예시**: Nginx, Apache HTTP Server, AWS Application Load Balancer

### 🔹 주요 차이점
- **L4**는 **네트워크 레벨**에서 IP 주소와 포트를 기준으로 분배하고,  
  **L7**은 **애플리케이션 레벨**에서 HTTP 요청의 내용(헤더, URL 등)을 기반으로 트래픽을 분배한다.
- L7은 더 세밀한 제어가 가능하지만, L4는 성능이 더 우수하고 간단하다.

📌 **결론**: L4는 **속도**, L7은 **세밀한 트래픽 제어**에 유리하다.

<li> 로드밸런서 알고리즘에 대해 설명해 주세요.</li>
## 로드 밸런서 알고리즘

로드 밸런서 알고리즘은 **서버 간의 트래픽 분배 방법**을 정의한다.  
각 알고리즘은 **서버의 부하**, **응답 시간**, **성능** 등을 고려하여 최적의 분배를 목표로 한다.

### 🔹 1. 라운드 로빈(Round Robin)
- **동작 방식**: 서버들 간에 순차적으로 요청을 분배
- **특징**: 간단하고 공평하게 요청을 분배하지만, 서버 성능 차이를 고려하지 않음
- **적용 상황**: 서버가 동일한 성능을 가진 경우

### 🔹 2. 최소 연결(Minimum Connections)
- **동작 방식**: 현재 연결이 가장 적은 서버로 요청을 분배
- **특징**: 서버의 부하 상태를 고려하여 트래픽을 분배, 동적인 환경에서 유리
- **적용 상황**: 트래픽이 불규칙하게 몰리는 경우

### 🔹 3. IP 해시(IP Hash)
- **동작 방식**: 클라이언트의 IP 주소를 해시하여 서버에 요청을 분배
- **특징**: 클라이언트와 서버 간의 **세션 지속성**을 제공 (세션 고정)
- **적용 상황**: 같은 클라이언트가 항상 같은 서버에 접근해야 할 때

### 🔹 4. 가중 라운드 로빈(Weighted Round Robin)
- **동작 방식**: 각 서버에 가중치를 부여하고, 가중치에 비례해 요청을 분배
- **특징**: 서버 성능에 따라 요청을 비례적으로 분배 (성능 차이를 반영)
- **적용 상황**: 서버의 성능 차이가 있을 때

### 🔹 5. 가중 최소 연결(Weighted Least Connections)
- **동작 방식**: 서버의 연결 수와 가중치를 고려하여 요청을 분배
- **특징**: 트래픽이 많이 몰린 서버로의 요청 분배를 피하고, 성능이 좋은 서버에 트래픽을 더 많이 분배
- **적용 상황**: 고성능 서버가 필요한 환경

📌 **결론**: 알고리즘 선택은 **서버의 성능**, **부하 상태**, **세션 유지 필요성** 등을 고려하여 결정된다.

<li> 로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?</li>
## 로드밸런서에서 장애 장비 제외하기

장치 중 일부가 문제가 생겨 접속이 불가능한 경우, 로드밸런서는 해당 장비로 트래픽을 보내지 않도록 해야 한다.  
이를 위해 **장애 감지 및 서버 제외** 기능을 활용한다.

### 🔹 방법 1: 헬스 체크(Health Check)
- **동작 방식**: 로드밸런서는 주기적으로 각 서버의 상태를 점검하는 헬스 체크를 실행
- **구현 방법**: 서버에 **헬스 체크 요청**을 보내고 응답이 없거나 비정상적일 경우 해당 서버를 **비활성화**
- **예시**: HTTP 요청에 대한 정상적인 응답 코드(200 OK)를 받지 못하면 해당 서버를 **비정상 상태**로 간주

### 🔹 방법 2: 서버 상태 변경
- **동작 방식**: 장애가 발생한 서버를 수동 또는 자동으로 **비활성화 상태로 변경**
- **구현 방법**: 로드밸런서 관리 콘솔 또는 자동화 도구를 사용하여 문제 발생 시 서버를 제외하도록 설정
- **예시**: `down`, `drain` 상태로 설정하여 해당 서버로의 요청을 차단

### 🔹 방법 3: 자동 복구 및 알림
- **동작 방식**: 장애가 해결되면 로드밸런서가 해당 서버를 **자동으로 다시 활성화**
- **구현 방법**: 장애가 해결되었을 때 로드밸런서가 서버 상태를 재점검하고 **정상 상태로 복구**

📌 **결론**: 로드밸런서는 헬스 체크를 통해 장애를 감지하고, 해당 서버로의 요청을 제외함으로써 시스템의 **고가용성**을 유지한다.

<li> 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.</li>
## DNS 기반 로드밸런싱

DNS를 활용한 로드밸런싱은 **DNS 서버**를 이용해 트래픽을 여러 서버로 분배하는 방법이다.  
로드밸런서 장치를 사용하지 않고도 **서버의 IP 주소를 DNS 응답에 여러 번 포함**시켜 여러 서버에 트래픽을 분배할 수 있다.

### 🔹 동작 방식
1. **DNS 요청**: 클라이언트가 도메인 이름을 DNS 서버에 질의
2. **DNS 응답**: DNS 서버가 여러 서버의 **IP 주소**를 응답
3. **클라이언트 선택**: 클라이언트가 응답 받은 IP 중 하나를 선택하여 접속

### 🔹 방법 1: 라운드 로빈 DNS
- **동작 방식**: DNS 서버가 동일한 도메인에 대해 여러 IP 주소를 순차적으로 응답
- **특징**: 클라이언트가 DNS 요청을 할 때마다 순차적으로 다른 IP 주소를 제공하여 트래픽을 분배
- **예시**: `www.example.com` → `192.168.1.1`, `192.168.1.2`, `192.168.1.3`

### 🔹 방법 2: 가중 라운드 로빈 DNS
- **동작 방식**: DNS 서버가 각 서버에 대해 **가중치**를 부여하여 트래픽을 비례적으로 분배
- **특징**: 더 성능 좋은 서버에 더 많은 트래픽을 보내도록 가중치를 설정
- **예시**: `www.example.com` → `192.168.1.1`(가중치 3), `192.168.1.2`(가중치 1)

### 🔹 방법 3: 지리적 DNS
- **동작 방식**: 클라이언트의 위치(지리적 정보)를 기준으로 가까운 서버의 IP를 응답
- **특징**: **지리적 근접성**을 고려해 트래픽을 분배, 지연 시간 최소화
- **예시**: 미국 사용자는 `192.168.1.1`(미국 서버), 유럽 사용자는 `192.168.1.2`(유럽 서버)

### 🔹 한계점
- **장애 처리 어려움**: 서버가 장애를 일으켰을 때 DNS 캐시로 인해 바로 장애를 감지하고 대체 서버로 트래픽을 보낼 수 없음
- **부하 분배 정확도 부족**: DNS는 클라이언트가 요청할 때마다 IP 주소를 분배하지만, 서버의 실제 부하 상태를 반영하지 않음

📌 **결론**: DNS 기반 로드밸런싱은 간단하고 비용 효율적이지만, **서버의 부하 상태**나 **장애 처리**에 한계가 있다.

</ul>
</details>

<details>
  <summary><h3>19. 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.</h3></summary>
# 서브넷 마스크 & 게이트웨이

1. **서브넷 마스크**: IP 주소를 네트워크 주소와 호스트 주소로 나누는 값. (예: `255.255.255.0`)
   - 동일한 서브넷 내 장치들이 직접 통신할 수 있도록 범위를 결정.
2. **게이트웨이**: 내부 네트워크와 외부 네트워크(인터넷 등)를 연결하는 장치(IP 라우터).
   - 다른 네트워크로 데이터를 전송할 때 경로 역할 수행. (예: `192.168.1.1`)
3. **차이점**: 서브넷 마스크는 네트워크 범위를 정의하고, 게이트웨이는 네트워크 간 데이터 전달 역할 수행.
4. **예시**: `192.168.1.10/24`에서 서브넷 마스크는 `255.255.255.0`, 게이트웨이는 `192.168.1.1`로 설정됨.

<ul>
<li> NAT에 대해 설명해 주세요. </li>
# NAT (Network Address Translation)란?

1. **역할**: 사설 IP 주소를 공인 IP 주소로 변환하여 인터넷과 통신할 수 있도록 하는 기술.
2. **종류**:
   - **SNAT (Source NAT)**: 내부 → 외부 통신 시 출발지 IP를 공인 IP로 변경.
   - **DNAT (Destination NAT)**: 외부 → 내부 통신 시 목적지 IP를 사설 IP로 변경.
3. **장점**: IPv4 주소 부족 해결, 보안 강화(내부 네트워크 주소 숨김), 네트워크 유연성 제공.

<li> 서브넷 마스크의 표현 방식에 대해 설명해 주세요.</li>
# 서브넷 마스크 표현 방식

1. **점 표기법 (Dotted Decimal Notation)**
   - 4옥텟(8비트씩 4개)로 구분된 십진수 형태.
   - 예: `255.255.255.0` (24비트 네트워크 주소)

2. **CIDR 표기법 (Classless Inter-Domain Routing)**
   - IP 주소 뒤에 `/`와 함께 네트워크 비트 개수를 표기.
   - 예: `192.168.1.0/24` (`255.255.255.0`과 동일)

3. **이진수 표기법**
   - 각 옥텟을 이진수로 변환하여 표현.
   - 예: `255.255.255.0` → `11111111.11111111.11111111.00000000`

<li> 그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?</li>
가능하지 않다.

1. **올바른 서브넷 마스크 조건**
   - 서브넷 마스크는 **연속된 1과 0**으로 구성되어야 함.
   - 예: `11111111.00000000.11111111.00000000` (불연속) → **잘못된 서브넷 마스크**

2. **255.0.255.0의 문제점**
   - 정상적인 서브넷 마스크는 `1`이 연속되고 이후 `0`이 연속되어야 함.
   - `255.0.255.0` (`11111111.00000000.11111111.00000000`)은 중간에 `0`이 끼어 있어 **올바른 서브넷 마스크가 아님**.

3. **결론**
   - 서브넷 마스크는 `255.255.0.0` 또는 `255.255.255.0`처럼 연속된 `1`과 `0`의 형태여야 함.
   - 따라서 `255.0.255.0` 같은 형식은 **잘못된 서브넷 마스크**이다.

</ul>
</details>

<details>
  <summary><h3>20. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 디멀티플렉싱의 과정에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>21. XSS에 대해서 설명해 주세요.</h3></summary>
<ul>
<li> CSRF랑 XSS는 어떤 차이가 있나요?</li>
<li> XSS는 프론트엔드에서만 막을 수 있나요?</li>
</ul>
</details>
