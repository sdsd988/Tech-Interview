## 네트워크

<details>
  <summary>
    <h3>1. 쿠키와 세션의 차이에 대해 설명해 주세요.</h3>
- HTTP는 무상태 프로토콜입니다. 그렇기에, 서버와 클라이언트의 통신은 연속적이지 않습니다. 이를 보완하는 도구가 쿠키와 세션 

| **구분**              | **쿠키 (Cookie)**                                                                | **세션 (Session)**                                                                |
|-----------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| **저장 위치**         | 클라이언트(브라우저) 측에 저장.                                                   | 서버 측에 저장.                                                                 |
| **저장 데이터**       | 문자열(주로 키-값 쌍).                                                           | 클라이언트에 대한 정보를 서버의 메모리나 데이터베이스에 저장.                     |
| **보안**              | 보안에 취약 (클라이언트가 수정 가능).                                              | 상대적으로 보안이 강함 (클라이언트는 세션 ID만 소유).                             |
| **유효 기간**         | 유효 기간을 설정할 수 있으며, 설정에 따라 브라우저 종료 후에도 유지 가능.          | 브라우저가 닫히거나, 세션 타임아웃(기본적으로 일정 시간 동안 활동이 없을 때) 시 삭제. |
| **속도**              | 클라이언트에서 처리되므로 서버 부하가 적음.                                        | 서버에서 관리하므로 서버 부하가 증가할 수 있음.                                    |
| **용량 제한**         | 각 쿠키는 최대 4KB, 도메인당 약 20개 제한.                                          | 제한 없음 (서버 자원에 따라 다름).                                               |
| **주 사용 목적**      | 사용자 설정 정보(예: 테마, 언어), 자동 로그인 등.                                   | 로그인 정보 관리, 사용자 상태 유지 등.                                           |
| **전송 방식**         | HTTP 요청 시마다 클라이언트에서 서버로 자동 전송.                                    | 세션 ID만 전송되며, 정보는 서버에서 관리.                                         |
| **수정 가능 여부**    | 클라이언트 측에서 수정 가능 (브라우저 개발자 도구로 변경 가능).                     | 클라이언트가 직접 수정할 수 없음.                                               |
| **예시**              |  장바구니 유지, 자동 로그인.                                                      |  로그인 상태 유지, 사용자 맞춤 환경 제공.                                        |
</summary>
<ul>
<li> 세션 방식의 로그인 과정에 대해 설명해 주세요.</li>

1. 사용자 인증
   사용자가 로그인 폼에 ID와 비밀번호를 입력하고 서버에 요청을 보냅니다.
   서버는 전달받은 자격 증명을 검증합니다(예: 데이터베이스에 저장된 사용자 정보와 비교).
2. 세션 생성
   인증이 성공하면 서버는 사용자를 고유하게 식별할 수 있는 세션 객체를 생성합니다.
   세션 객체에는 사용자 정보를 저장하거나, 이를 참조할 수 있는 세션 ID가 생성됩니다.
3. 세션 ID 전달
   서버는 생성된 세션 ID를 쿠키를 사용해 클라이언트 브라우저에 전달합니다.
   쿠키에 저장된 세션 ID는 브라우저가 서버에 요청을 보낼 때마다 포함됩니다.
4. 서버에서 세션 관리
   서버는 클라이언트로부터 전달받은 세션 ID를 확인하여, 요청을 보낸 사용자를 식별합니다.
   세션 ID를 통해 저장된 사용자 정보를 참조하여 권한을 확인하거나 특정 작업을 수행합니다.
5. 세션 종료
   사용자가 로그아웃하거나, 세션이 만료되면 서버에서 세션 객체를 삭제합니다.
   세션 만료는 보통 일정 시간이 지나면 자동으로 이루어지며, 이를 세션 타임아웃이라고 합니다.


<li> HTTP의 특성인 Stateless에 대해 설명해 주세요.</li>

HTTP의 특성 중 하나인 `Stateless(무상태성)`는 HTTP 프로토콜이 각 요청(Request)과 응답(Response)을 독립적으로 처리하며, 이전 요청의 상태 정보를 유지하지 않는다는 특징을 말합니다. 이 특성은 HTTP가 간단하고 확장 가능한 프로토콜이 되도록 설계된 중요한 이유 중 하나입니다.

 Stateless의 주요 특징
요청 간 독립성

각 HTTP 요청은 독립적입니다. 이전 요청이나 이후 요청과는 관계없이, 각 요청은 필요한 모든 정보를 포함해야 합니다.
예를 들어, 서버는 이전 요청의 정보를 저장하지 않으므로, 클라이언트는 매 요청마다 인증 정보와 필요한 데이터를 포함해야 합니다.
서버의 상태 관리 없음

서버는 클라이언트와의 세션 상태를 기본적으로 유지하지 않습니다.
클라이언트가 요청을 보낼 때마다, 서버는 요청만 처리하고 응답을 반환한 뒤 상태 정보를 저장하지 않습니다.
확장성(Scalability)

무상태성 덕분에 서버는 클라이언트 상태를 관리할 필요가 없으므로, 서버 간 요청 처리가 간단해지고 확장성이 높아집니다.
서버가 분산 환경이나 로드 밸런싱 환경에서 효율적으로 동작할 수 있습니다.
### 장점

단순함
HTTP가 단순하게 동작하며, 상태를 관리하지 않아도 되는 구조를 유지합니다.

확장성
상태를 저장하지 않으므로, 서버 부하가 줄고 분산 처리나 스케일 아웃(Scale-out)이 쉽습니다.

표준화된 설계
모든 요청이 독립적이기 때문에, 특정 요청이나 응답에 대해 예측 가능하고 명확한 처리가 가능합니다.

단점
상태 유지의 어려움
클라이언트와 서버 간 지속적인 상태를 유지해야 하는 경우, 별도의 상태 관리 기술(세션, 쿠키, JWT 등)이 필요합니다.

데이터 중복
클라이언트는 매 요청마다 필요한 모든 데이터를 서버로 보내야 하므로 데이터가 중복될 수 있습니다.

Stateless 문제 해결 방법
Stateless의 단점을 극복하기 위해 다양한 상태 관리 기법이 활용됩니다:

쿠키(Cookie)
클라이언트가 서버로부터 받은 상태 정보를 브라우저에 저장하고, 이후 요청 시 이를 서버에 다시 전달합니다.

세션(Session)
서버가 상태 정보를 유지하기 위해 고유한 세션 ID를 생성하고, 클라이언트는 이를 쿠키를 통해 서버에 전달합니다.

JWT(Json Web Token)
클라이언트가 상태 정보를 토큰 형태로 저장하고, 요청마다 이를 서버에 전달하여 상태를 관리합니다.

<li> Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?</li>
- 세션은 HTTP의 Stateless 특성과 다소 상반되는 동작을 하지만, HTTP의 설계 원칙을 깨는 것이 아니라 Stateless 특성을 보완하여 인증과 상태 유지를 가능하게 하는 기술입니다. 다만, 애플리케이션의 규모, 보안 요구사항, 성능 요구사항에 따라 세션이 적절하지 않은 경우에는 JWT와 같은 Stateless 인증 방식을 선택하는 것이 더 나을 수 있습니다.
<li> 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?</li>
1. 세션 스티키(Sticky Session)
스티키 세션은 사용자가 처음 연결된 서버와 지속적으로 연결되도록 설정하는 방식입니다.

동작 원리
로드 밸런서가 클라이언트 요청을 항상 동일한 서버로 전달합니다.
이를 위해 로드 밸런서는 클라이언트의 식별자(예: 쿠키, IP)를 기반으로 세션을 "고정"합니다.
장점
구현이 간단하고 추가 저장소가 필요 없습니다.
기존 세션 관리 방식(서버 메모리 사용)을 그대로 사용할 수 있습니다.
단점
특정 서버에 부하가 집중될 수 있습니다.
서버가 장애로 다운되면 해당 사용자의 세션 정보가 손실됩니다.
2. 세션 복제(Session Replication)
   세션 데이터를 서버 간에 공유하는 방식입니다.

동작 원리
각 서버가 생성한 세션 데이터를 클러스터 내의 다른 서버로 복제합니다.
사용자가 요청을 보낸 서버가 달라지더라도, 다른 서버에서 동일한 세션 데이터를 사용할 수 있습니다.
장점
사용자가 어떤 서버에 요청을 보내더라도 동일한 세션 데이터에 접근 가능합니다.
서버 장애 시에도 세션 데이터가 손실되지 않습니다.
단점
서버 간 데이터 동기화로 인해 네트워크 트래픽과 성능 부담이 증가합니다.
구현과 관리가 복잡합니다.
3. 외부 세션 저장소(Distributed Session Store)
   세션 데이터를 서버가 아닌 외부 저장소에 저장하고 모든 서버가 이를 참조하는 방식입니다. Redis, Memcached와 같은 인메모리 데이터베이스가 주로 사용됩니다.

동작 원리
세션 데이터는 중앙 집중형 저장소(예: Redis, Memcached)에 저장됩니다.
서버는 클라이언트 요청에서 전달받은 세션 ID를 사용하여 외부 저장소에서 세션 데이터를 가져옵니다.
장점
확장성이 뛰어나며, 서버가 추가되더라도 세션 관리에 영향을 받지 않습니다.
서버 간 동기화가 필요 없으므로 간단하고 효율적입니다.
세션 데이터를 복구하거나 분석하기 용이합니다.
단점
외부 저장소가 병목이 될 가능성이 있습니다(고성능 저장소가 필요).
저장소 장애 시 모든 세션 데이터가 손실될 수 있으므로 고가용성(HA) 구성이 필요합니다.
4. 세션 없는 인증 방식(JWT 기반 인증)
   세션 관리의 복잡성을 피하기 위해, 서버가 상태를 전혀 유지하지 않는 방식으로 JWT를 사용하는 인증 방법입니다.

동작 원리
인증 정보를 포함한 JWT를 클라이언트에게 전달합니다.
클라이언트는 이후 요청마다 JWT를 포함하여 서버에 보냅니다.
서버는 JWT를 검증하여 사용자 상태를 확인합니다.
장점
서버는 세션 데이터를 유지할 필요가 없으므로 완전한 Stateless를 구현할 수 있습니다.
확장성이 뛰어나며, 분산 환경에 적합합니다.
단점
JWT가 클라이언트에 저장되므로 만료 시간을 짧게 설정하거나, 토큰 재발급 로직을 추가해야 합니다.
JWT 크기가 커지면 네트워크 트래픽에 영향을 미칠 수 있습니다.
</ul>   
</details>

<details>
  <summary><h3>2. HTTP 응답코드에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?</li>
<li> 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.</li>
<li> 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요. </li>
</ul>
</details>

<details>
  <summary><h3>3. HTTP Method 에 대해 설명해 주세요.</h3></summary>
<ul>
<li> HTTP Method의 멱등성에 대해 설명해 주세요.</li>
<li> GET과 POST의 차이는 무엇인가요?</li>
<li> POST와 PUT, PATCH의 차이는 무엇인가요?</li>
<li> HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?</li>
</ul>
</details>

<details>
  <summary><h3>4. HTTP에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 공개키와 대칭키에 대해 설명해 주세요.</li>
<li> 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?</li>
<li> SSL과 TLS의 차이는 무엇인가요?</li>
</ul>
</details>

<details>
  <summary><h3>5. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 소켓과 포트의 차이가 무엇인가요?</li>
<li> 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?</li>
<li> 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?</li>
</ul>
</details>

<details>
  <summary><h3>6. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?</h3></summary>
<ul>
<li> HOL Blocking 에 대해 설명해 주세요.</li>
<li> HTTP/3.0의 주요 특징에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>7. TCP와 UDP의 차이에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Checksum이 무엇인가요?</li>
<li> TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?</li>
<li> 그렇다면, Checksum을 통해 오류를 정정할 수 있나요? </li>
<li> TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.</li>
<li> TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.</li>
<li> 왜 HTTP는 TCP를 사용하나요?</li>
<li> 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?</li>
<li> 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?</li>
<li> 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?</li>
</ul>
</details>

<details>
  <summary><h3>8. DHCP가 무엇인지 설명해 주세요.</h3></summary>
<ul>
<li> DHCP는 몇 계층 프로토콜인가요? </li>
<li> DHCP는 어떻게 동작하나요?</li>
<li> DHCP에서 UDP를 사용하는 이유가 무엇인가요?</li>
<li> DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?</li>
<li> DHCP의 유효기간은 얼마나 긴가요?</li>
</ul>
</details>

<details>
  <summary><h3>9. IP 주소는 무엇이며, 어떤 기능을 하고 있나요?</h3></summary>
<ul>
<li> IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?</li>
<li> IPv4와 IPv6의 차이에 대해 설명해 주세요.</li>
<li> 수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?</li>
<li> IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요? </li>
<li> IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?</li>
<li> IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?</li>
<li> TTL(Hop Limit)이란 무엇인가요? </li>
<li> IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>10. OSI 7계층에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.</li>
<li> L3 Switch와 Router의 차이에 대해 설명해 주세요.</li>
<li> 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.</li>
<li> 각각의 Header의 Packing Order에 대해 설명해 주세요.</li>
<li> ARP에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>11. 3-Way Handshake에 대해 설명해 주세요.</h3></summary>
<ul>
<li> ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?</li>
<li> 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.</li>
<li> 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?</li>
<li> SYN Flooding 에 대해 설명해 주세요.</li>
<li> 위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?</li>
</ul>
</details>

<details>
  <summary><h3>12. 4-Way Handshake에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?</li>
<li> 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?</li>
<li> 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?</li>
<li> 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요? </li>
</ul>
</details>

<details>
  <summary><h3>13. www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.</h3></summary>
<ul>
<li> DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?</li>
<li> Web Server와 Web Application Server의 차이에 대해 설명해 주세요. </li>
<li> URL, URI, URN은 어떤 차이가 있나요? </li>
</ul>
</details>

<details>
  <summary><h3>14. DNS에 대해 설명해 주세요.</h3></summary>
<ul>
<li> DNS는 몇 계층 프로토콜인가요? </li>
<li> UDP와 TCP 중 어떤 것을 사용하나요?</li>
<li> DNS Recursive Query, Iterative Query가 무엇인가요?</li>
<li> DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?</li>
<li> 캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?</li>
<li> DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.</li>
<li> hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?</li>
</ul>
</details>

<details>
  <summary><h3>15. SOP 정책에 대해 설명해 주세요.</h3></summary>
<ul>
<li> CORS 정책이 무엇인가요?</li>
<li> Preflight에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>16. Stateless와 Connectionless에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 왜 HTTP는 Stateless 구조를 채택하고 있을까요?</li>
<li> Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?</li>
<li> TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?</li>
</ul>
</details>

<details>
  <summary><h3>17. 라우터 내의 포워딩 과정에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 라우팅과 포워딩의 차이는 무엇인가요?</li>
<li> 라우팅 알고리즘에 대해 설명해 주세요.</li>
<li> 포워딩 테이블의 구조에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>18. 로드밸런서가 무엇인가요?</h3></summary>
<ul>
<li> L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.</li>
<li> 로드밸런서 알고리즘에 대해 설명해 주세요.</li>
<li> 로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?</li>
<li> 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>19. 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.</h3></summary>
<ul>
<li> NAT에 대해 설명해 주세요. </li>
<li> 서브넷 마스크의 표현 방식에 대해 설명해 주세요.</li>
<li> 그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?</li>
</ul>
</details>

<details>
  <summary><h3>20. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 디멀티플렉싱의 과정에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>21. XSS에 대해서 설명해 주세요.</h3></summary>
<ul>
<li> CSRF랑 XSS는 어떤 차이가 있나요?</li>
<li> XSS는 프론트엔드에서만 막을 수 있나요?</li>
</ul>
</details>
