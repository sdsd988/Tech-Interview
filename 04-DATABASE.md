## 데이터베이스


  <summary><h3>1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.</h3></summary>
    - 키는 테이블에서 특정 레코드를 식별하거나, 검색하기 위해 사용되는 식별자를 의미한다.
    - 키의 유일성과 최소성, 키 값은 레코드를 구분하기에 유일하고 최소한으로 구성되어야 한다.
    - 슈퍼키 (각 행을 유일하게 식별할 수 있는 속성들의 집합) : 유일성은 만족, 최소성 불만족
    - 후보키 (각 행을 유일하게 식별할 수 있는 최소한의 속성들 집합), 기본키의 후보들
    - 기본키 후보키 중 특별히 선정된 키, 중복된 값을 가질 수 없다.
    - 외래키 다른 테이블, 릴레이션의 기본 키를 탐조하는 속성 또는 속성들의 집합
<ul>
<li> 기본키는 수정이 가능한가요?</li>
- 가능하다. 하지만 조건이 있다. 변경하고자 하는 값이 유일성을 만족하고, NULL이 아니며, 다른 테이블에서 FK로 사용되지 않는경우
<li> 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?</li>
- MySQL의 경우 8버전부터 세팅을 통해 자동으로 보이지 않는 기본키를 생선한다. 즉 기본키를 명시적으로 정의하지 않아도 내부적으로 자동으로 기본키를 생서하여 이노디비 엔진이 클러스터링된 인덱스를 사용할 수 있도록 한다.
<li> 외래키 값은 NULL이 들어올 수 있나요?</li>
- 가능하다.
<li> 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?</li>
- 유일한 값을 가지게 되면, 조건 조회시 쿼리의 성능을 향상할 수 있다.
</ul>




  <summary><h3>2. RDB와 NoSQL의 차이에 대해 설명해 주세요.</h3></summary>
- 테이블 사이의 관계성 여부에 따라 RDB와 NoSQL을 구분한다.
<ul>
<li> NoSQL의 강점과, 약점이 무엇인가요?</li>
장점 
- 스키마가 없기에 데이터 저장시 유연성을 가질 수 있다.
- 테이블간 관계를 갖지 않기에, 데잍
단점
- 데이터 저장 형식이 없기에, 사용시 복잡성이 증가
- 데이터의 중복도 많다.
<li> RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)</li>
- 관계형 데이터베이스의 관계성 때문에 부하가 많이 걸릴 수 있다.
<li> NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.</li>
- 사이드 프로젝트에서, 인기 검색어를 구현할 때 Redis를 사용한 경험이 있다. 인기 검색어의 경우, 시간마다 변하는 값이기에 변동성이 큰 데이터인 동시에 영속적으로 관리할 필요가 없다고 생각. Redis에서 제공해주는 자료구조인 Sorted Set을 활용하면 빠르게 구현할 수 있다는 점을 고려하여 Redis를 선택.
</ul>




  <summary><h3>3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.</h3></summary>
- 트랜잭션은 데이터베이스에서 작업을 논리적으로 단위로 묶은 것
- ACID는 트랜잭션의 안전성을 보장하기 위한 4가지 특성을 말합니다. 
- 원자성, 알관성, 격리성, 지속성의 줄인말
- 원자성이란, 트랜잭션에 속한 쿼리는 전부 반영되거나 반영되지 않거나 둘중 하나여야 한다는 원칙 그래야 데이터의 안전성을 보장할 수 있다.
- 일관성이란, 트랜잭션 전 후 데이터베이스의 일관성 즉 무결성 제약 조건을 만족해야 함을 의미
- 격리성(독립성)이란, 서로 다른 트랜잭션은 서로 영향을 받지 않아야 함을 의미
- 지속성이란 트랜잭션 결과는 데이터베이스에 영구적으로 반영되어야 함을 의미 
<ul>
<li> ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?</li>
Durability(지속성)는 ACID 원칙 중 트랜잭션이 커밋되면 데이터가 영구적으로 저장됨을 보장합니다.  
DBMS는 이를 위해 주로 Write-Ahead Logging(WAL)을 사용합니다.  
변경 사항을 먼저 로그 파일(Redo 로그)에 기록한 후 디스크에 반영합니다.  
시스템 장애 시 Redo 로그를 통해 커밋된 데이터를 복구합니다.  
InnoDB는 Redo 로그와 버퍼 풀을 활용해 지속성을 보장합니다.  
비휘발성 저장소(NVRAM)나 배터리 백업도 활용될 수 있습니다.  
결과적으로, 전원 손실에도 데이터 손실을 방지합니다.
<li> 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?</li>
<li> 읽기에는 트랜잭션을 걸지 않아도 될까요?</li>
- 일반적으로는 읽기에는 트랜잭션이 필요없다.
- 예외적으로 일관성이 중요한 경우(읽기 후 후속잡업이 연계된 경우) 필요할 수 있다.
</ul>


  <summary><h3>4. 트랜잭션 격리 레벨에 대해 설명해 주세요.</h3></summary>
- 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것
- 트랜잭션의 격리 수준은 격리(고립) 수준이 높은 순서대로 SERIALIZABLE, REPEATABLE READ(팬텀스레드), READ COMMITTED, READ UNCOMMITED가 존재
<ul>
<li> 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?</li>
모든 DBMS가 4개의 트랜잭션 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)을 모두 구현하지는 않습니다.  
이는 성능, 복잡성, 그리고 사용 사례의 우선순위 때문입니다.  
예를 들어, MySQL InnoDB는 기본적으로 Repeatable Read를 사용하며 Serializable은 옵션입니다.  
PostgreSQL은 Serializable을 지원하지만, 구현 비용 때문에 덜 사용됩니다.  
DBMS마다 설계 목표와 최적화 전략이 달라 완전 구현 여부가 다릅니다.
<li> 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.</li>
MySQL InnoDB에서 Undo 영역은 트랜잭션 롤백과 일관성 있는 읽기를 위해 이전 데이터 버전을 저장합니다.  
Redo 영역은 시스템 크래시 후 데이터 복구를 위해 커밋된 트랜잭션의 변경 사항을 기록합니다.  
Undo는 주로 테이블스페이스 내 Undo 로그에 저장되며 MVCC를 지원합니다.  
Redo는 Redo 로그 파일에 순차적으로 기록되어 장애 복구 속도를 높입니다.  
둘 다 InnoDB의 트랜잭션 안정성과 성능을 보장하는 핵심 요소입니다.
<li> 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?</li>
스토리지 엔진은 DBMS에서 데이터의 저장, 검색, 관리 방식을 담당하는 핵심 구성 요소입니다.  
디스크나 메모리에 데이터를 어떻게 쓰고 읽을지, 인덱스를 어떻게 구성할지 결정합니다.  
MySQL의 InnoDB는 트랜잭션과 롤백을 지원하며, MyISAM은 빠른 읽기 중심으로 동작합니다.  
스토리지 엔진은 쿼리 실행 엔진과 협력해 데이터를 효율적으로 처리합니다.  
사용자는 테이블 단위로 스토리지 엔진을 선택해 성능과 기능을 조정할 수 있습니다.  
쉽게 말해, 데이터베이스의 '물리적 처리' 담당자라고 볼 수 있습니다.
</ul>

  <summary><h3>5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.</h3></summary>
인덱스(index)는 데이터베이스의 검색 속도를 높이기 위해 사용하는 자료구조로, 테이블 내의 컬럼을 이용하여 생성됩니다. 데이터베이스의 성능을 향상시키고 효율성을 높이는 데 기여합니다
<ul>
<li> 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?</li>
-  왜냐하면 인덱스도 테이블의 값이기에 삽입과 변경 작업에 비용이 많이 들기 때문입니다.  
- 또한, 한 테이블에 인덱스가 너무 많으면 데이터 수정 시 소요시간이 길어집니다. 
<li> 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?</li>
<li> ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.</li>
# ORDER BY / GROUP BY 연산의 동작 과정 (인덱스와의 관계)

1. ORDER BY 연산 과정

인덱스가 있는 경우

1 **인덱스 스캔(Index Scan) 수행**
    - 인덱스가 적용된 컬럼이면 **이미 정렬된 상태**이므로 추가 정렬 없이 데이터를 가져올 수 있음.
2. **결과 반환**
    - 인덱스를 순차적으로 읽으며 빠르게 결과 출력.

**성능 최적화**
- 인덱스를 활용하면 **불필요한 정렬 연산을 제거**할 수 있어 성능이 향상됨.
- `ORDER BY` 컬럼이 **클러스터형 인덱스**(Primary Key) 또는 **커버링 인덱스**라면 더욱 효율적.

**예제**
```sql
SELECT * FROM orders ORDER BY order_date;
```

- order_date에 인덱스가 있다면 정렬 없이 바로 반환 가능.

인덱스가 없는 경우
1. 테이블 풀 스캔(Full Table Scan) 수행
- 정렬되지 않은 상태에서 데이터를 모두 읽어옴.
2. 정렬 연산(Sort Operation) 수행
메모리 정렬이 가능하면 정렬 후 반환.
메모리에 적재할 수 없으면 디스크 기반 정렬(File Sort) 발생, 성능 저하.
❌ 성능 저하 요인

- 정렬 비용 증가 → 데이터 양이 많을수록 CPU 및 I/O 사용량 급증.
- 디스크 사용 증가 → 메모리 초과 시 디스크를 이용한 정렬로 속도 저하.

2. GROUP BY 연산 과정

3. 인덱스가 있는 경우
   인덱스 스캔 수행
   GROUP BY 대상 컬럼이 인덱스로 정렬된 상태라면, 별도 정렬 없이 바로 그룹핑 가능.
   그룹핑 수행
   정렬된 데이터를 순차적으로 읽으며 집계 연산 수행.
 성능 최적화

인덱스를 활용한 그룹핑(Sorted Aggregate) 가능, 추가적인 정렬 과정 생략.

```sql
SELECT category, COUNT(*) FROM products GROUP BY category;
```
- category 컬럼이 인덱스로 정렬되어 있다면 바로 그룹핑 가능, 성능 향상.

인덱스가 없는 경우
  
1. 테이블 풀 스캔 수행
- 모든 데이터를 읽어옴.
2. 정렬 후 그룹핑 수행(Sort Aggregate)
- 먼저 정렬한 후 그룹핑 진행.
- 데이터 양이 많으면 디스크 정렬 발생(File Sort) → 성능 저하. 
3. 또는 해시 그룹핑(Hash Aggregate) 수행
- 정렬 없이 해시 테이블을 이용해 그룹핑 수행.
메모리 초과 시 디스크를 사용하여 성능 저하 발생.

성능 저하 요인

- 정렬 비용 증가 → GROUP BY 컬럼이 인덱스가 아닐 경우 불필요한 정렬 작업 발생.
- 메모리 및 디스크 사용량 증가 → 데이터 크기가 클 경우 성능 저하.

<li> 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?</li>
# 기본키와 인덱스의 차이점

## ✅ 기본키(Primary Key)란?
- 테이블에서 **유일하게 각 행을 식별**하는 컬럼 또는 컬럼 조합.
- **NULL 값을 가질 수 없음**(NOT NULL 제약 조건).
- 자동으로 **클러스터형 인덱스(Clustered Index)** 가 생성됨(일부 DBMS 제외).

## ✅ 인덱스(Index)란?
- **검색 성능을 최적화**하기 위해 특정 컬럼에 생성하는 자료 구조.
- 기본키뿐만 아니라 **외래키, 보조키, 일반 컬럼에도 생성 가능**.
- 클러스터형(B-Tree 기반) 또는 비클러스터형 인덱스로 나뉨.

## ✅ 기본키와 인덱스의 차이
| 구분       | 기본키(Primary Key) | 인덱스(Index) |
|------------|-----------------|--------------|
| **역할**   | 행을 유일하게 식별 | 검색 성능 최적화 |
| **NULL 허용 여부** | 허용 안 됨 (NOT NULL) | 가능 (제약 없음) |
| **자동 생성 여부** | 생성 시 자동으로 클러스터형 인덱스 생성 | 수동으로 생성 가능 |
| **사용 가능 위치** | 기본키 컬럼에만 적용 | 모든 컬럼에 적용 가능 |

📌 **결론**
- **기본키 ≠ 인덱스**, 하지만 기본키를 생성하면 자동으로 인덱스가 만들어짐.
- **인덱스는 기본키 없이도 생성할 수 있으며, 조회 성능 향상을 위해 사용됨**.

<li> 그렇다면 외래키는요?</li>
# 기본키와 인덱스의 차이점

## ✅ 기본키(Primary Key)란?
- 테이블에서 **유일하게 각 행을 식별**하는 컬럼 또는 컬럼 조합.
- **NULL 값을 가질 수 없음**(NOT NULL 제약 조건).
- 자동으로 **클러스터형 인덱스(Clustered Index)** 가 생성됨(일부 DBMS 제외).

## ✅ 인덱스(Index)란?
- **검색 성능을 최적화**하기 위해 특정 컬럼에 생성하는 자료 구조.
- 기본키뿐만 아니라 **외래키, 보조키, 일반 컬럼에도 생성 가능**.
- 클러스터형(B-Tree 기반) 또는 비클러스터형 인덱스로 나뉨.

## ✅ 기본키와 인덱스의 차이
| 구분       | 기본키(Primary Key) | 인덱스(Index) |
|------------|-----------------|--------------|
| **역할**   | 행을 유일하게 식별 | 검색 성능 최적화 |
| **NULL 허용 여부** | 허용 안 됨 (NOT NULL) | 가능 (제약 없음) |
| **자동 생성 여부** | 생성 시 자동으로 클러스터형 인덱스 생성 | 수동으로 생성 가능 |
| **사용 가능 위치** | 기본키 컬럼에만 적용 | 모든 컬럼에 적용 가능 |

📌 **결론**
- **기본키 ≠ 인덱스**, 하지만 기본키를 생성하면 자동으로 인덱스가 만들어짐.
- **인덱스는 기본키 없이도 생성할 수 있으며, 조회 성능 향상을 위해 사용됨**.

<li> 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?</li>
- 인덱스는 데이터의 물리적 저장 순서에 직접 영향을 미치지 않음.  
- 데이터 검색을 위한 별도 구조물(지도 역할).  
- 물리적 저장 순서는 삽입 순서나 DBMS 설계에 따라 결정.  
- **클러스터드 인덱스**: 데이터가 키 순서로 물리적 정렬.  
- **비클러스터드 인덱스**: 물리적 순서 변경 없음.  
- 스토리지 엔진(예: B-트리, 해시)에 따라 다름.  
- 일반적으로 삽입 시점 순서로 디스크에 저장.  
<li> 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요? </li>
- NoSQL DB(Redis, MongoDB 등)도 인덱스를 지원함.  
- **Redis**: 키-값 쌍 기반, 인덱스 대신 해시나 정렬된 집합 사용.  
- **MongoDB**: 문서 기반, B-트리 인덱스 제공(RDB와 유사).  
- **차이점 1**: RDB는 테이블 구조, NoSQL은 데이터 모델에 따라 유연.  
- **차이점 2**: RDB는 주로 정규화, NoSQL은 비정규화 데이터에 최적화.  
- **차이점 3**: NoSQL 인덱스는 스키마 유연성으로 생성/관리 더 자유로움.  
- **공통점**: 검색 속도 향상 목적은 동일.  
<li> (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요? </li>
(A, B)로 복합 인덱스가 설정된 테이블에서 A 조건 없이 B 조건만 사용한 쿼리는 일반적으로 인덱스를 타지 않습니다.  
복합 인덱스는 왼쪽 컬럼(A)부터 순서대로 참조해야 효과적으로 동작합니다.  
B만 사용하면 인덱스의 선행 조건(A)이 누락되어 풀 테이블 스캔이 발생할 가능성이 높습니다.  
단, 데이터베이스 엔진의 최적화에 따라 예외적으로 인덱스를 사용할 수도 있으니 실행 계획을 확인하는 게 좋습니다.
</ul>


<details>
  <summary><h3>6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.</h3></summary>
# RDBMS와 NoSQL 클러스터링/레플리케이션

## **RDBMS**
- **클러스터링**: 여러 노드가 단일 스토리지를 공유해 고가용성과 장애 복구 지원.
    - 예: Oracle RAC(Real Application Clusters).
    - 주로 단일 데이터베이스 인스턴스처럼 동작.
- **레플리케이션**: 마스터-슬레이브 구조로 데이터 복제.
    - 읽기 전용 슬레이브로 부하 분산.
    - 예: MySQL Master-Slave, PostgreSQL Streaming Replication.
- **특징**:
    - ACID(원자성, 일관성, 격리성, 지속성) 준수.
    - 수직 확장에 적합, 강한 일관성 유지.

## **NoSQL**
- **클러스터링**: 데이터를 샤딩하여 노드 간 분산 저장.
    - 수평 확장으로 대규모 데이터 처리.
    - 예: MongoDB Sharding, Cassandra Ring.
- **레플리케이션**: 리더-팔로워 또는 피어-투-피어 방식.
    - 데이터 복제본 유지로 가용성 향상.
    - 예: DynamoDB, Couchbase.
- **특징**:
    - BASE(기본 가용성, 소프트 상태, 최종 일관성) 원칙.
    - 유연성과 확장성 우선, 약한 일관성 허용.
<ul>
  <li>이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?</li>
  <li>마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?</li>
  <li>다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.</li>
  <li>샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?</li>
</ul>
</details>

<details>
  <summary><h3>7. 정규화가 무엇인가요?</h3></summary>
# 데이터베이스 정규화 (Normalization)

- **정의**: 데이터베이스에서 중복 데이터를 제거하고, 데이터 무결성을 보장하기 위해 테이블을 구조화하는 과정.
- **목적**:
    - 데이터 중복 최소화.
    - 삽입, 삭제, 갱신 이상(Anomaly) 방지.
    - 데이터 일관성 유지.
- **주요 단계**:
    1. **1NF (제1정규형)**: 모든 속성이 원자값(Atomic Value)을 가지도록 함. 중복 그룹 제거.
    2. **2NF (제2정규형)**: 1NF를 만족하며, 부분 함수 종속성 제거 (기본 키의 일부에 종속되지 않음).
    3. **3NF (제3정규형)**: 2NF를 만족하며, 이행 함수 종속성 제거 (비기본 속성이 다른 비기본 속성에 종속되지 않음).
- **장점**: 효율적인 저장, 무결성 보장.
- **단점**: 복잡한 쿼리 시 조인 증가로 성능 저하 가능.
<ul>
<li> 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.</li>
# 정규화를 하지 않을 경우 발생할 수 있는 이상현상

- **삽입 이상 (Insertion Anomaly)**:
    - 새로운 데이터를 추가할 때 불필요한 데이터까지 함께 입력해야 하는 문제.
    - 예: 학생 정보 없이 과목만 추가 불가능.

- **삭제 이상 (Deletion Anomaly)**:
    - 특정 데이터를 삭제하면 필요한 다른 데이터까지 함께 삭제되는 문제.
    - 예: 학생 삭제 시 수업 기록도 함께 삭제.

- **갱신 이상 (Update Anomaly)**:
    - 중복 데이터 중 일부만 갱신되어 데이터 불일치가 발생하는 문제.
    - 예: 동일한 학생의 주소가 여러 행에 중복되며, 일부만 수정 시 불일치.

- **원인**: 데이터 중복과 함수 종속성 미해결.
- **해결**: 정규화를 통해 중복 제거 및 테이블 분리.
<li> 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.</li>
# 정규화 단계별 테이블 변화

## **1NF (제1정규형)**
- **진행 전**: 반복 그룹(다중 값 속성)이 포함된 테이블.
    - 예: `학생(학생ID, 이름, 과목들)` → 과목들: "수학, 영어".
- **진행 후**: 모든 속성이 원자값으로 분리.
    - 예: `학생과목(학생ID, 이름, 과목)` → 각 행에 단일 과목(수학, 영어).

## **2NF (제2정규형)**
- **진행 전**: 1NF를 만족하지만, 부분 함수 종속성 존재.
    - 예: `수강(학생ID, 과목ID, 학생이름, 과목명)` → 학생이름은 학생ID에만 종속.
- **진행 후**: 부분 종속성 제거, 테이블 분리.
    - 예: `학생(학생ID, 학생이름)`, `수강(학생ID, 과목ID, 과목명)`.

## **3NF (제3정규형)**
- **진행 전**: 2NF를 만족하지만, 이행 함수 종속성 존재.
    - 예: `수강(학생ID, 과목ID, 강사ID, 강사이름)` → 강사이름은 강사ID에 종속.
- **진행 후**: 이행 종속성 제거, 테이블 분리.
    - 예: `수강(학생ID, 과목ID, 강사ID)`, `강사(강사ID, 강사이름)`.

- **결론**: 각 단계마다 중복과 종속성이 줄어들며 데이터 무결성 향상.
<li> 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.</li>
# 정규화가 무조건 좋은가?

- **정규화의 한계**:
    - **성능 저하**: 복잡한 쿼리 시 다중 조인으로 응답 시간 증가.
    - **복잡성 증가**: 테이블 분리로 관리와 이해가 어려워질 수 있음.
    - **읽기 중심 애플리케이션 부적합**: 쓰기보다 읽기가 많은 경우 비효율적.

- **역정규화 (Denormalization)**:
    - **정의**: 성능 최적화를 위해 의도적으로 중복 데이터를 허용하거나 테이블을 통합.
    - **장점**: 쿼리 속도 향상, 조인 감소.

- **역정규화가 적합한 상황**:
    - **읽기 중심 워크로드**: 예: 보고서 생성, 대시보드 (OLAP 시스템).
    - **실시간 응답 요구**: 예: 전자상거래 검색, 추천 시스템.
    - **데이터 분석**: 대량 데이터 집계 시 중복 데이터로 계산 단순화.
    - **일관성 덜 중요한 경우**: 데이터 갱신이 드물고 지연 허용 가능 시.

- **결론**: 정규화는 무결성 우선, 역정규화는 성능 우선. 요구사항에 따라 선택 필요.

# 정규화의 효율성 분석

## **정규화가 쓰기보다 읽기가 많은 경우 비효율적인 이유**
- **다중 테이블 조인**: 데이터가 여러 테이블로 나뉘어 조인 필요, 읽기 성능 저하.
    - 예: `학생`, `수강`, `과목` 조회 시 2번 조인.
- **쿼리 복잡성 증가**: 조인으로 CPU, 메모리, I/O 부하 증가.
- **캐시 활용 어려움**: 분산된 데이터로 캐싱 효율 저하.
- **읽기 중심 불일치**: 정규화는 쓰기 무결성에 초점, 읽기 빈도 높은 경우 오버헤드만 커짐.
- **결론**: 읽기 중심(보고서, 분석 등)에서는 조인 비용으로 비효율적.

## **정규화가 쓰기 작업에서 읽기 작업보다 장점인 이유**
- **중복 최소화**: 쓰기 시 단일 위치 수정으로 효율성 향상.
    - 예: 주소 변경 시 `학생` 테이블만 갱신.
- **갱신 이상 방지**: 중복 없어 데이터 불일치 위험 감소.
- **삽입 이상 방지**: 불필요한 데이터 입력 요구 없음.
- **삭제 이상 방지**: 연관 데이터 손실 없이 삭제 가능.
- **작은 단위 관리**: 쓰기 작업이 작은 테이블에서 더 빠르고 간단.
- **결론**: 쓰기 중심(데이터 입력/수정)에서 무결성과 효율성 보장.

</ul>
</details>

<details>
  <summary><h3>8. View가 무엇이고, 언제 사용할 수 있나요?</h3></summary>
<ul>
<li> 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?</li>
</ul>
</details>

<details>
  <summary><h3>9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.</li>
<li> 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?</li>
<li> 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?</li>
<li> 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>10. B-Tree와 B+Tree에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?</li>
<li> DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?</li>
<li> 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>11. DB Locking에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.</li>
<li> 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?</li>
</ul>
</details>

<details>
  <summary><h3>12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?</h3></summary>
<ul>
<li> DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?</li>
</ul>
</details>

<details>
  <summary><h3>13. Schema가 무엇인가요?</h3></summary>
<ul>
  <li>Schema의 3계층에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>14. DB의 Connection Pool에 대해 설명해 주세요.</h3></summary>
<ul>
  <li>DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.</h3></summary>
<ul>
  <li>가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?</li>
  <li> COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요?</li>
</ul>
</details>

<details>
  <summary><h3>16. SQL Injection에 대해 설명해 주세요.</h3></summary>
<ul>
  <li>그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?</li>
</ul>
</details>
