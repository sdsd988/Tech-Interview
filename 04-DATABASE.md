## 데이터베이스


  <summary><h3>1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.</h3></summary>
    - 키는 테이블에서 특정 레코드를 식별하거나, 검색하기 위해 사용되는 식별자를 의미한다.
    - 키의 유일성과 최소성, 키 값은 레코드를 구분하기에 유일하고 최소한으로 구성되어야 한다.
    - 슈퍼키 (각 행을 유일하게 식별할 수 있는 속성들의 집합) : 유일성은 만족, 최소성 불만족
    - 후보키 (각 행을 유일하게 식별할 수 있는 최소한의 속성들 집합), 기본키의 후보들
    - 기본키 후보키 중 특별히 선정된 키, 중복된 값을 가질 수 없다.
    - 외래키 다른 테이블, 릴레이션의 기본 키를 탐조하는 속성 또는 속성들의 집합
<ul>
<li> 기본키는 수정이 가능한가요?</li>
- 가능하다. 하지만 조건이 있다. 변경하고자 하는 값이 유일성을 만족하고, NULL이 아니며, 다른 테이블에서 FK로 사용되지 않는경우
<li> 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?</li>
- MySQL의 경우 8버전부터 세팅을 통해 자동으로 보이지 않는 기본키를 생선한다. 즉 기본키를 명시적으로 정의하지 않아도 내부적으로 자동으로 기본키를 생서하여 이노디비 엔진이 클러스터링된 인덱스를 사용할 수 있도록 한다.
<li> 외래키 값은 NULL이 들어올 수 있나요?</li>
- 가능하다.
<li> 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?</li>
- 유일한 값을 가지게 되면, 조건 조회시 쿼리의 성능을 향상할 수 있다.
</ul>




  <summary><h3>2. RDB와 NoSQL의 차이에 대해 설명해 주세요.</h3></summary>
- 테이블 사이의 관계성 여부에 따라 RDB와 NoSQL을 구분한다.
<ul>
<li> NoSQL의 강점과, 약점이 무엇인가요?</li>
장점 
- 스키마가 없기에 데이터 저장시 유연성을 가질 수 있다.
- 테이블간 관계를 갖지 않기에, 데잍
단점
- 데이터 저장 형식이 없기에, 사용시 복잡성이 증가
- 데이터의 중복도 많다.
<li> RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)</li>
- 관계형 데이터베이스의 관계성 때문에 부하가 많이 걸릴 수 있다.
<li> NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.</li>
- 사이드 프로젝트에서, 인기 검색어를 구현할 때 Redis를 사용한 경험이 있다. 인기 검색어의 경우, 시간마다 변하는 값이기에 변동성이 큰 데이터인 동시에 영속적으로 관리할 필요가 없다고 생각. Redis에서 제공해주는 자료구조인 Sorted Set을 활용하면 빠르게 구현할 수 있다는 점을 고려하여 Redis를 선택.
</ul>




  <summary><h3>3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.</h3></summary>
- 트랜잭션은 데이터베이스에서 작업을 논리적으로 단위로 묶은 것
- ACID는 트랜잭션의 안전성을 보장하기 위한 4가지 특성을 말합니다. 
- 원자성, 알관성, 격리성, 지속성의 줄인말
- 원자성이란, 트랜잭션에 속한 쿼리는 전부 반영되거나 반영되지 않거나 둘중 하나여야 한다는 원칙 그래야 데이터의 안전성을 보장할 수 있다.
- 일관성이란, 트랜잭션 전 후 데이터베이스의 일관성 즉 무결성 제약 조건을 만족해야 함을 의미
- 격리성(독립성)이란, 서로 다른 트랜잭션은 서로 영향을 받지 않아야 함을 의미
- 지속성이란 트랜잭션 결과는 데이터베이스에 영구적으로 반영되어야 함을 의미 
<ul>
<li> ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?</li>
Durability(지속성)는 ACID 원칙 중 트랜잭션이 커밋되면 데이터가 영구적으로 저장됨을 보장합니다.  
DBMS는 이를 위해 주로 Write-Ahead Logging(WAL)을 사용합니다.  
변경 사항을 먼저 로그 파일(Redo 로그)에 기록한 후 디스크에 반영합니다.  
시스템 장애 시 Redo 로그를 통해 커밋된 데이터를 복구합니다.  
InnoDB는 Redo 로그와 버퍼 풀을 활용해 지속성을 보장합니다.  
비휘발성 저장소(NVRAM)나 배터리 백업도 활용될 수 있습니다.  
결과적으로, 전원 손실에도 데이터 손실을 방지합니다.
<li> 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?</li>
<li> 읽기에는 트랜잭션을 걸지 않아도 될까요?</li>
- 일반적으로는 읽기에는 트랜잭션이 필요없다.
- 예외적으로 일관성이 중요한 경우(읽기 후 후속잡업이 연계된 경우) 필요할 수 있다.
</ul>


  <summary><h3>4. 트랜잭션 격리 레벨에 대해 설명해 주세요.</h3></summary>
- 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것
- 트랜잭션의 격리 수준은 격리(고립) 수준이 높은 순서대로 SERIALIZABLE, REPEATABLE READ(팬텀스레드), READ COMMITTED, READ UNCOMMITED가 존재
<ul>
<li> 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?</li>
모든 DBMS가 4개의 트랜잭션 격리 수준(Read Uncommitted, Read Committed, Repeatable Read, Serializable)을 모두 구현하지는 않습니다.  
이는 성능, 복잡성, 그리고 사용 사례의 우선순위 때문입니다.  
예를 들어, MySQL InnoDB는 기본적으로 Repeatable Read를 사용하며 Serializable은 옵션입니다.  
PostgreSQL은 Serializable을 지원하지만, 구현 비용 때문에 덜 사용됩니다.  
DBMS마다 설계 목표와 최적화 전략이 달라 완전 구현 여부가 다릅니다.
<li> 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.</li>
MySQL InnoDB에서 Undo 영역은 트랜잭션 롤백과 일관성 있는 읽기를 위해 이전 데이터 버전을 저장합니다.  
Redo 영역은 시스템 크래시 후 데이터 복구를 위해 커밋된 트랜잭션의 변경 사항을 기록합니다.  
Undo는 주로 테이블스페이스 내 Undo 로그에 저장되며 MVCC를 지원합니다.  
Redo는 Redo 로그 파일에 순차적으로 기록되어 장애 복구 속도를 높입니다.  
둘 다 InnoDB의 트랜잭션 안정성과 성능을 보장하는 핵심 요소입니다.
<li> 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?</li>
스토리지 엔진은 DBMS에서 데이터의 저장, 검색, 관리 방식을 담당하는 핵심 구성 요소입니다.  
디스크나 메모리에 데이터를 어떻게 쓰고 읽을지, 인덱스를 어떻게 구성할지 결정합니다.  
MySQL의 InnoDB는 트랜잭션과 롤백을 지원하며, MyISAM은 빠른 읽기 중심으로 동작합니다.  
스토리지 엔진은 쿼리 실행 엔진과 협력해 데이터를 효율적으로 처리합니다.  
사용자는 테이블 단위로 스토리지 엔진을 선택해 성능과 기능을 조정할 수 있습니다.  
쉽게 말해, 데이터베이스의 '물리적 처리' 담당자라고 볼 수 있습니다.
</ul>

  <summary><h3>5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.</h3></summary>
인덱스(index)는 데이터베이스의 검색 속도를 높이기 위해 사용하는 자료구조로, 테이블 내의 컬럼을 이용하여 생성됩니다. 데이터베이스의 성능을 향상시키고 효율성을 높이는 데 기여합니다
<ul>
<li> 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?</li>
-  왜냐하면 인덱스도 테이블의 값이기에 삽입과 변경 작업에 비용이 많이 들기 때문입니다.  
- 또한, 한 테이블에 인덱스가 너무 많으면 데이터 수정 시 소요시간이 길어집니다. 
<li> 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?</li>
<li> ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.</li>
# ORDER BY / GROUP BY 연산의 동작 과정 (인덱스와의 관계)

1. ORDER BY 연산 과정

인덱스가 있는 경우

1 **인덱스 스캔(Index Scan) 수행**
    - 인덱스가 적용된 컬럼이면 **이미 정렬된 상태**이므로 추가 정렬 없이 데이터를 가져올 수 있음.
2. **결과 반환**
    - 인덱스를 순차적으로 읽으며 빠르게 결과 출력.

**성능 최적화**
- 인덱스를 활용하면 **불필요한 정렬 연산을 제거**할 수 있어 성능이 향상됨.
- `ORDER BY` 컬럼이 **클러스터형 인덱스**(Primary Key) 또는 **커버링 인덱스**라면 더욱 효율적.

**예제**
```sql
SELECT * FROM orders ORDER BY order_date;
```

- order_date에 인덱스가 있다면 정렬 없이 바로 반환 가능.

인덱스가 없는 경우
1. 테이블 풀 스캔(Full Table Scan) 수행
- 정렬되지 않은 상태에서 데이터를 모두 읽어옴.
2. 정렬 연산(Sort Operation) 수행
메모리 정렬이 가능하면 정렬 후 반환.
메모리에 적재할 수 없으면 디스크 기반 정렬(File Sort) 발생, 성능 저하.
❌ 성능 저하 요인

- 정렬 비용 증가 → 데이터 양이 많을수록 CPU 및 I/O 사용량 급증.
- 디스크 사용 증가 → 메모리 초과 시 디스크를 이용한 정렬로 속도 저하.

2. GROUP BY 연산 과정

3. 인덱스가 있는 경우
   인덱스 스캔 수행
   GROUP BY 대상 컬럼이 인덱스로 정렬된 상태라면, 별도 정렬 없이 바로 그룹핑 가능.
   그룹핑 수행
   정렬된 데이터를 순차적으로 읽으며 집계 연산 수행.
 성능 최적화

인덱스를 활용한 그룹핑(Sorted Aggregate) 가능, 추가적인 정렬 과정 생략.

```sql
SELECT category, COUNT(*) FROM products GROUP BY category;
```
- category 컬럼이 인덱스로 정렬되어 있다면 바로 그룹핑 가능, 성능 향상.

인덱스가 없는 경우
  
1. 테이블 풀 스캔 수행
- 모든 데이터를 읽어옴.
2. 정렬 후 그룹핑 수행(Sort Aggregate)
- 먼저 정렬한 후 그룹핑 진행.
- 데이터 양이 많으면 디스크 정렬 발생(File Sort) → 성능 저하. 
3. 또는 해시 그룹핑(Hash Aggregate) 수행
- 정렬 없이 해시 테이블을 이용해 그룹핑 수행.
메모리 초과 시 디스크를 사용하여 성능 저하 발생.

성능 저하 요인

- 정렬 비용 증가 → GROUP BY 컬럼이 인덱스가 아닐 경우 불필요한 정렬 작업 발생.
- 메모리 및 디스크 사용량 증가 → 데이터 크기가 클 경우 성능 저하.

<li> 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?</li>
# 기본키와 인덱스의 차이점

## ✅ 기본키(Primary Key)란?
- 테이블에서 **유일하게 각 행을 식별**하는 컬럼 또는 컬럼 조합.
- **NULL 값을 가질 수 없음**(NOT NULL 제약 조건).
- 자동으로 **클러스터형 인덱스(Clustered Index)** 가 생성됨(일부 DBMS 제외).

## ✅ 인덱스(Index)란?
- **검색 성능을 최적화**하기 위해 특정 컬럼에 생성하는 자료 구조.
- 기본키뿐만 아니라 **외래키, 보조키, 일반 컬럼에도 생성 가능**.
- 클러스터형(B-Tree 기반) 또는 비클러스터형 인덱스로 나뉨.

## ✅ 기본키와 인덱스의 차이
| 구분       | 기본키(Primary Key) | 인덱스(Index) |
|------------|-----------------|--------------|
| **역할**   | 행을 유일하게 식별 | 검색 성능 최적화 |
| **NULL 허용 여부** | 허용 안 됨 (NOT NULL) | 가능 (제약 없음) |
| **자동 생성 여부** | 생성 시 자동으로 클러스터형 인덱스 생성 | 수동으로 생성 가능 |
| **사용 가능 위치** | 기본키 컬럼에만 적용 | 모든 컬럼에 적용 가능 |

📌 **결론**
- **기본키 ≠ 인덱스**, 하지만 기본키를 생성하면 자동으로 인덱스가 만들어짐.
- **인덱스는 기본키 없이도 생성할 수 있으며, 조회 성능 향상을 위해 사용됨**.

<li> 그렇다면 외래키는요?</li>
# 기본키와 인덱스의 차이점

## ✅ 기본키(Primary Key)란?
- 테이블에서 **유일하게 각 행을 식별**하는 컬럼 또는 컬럼 조합.
- **NULL 값을 가질 수 없음**(NOT NULL 제약 조건).
- 자동으로 **클러스터형 인덱스(Clustered Index)** 가 생성됨(일부 DBMS 제외).

## ✅ 인덱스(Index)란?
- **검색 성능을 최적화**하기 위해 특정 컬럼에 생성하는 자료 구조.
- 기본키뿐만 아니라 **외래키, 보조키, 일반 컬럼에도 생성 가능**.
- 클러스터형(B-Tree 기반) 또는 비클러스터형 인덱스로 나뉨.

## ✅ 기본키와 인덱스의 차이
| 구분       | 기본키(Primary Key) | 인덱스(Index) |
|------------|-----------------|--------------|
| **역할**   | 행을 유일하게 식별 | 검색 성능 최적화 |
| **NULL 허용 여부** | 허용 안 됨 (NOT NULL) | 가능 (제약 없음) |
| **자동 생성 여부** | 생성 시 자동으로 클러스터형 인덱스 생성 | 수동으로 생성 가능 |
| **사용 가능 위치** | 기본키 컬럼에만 적용 | 모든 컬럼에 적용 가능 |

📌 **결론**
- **기본키 ≠ 인덱스**, 하지만 기본키를 생성하면 자동으로 인덱스가 만들어짐.
- **인덱스는 기본키 없이도 생성할 수 있으며, 조회 성능 향상을 위해 사용됨**.

<li> 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?</li>
- 인덱스는 데이터의 물리적 저장 순서에 직접 영향을 미치지 않음.  
- 데이터 검색을 위한 별도 구조물(지도 역할).  
- 물리적 저장 순서는 삽입 순서나 DBMS 설계에 따라 결정.  
- **클러스터드 인덱스**: 데이터가 키 순서로 물리적 정렬.  
- **비클러스터드 인덱스**: 물리적 순서 변경 없음.  
- 스토리지 엔진(예: B-트리, 해시)에 따라 다름.  
- 일반적으로 삽입 시점 순서로 디스크에 저장.  
<li> 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요? </li>
- NoSQL DB(Redis, MongoDB 등)도 인덱스를 지원함.  
- **Redis**: 키-값 쌍 기반, 인덱스 대신 해시나 정렬된 집합 사용.  
- **MongoDB**: 문서 기반, B-트리 인덱스 제공(RDB와 유사).  
- **차이점 1**: RDB는 테이블 구조, NoSQL은 데이터 모델에 따라 유연.  
- **차이점 2**: RDB는 주로 정규화, NoSQL은 비정규화 데이터에 최적화.  
- **차이점 3**: NoSQL 인덱스는 스키마 유연성으로 생성/관리 더 자유로움.  
- **공통점**: 검색 속도 향상 목적은 동일.  
<li> (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요? </li>
(A, B)로 복합 인덱스가 설정된 테이블에서 A 조건 없이 B 조건만 사용한 쿼리는 일반적으로 인덱스를 타지 않습니다.  
복합 인덱스는 왼쪽 컬럼(A)부터 순서대로 참조해야 효과적으로 동작합니다.  
B만 사용하면 인덱스의 선행 조건(A)이 누락되어 풀 테이블 스캔이 발생할 가능성이 높습니다.  
단, 데이터베이스 엔진의 최적화에 따라 예외적으로 인덱스를 사용할 수도 있으니 실행 계획을 확인하는 게 좋습니다.
</ul>


<details>
  <summary><h3>6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.</h3></summary>
# RDBMS와 NoSQL 클러스터링/레플리케이션

## **RDBMS**
- **클러스터링**: 여러 노드가 단일 스토리지를 공유해 고가용성과 장애 복구 지원.
    - 예: Oracle RAC(Real Application Clusters).
    - 주로 단일 데이터베이스 인스턴스처럼 동작.
    - ## 공유 디스크 클러스터링(Shared-Disk Clustering)이란?

### 정의
- **클러스터링**: 여러 노드(서버)가 단일 스토리지(디스크)를 공유하여 데이터베이스를 운영하는 방식.
- **목적**: 고가용성(High Availability, HA)과 장애 복구(Failover) 지원.
- **특징**: 모든 노드가 동일한 데이터에 접근하며, 단일 데이터베이스 인스턴스처럼 동작.

### 동작 방식
- **구성**:
  - 여러 노드가 하나의 공유 스토리지(예: SAN, NAS)에 연결.
  - 각 노드는 자체 CPU와 메모리를 사용하지만, 데이터는 공유 디스크에 저장.
- **데이터 관리**:
  - 노드 간 동기화를 통해 데이터 일관성 유지(캐시 퓨전, Cache Fusion 등 활용).
  - 한 노드가 실패하면 다른 노드가 작업을 인계받음.
- **트랜잭션 처리**: 모든 노드가 동시에 읽기/쓰기 가능(병렬 처리).

### 대표 예시: Oracle RAC
- **Oracle Real Application Clusters (RAC)**:
  - 여러 노드가 단일 Oracle DB 인스턴스를 공유.
  - **구성 요소**:
    - **공유 스토리지**: 데이터 파일, 로그 파일 저장.
    - **클러스터웨어**: 노드 간 통신 및 장애 관리(예: Grid Infrastructure).
  - **특징**:
    - 실시간 장애 복구: 노드 다운 시 다른 노드가 즉시 대체.
    - 부하 분산: 읽기/쓰기 작업을 노드 간 분배.
  - **사용 사례**: 금융, 대규모 ERP 시스템 등 고가용성이 필수적인 환경.

### 장점
- **고가용성**: 노드 장애 시 서비스 중단 최소화.
- **확장성**: 노드 추가로 처리 능력 확장 가능.
- **단일 이미지**: 애플리케이션은 단일 DB로 인식(복잡한 분산 로직 불필요).

### 단점
- **비용**: 공유 스토리지와 클러스터웨어 구축에 높은 비용.
- **복잡성**: 노드 간 동기화 및 캐시 관리 복잡.
- **단일 장애점**: 공유 스토리지 자체가 실패하면 전체 시스템 영향.

### 언제 사용?
- **적합한 경우**:
  - 초 단위 다운타임도 허용 불가한 시스템(예: 은행, 항공).
  - 대규모 트랜잭션 처리와 동시에 HA 필요 시.
- **부적합한 경우**:
  - 저비용, 단순 구조 선호 시(NoSQL 샤딩 대안).

### 비교: 공유-아무것도 아님(Shared-Nothing) 클러스터링
- **차이**: 공유-아무것도 아님은 노드마다 독립 스토리지(예: MySQL 샤딩).
- **RACとの違い**: RAC는 단일 DB 이미지, 공유-아무것도 아님은 분산 DB.

### 결론
- Oracle RAC와 같은 공유 디스크 클러스터링은 고가용성과 성능을 동시에 추구하는 RDBMS 환경에 최적화. 그러나 비용과 복잡성 고려 필요.
- **레플리케이션**: 마스터-슬레이브 구조로 데이터 복제.
    - 읽기 전용 슬레이브로 부하 분산.
    - 예: MySQL Master-Slave, PostgreSQL Streaming Replication.
- **특징**:
    - ACID(원자성, 일관성, 격리성, 지속성) 준수.
    - 수직 확장에 적합, 강한 일관성 유지.

## **NoSQL**
- **클러스터링**: 데이터를 샤딩하여 노드 간 분산 저장.
    - 수평 확장으로 대규모 데이터 처리.
    - 예: MongoDB Sharding, Cassandra Ring.
- **레플리케이션**: 리더-팔로워 또는 피어-투-피어 방식.
    - 데이터 복제본 유지로 가용성 향상.
    - 예: DynamoDB, Couchbase.
- **특징**:
    - BASE(기본 가용성, 소프트 상태, 최종 일관성) 원칙.
    - 유연성과 확장성 우선, 약한 일관성 허용.
<ul>
  <li>이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?</li>
## 데이터베이스 분산 환경에서 트랜잭션 관리 방법

### 분산 트랜잭션概述
- **정의**: 여러 노드(서버)에 걸친 데이터베이스 작업을 하나의 트랜잭션으로 관리.
- **목표**: ACID 속성(원자성, 일관성, 격리성, 지속성) 보장.

### 주요 관리 방법
1. **2단계 커밋 프로토콜 (2PC)**
  - **과정**:
    1. 준비 단계(Prepare): 모든 노드가 커밋 가능 여부 확인.
    2. 커밋 단계(Commit): 모두 준비되면 커밋, 아니면 롤백.
  - **장점**: 원자성 보장.
  - **단점**: 코디네이터 장애 시 지연 발생.
2. **3단계 커밋 프로토콜 (3PC)**
  - **과정**: 준비 → 사전 커밋 → 커밋. 장애 복구 강화.
  - **장점**: 2PC보다 장애 내성 우수.
  - **단점**: 복잡성 증가.
3. **분산 합의 프로토콜 (Paxos, Raft)**
  - **용도**: 노드 간 합의로 트랜잭션 상태 결정.
  - **특징**: 복제 및 장애 복구에 강함.
4. **사가 패턴 (Saga)**
  - **방식**: 트랜잭션을 작은 로컬 작업으로 분리, 실패 시 보상 트랜잭션 실행.
  - **장점**: 확장성 우수, 단순화.
  - **단점**: 일관성 보장 약함.

### 고려 사항
- **성능**: 네트워크 지연 최소화.
- **장애 처리**: 롤백 및 복구 메커니즘 필수.
- **도구**: X/Open XA, 분산 DB 시스템(MySQL Cluster, CockroachDB) 활용.
  <li>마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?</li>
  <li>다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.</li>
  <li>샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?</li>
</ul>
</details>

<details>
  <summary><h3>7. 정규화가 무엇인가요?</h3></summary>
# 데이터베이스 정규화 (Normalization)

- **정의**: 데이터베이스에서 중복 데이터를 제거하고, 데이터 무결성을 보장하기 위해 테이블을 구조화하는 과정.
- **목적**:
    - 데이터 중복 최소화.
    - 삽입, 삭제, 갱신 이상(Anomaly) 방지.
    - 데이터 일관성 유지.
- **주요 단계**:
    1. **1NF (제1정규형)**: 모든 속성이 원자값(Atomic Value)을 가지도록 함. 중복 그룹 제거.
    2. **2NF (제2정규형)**: 1NF를 만족하며, 부분 함수 종속성 제거 (기본 키의 일부에 종속되지 않음).
    3. **3NF (제3정규형)**: 2NF를 만족하며, 이행 함수 종속성 제거 (비기본 속성이 다른 비기본 속성에 종속되지 않음).
- **장점**: 효율적인 저장, 무결성 보장.
- **단점**: 복잡한 쿼리 시 조인 증가로 성능 저하 가능.
<ul>
<li> 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.</li>
# 정규화를 하지 않을 경우 발생할 수 있는 이상현상

- **삽입 이상 (Insertion Anomaly)**:
    - 새로운 데이터를 추가할 때 불필요한 데이터까지 함께 입력해야 하는 문제.
    - 예: 학생 정보 없이 과목만 추가 불가능.

- **삭제 이상 (Deletion Anomaly)**:
    - 특정 데이터를 삭제하면 필요한 다른 데이터까지 함께 삭제되는 문제.
    - 예: 학생 삭제 시 수업 기록도 함께 삭제.

- **갱신 이상 (Update Anomaly)**:
    - 중복 데이터 중 일부만 갱신되어 데이터 불일치가 발생하는 문제.
    - 예: 동일한 학생의 주소가 여러 행에 중복되며, 일부만 수정 시 불일치.

- **원인**: 데이터 중복과 함수 종속성 미해결.
- **해결**: 정규화를 통해 중복 제거 및 테이블 분리.
<li> 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.</li>
# 정규화 단계별 테이블 변화

## **1NF (제1정규형)**
- **진행 전**: 반복 그룹(다중 값 속성)이 포함된 테이블.
    - 예: `학생(학생ID, 이름, 과목들)` → 과목들: "수학, 영어".
- **진행 후**: 모든 속성이 원자값으로 분리.
    - 예: `학생과목(학생ID, 이름, 과목)` → 각 행에 단일 과목(수학, 영어).

## **2NF (제2정규형)**
- **진행 전**: 1NF를 만족하지만, 부분 함수 종속성 존재.
    - 예: `수강(학생ID, 과목ID, 학생이름, 과목명)` → 학생이름은 학생ID에만 종속.
- **진행 후**: 부분 종속성 제거, 테이블 분리.
    - 예: `학생(학생ID, 학생이름)`, `수강(학생ID, 과목ID, 과목명)`.

## **3NF (제3정규형)**
- **진행 전**: 2NF를 만족하지만, 이행 함수 종속성 존재.
    - 예: `수강(학생ID, 과목ID, 강사ID, 강사이름)` → 강사이름은 강사ID에 종속.
- **진행 후**: 이행 종속성 제거, 테이블 분리.
    - 예: `수강(학생ID, 과목ID, 강사ID)`, `강사(강사ID, 강사이름)`.

- **결론**: 각 단계마다 중복과 종속성이 줄어들며 데이터 무결성 향상.
<li> 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.</li>
# 정규화가 무조건 좋은가?

- **정규화의 한계**:
    - **성능 저하**: 복잡한 쿼리 시 다중 조인으로 응답 시간 증가.
    - **복잡성 증가**: 테이블 분리로 관리와 이해가 어려워질 수 있음.
    - **읽기 중심 애플리케이션 부적합**: 쓰기보다 읽기가 많은 경우 비효율적.

- **역정규화 (Denormalization)**:
    - **정의**: 성능 최적화를 위해 의도적으로 중복 데이터를 허용하거나 테이블을 통합.
    - **장점**: 쿼리 속도 향상, 조인 감소.

- **역정규화가 적합한 상황**:
    - **읽기 중심 워크로드**: 예: 보고서 생성, 대시보드 (OLAP 시스템).
    - **실시간 응답 요구**: 예: 전자상거래 검색, 추천 시스템.
    - **데이터 분석**: 대량 데이터 집계 시 중복 데이터로 계산 단순화.
    - **일관성 덜 중요한 경우**: 데이터 갱신이 드물고 지연 허용 가능 시.

- **결론**: 정규화는 무결성 우선, 역정규화는 성능 우선. 요구사항에 따라 선택 필요.

# 정규화의 효율성 분석

## **정규화가 쓰기보다 읽기가 많은 경우 비효율적인 이유**
- **다중 테이블 조인**: 데이터가 여러 테이블로 나뉘어 조인 필요, 읽기 성능 저하.
    - 예: `학생`, `수강`, `과목` 조회 시 2번 조인.
- **쿼리 복잡성 증가**: 조인으로 CPU, 메모리, I/O 부하 증가.
- **캐시 활용 어려움**: 분산된 데이터로 캐싱 효율 저하.
- **읽기 중심 불일치**: 정규화는 쓰기 무결성에 초점, 읽기 빈도 높은 경우 오버헤드만 커짐.
- **결론**: 읽기 중심(보고서, 분석 등)에서는 조인 비용으로 비효율적.

## **정규화가 쓰기 작업에서 읽기 작업보다 장점인 이유**
- **중복 최소화**: 쓰기 시 단일 위치 수정으로 효율성 향상.
    - 예: 주소 변경 시 `학생` 테이블만 갱신.
- **갱신 이상 방지**: 중복 없어 데이터 불일치 위험 감소.
- **삽입 이상 방지**: 불필요한 데이터 입력 요구 없음.
- **삭제 이상 방지**: 연관 데이터 손실 없이 삭제 가능.
- **작은 단위 관리**: 쓰기 작업이 작은 테이블에서 더 빠르고 간단.
- **결론**: 쓰기 중심(데이터 입력/수정)에서 무결성과 효율성 보장.

</ul>
</details>

<details>
  <summary><h3>8. View가 무엇이고, 언제 사용할 수 있나요?</h3>
  ## 데이터베이스에서 View란 무엇인가?
- 테이블 데이터를 기반으로 한 **가상 테이블**.
- 실제 데이터를 저장하지 않고, 쿼리로 실시간 생성.
- 보안 및 데이터 접근 제어를 위해 특정 열/행만 표시 가능.

## 언제 사용할 수 있나요?
- **보안 강화**: 민감 데이터(예: 급여)를 숨길 때.
- **쿼리 단순화**: 복잡한 쿼리를 재사용 가능하게 저장.
- **데이터 일관성**: 여러 사용자에게 동일 형식 제공.
- **보고서 생성**: 자주 사용하는 데이터 집합 필요 시.

## 예시
- `SELECT name, dept FROM employees`로 "급여 제외 직원 정보" View 생성.
</summary>

<li> 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?</li>
## View 수정 시 실제 테이블 반영 여부

### 기본 원칙
- View는 **가상 테이블**. 자체 데이터를 저장하지 않음.
- View 수정이 원본 테이블에 반영되는지는 정의에 따라 다름.

### 수정 가능 여부
- **가능한 경우**:
  - 단일 테이블 기반, 단순 쿼리(조인, 집계 없음).
  - 예: `UPDATE adult_users SET age = 20` → `users` 테이블 반영.
- **불가능한 경우**:
  - 조인, `SUM`, `GROUP BY` 등 복잡한 쿼리 포함 시 읽기 전용.
  - 예: `sales_summary` (`SUM(sales)`)는 수정 불가.

### 추가 고려 사항
- **제한**: 1:1 매핑 필요. 복잡한 View는 트리거로 간접 수정 가능.
- **결론**: View 정의 확인 필수. 단순 View만 직접 수정 반영.

</details>

<details>
  <summary><h3>9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.</h3></summary>
| **종류**         | **반환 데이터**                  | **주요 용도**              |
|------------------|----------------------------------|----------------------------|
| INNER JOIN       | 조건 일치 행만                  | 필수 관계 데이터 조회      |
| LEFT JOIN        | 왼쪽 전부 + 오른쪽 일치         | 왼쪽 기준 옵셔널 조회      |
| RIGHT JOIN       | 오른쪽 전부 + 왼쪽 일치         | 오른쪽 기준 옵셔널 조회    |
| FULL JOIN        | 양쪽 전부                       | 모든 데이터 보존            |
| CROSS JOIN       | 모든 조합                       | 전체 경우의 수 생성        |
| SELF JOIN        | 동일 테이블 내 관계             | 계층/자가 참조 조회        |

### 참고
- 성능: 조인 조건과 인덱스 최적화 필요.
- 데이터 크기에 따라 결과 집합 크기 주의.
<li> 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.</li>
## JOIN의 내부 구현 방식

### 배경
- **문제**: 대규모 테이블 조인은 메모리, 디스크 I/O, CPU 비용 증가.
- **해결**: DBMS는 쿼리 실행 계획(Query Execution Plan)을 통해 최적 알고리즘 선택.
- **영향 요인**: 테이블 크기, 인덱스, 조인 조건, 데이터 정렬 여부.

---

## 주요 JOIN 알고리즘

### 1. Nested Loop Join (중첩 루프 조인)
- **설명**: 한 테이블의 각 행을 다른 테이블의 모든 행과 비교.
- **동작**:
  - 외부 루프: 첫 번째 테이블(Outer Table) 순회.
  - 내부 루프: 두 번째 테이블(Inner Table) 전체 탐색.
- **특징**:
  - 단순하지만 비효율적(O(n × m)).
  - 인덱스 있으면 내부 테이블 탐색 최적화 가능.
- **사용 시**: 작은 테이블, 인덱스 활용 가능 시.
- **예시**: `SELECT * FROM small_table s JOIN large_table l ON s.id = l.id;` (인덱스 없으면 비효율적).

### 2. Hash Join (해시 조인)
- **설명**: 해시 테이블을 만들어 조인 키를 빠르게 매핑.
- **동작**:
  1. 작은 테이블(Build Input)을 해시 테이블로 변환.
  2. 큰 테이블(Probe Input) 행을 해시 테이블에서 검색.
- **특징**:
  - 등가 조인(=)에 적합.
  - 메모리 사용량 높음, 성능 우수(O(n + m)).
- **사용 시**: 큰 테이블 조인, 인덱스 없거나 등가 조건.
- **예시**: `SELECT * FROM orders o JOIN customers c ON o.cust_id = c.id;`.

### 3. Merge Join (병합 조인)
- **설명**: 두 테이블을 정렬 후 병합하며 조인.
- **동작**:
  1. 양쪽 테이블을 조인 키 기준으로 정렬.
  2. 정렬된 상태에서 순차 비교하며 매핑.
- **특징**:
  - 정렬 필요(미리 정렬된 경우 효율적).
  - 범위 조인(>, <)에도 사용 가능.
- **사용 시**: 이미 정렬된 데이터(예: 클러스터드 인덱스), 대량 데이터.
- **예시**: `SELECT * FROM employees e JOIN departments d ON e.dept_id = d.id;` (정렬 활용).

### 4. Index Join (인덱스 조인)
- **설명**: 한 테이블의 인덱스를 활용해 조인 수행.
- **동작**:
  - 외부 테이블 행마다 인덱스를 통해 내부 테이블 행 검색.
- **특징**:
  - Nested Loop Join의 변형.
  - 인덱스 유무에 따라 성능 크게 차이.
- **사용 시**: 내부 테이블에 효율적인 인덱스 존재 시.
- **예시**: `SELECT * FROM users u JOIN roles r ON u.role_id = r.id;` (r.id에 인덱스).

---

## 추가 구현 방식

### 5. Sort-Merge Join
- **Merge Join의 변형**: 정렬이 안 된 경우 먼저 정렬 후 병합.
- **특징**: 초기 정렬 비용 높음, 이후 병합 빠름.

### 6. Block Nested Loop Join
- **Nested Loop 개선**: 메모리 버퍼에 외부 테이블 블록을 로드해 I/O 감소.
- **사용 시**: 메모리 활용 가능 시.

---

## 비교
| **알고리즘**      | **복잡도**    | **조건**             | **최적 상황**             |
|-------------------|---------------|----------------------|---------------------------|
| Nested Loop       | O(n × m)      | 모든 조인            | 작은 테이블, 인덱스       |
| Hash Join         | O(n + m)      | 등가 조인            | 큰 테이블, 메모리 여유    |
| Merge Join        | O(n log n)    | 정렬 가능 조인       | 정렬된 대량 데이터        |
| Index Join        | O(n log m)    | 인덱스 활용          | 인덱스된 내부 테이블      |

---

## 최적화 요소
- **인덱스**: 조인 컬럼에 인덱스 생성.
- **통계**: 쿼리 최적화기가 테이블 크기/분포 분석.
- **하드웨어**: 메모리와 디스크 속도 영향.

### 결론
- DBMS는 실행 계획을 통해 상황에 맞는 알고리즘 선택(예: PostgreSQL `EXPLAIN`, Oracle `EXPLAIN PLAN`).
- 개발자는 조인 조건과 인덱스 설계로 성능 개선 가능.
<li> 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?</li>
## 쿼리 실행 계획으로 JOIN 구현 방식 확인하기

### 기본 개념
- **실행 계획**: DBMS가 쿼리를 처리하는 단계와 알고리즘을 시각화한 정보.
- **목적**: 어떤 JOIN 방식이 사용되는지, 인덱스 활용 여부, 예상 비용 등을 파악.
- **확인 방법**: DBMS별 전용 명령어 사용.

---

## 주요 DBMS별 확인 방법

### 1. MySQL
- **명령어**: `EXPLAIN` 또는 `EXPLAIN ANALYZE` (MySQL 8.0 이상).
- **사용법**:
  ```sql
  EXPLAIN SELECT * FROM employees e JOIN departments d ON e.dept_id = d.id;
<li> 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?</li>
- 그렇다, 인덱스 여부에따라 데이터 풀 스캔을 할지 인덱스 스캔을 할 지 결정됨
<li> 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.</li>

- 기본적으로 두 개의 테이블을 조인하는 것과 비슷하게 작동하지만, 조인 순서와 조인 전략이 더 중요하게 작동
- SQL 쿼리는 일반적으로 왼쪽에서 오른쪽으로 읽히지만, A JOIN B JOIN C이라고 해서 A JOIN B를 먼저 수행한 후, 결과 값에 C를 조인하는 게 아니다.
 쿼리 옵티마이저가 뭘 먼저 조인했을 때 더 효율적인지 판단하고 수행하게 된다.
### 순차적 조인
- 먼저, 두 개의 테이블을 조인한 다음, 그 결과를 일시적인 중간 테이블에 저장하고, 그 중간 테이블과 세 번째 테이블과 조인한다.
### 조인 순서 최적화
쿼리 옵티마이저가 세 개의 테이블 중 어떤 두 테이블을 먼저 조인할지 선택
### Multi-way Join
세 개 이상의 테이블을 한 번에 조인하는 것이 아니라, 각 테이블 간의 조인 연산을 단계적으로 수행
옵티마이저가 다양한 방법을 시도하여 최적의 방법을 선택
### 번외) 3중 조인을 수행할 때 조건절
A JOIN B JOIN C ON (A.id = B.id) AND (B.id = C.id)
이런식으로 조건절을 뒤에 한번에 몰아쓰면 오류 발생
JOIN을 여러 개 사용할 때, 각 JOIN연산마다 별도의 ON절을 명시해야 한다.
SELECT *
FROM A
JOIN B ON A.id = B.id
JOIN C ON B.id = C.id;
</details>

<details>
  <summary><h3>10. B-Tree와 B+Tree에 대해 설명해 주세요.</h3>
# B-Tree와 B+Tree 비교

## B-Tree
B-Tree는 **균형 트리(Balanced Tree)** 로, 데이터베이스와 파일 시스템에서 널리 사용되는 **다진 검색 트리(M-ary Search Tree)** 입니다.

### 특징
- **균형 유지**: 모든 리프 노드가 동일한 깊이를 가짐
- **M차 트리**: 한 노드는 최대 M개의 자식을 가질 수 있음
- **내부 노드에 데이터 저장**: 검색 키와 함께 데이터가 저장됨
- **검색, 삽입, 삭제 연산의 성능이 O(log N)**

## B+Tree
B+Tree는 B-Tree의 확장된 형태로, **모든 실제 데이터는 리프 노드에만 저장**됩니다.

### 특징
- **리프 노드에만 데이터 저장**: 내부 노드는 인덱스 역할만 수행
- **리프 노드 간 연결(Linked List 구조)**: 순차 접근 성능 향상
- **B-Tree보다 높은 팬 아웃(Fan-out)**: 내부 노드에 데이터가 없으므로 더 많은 키를 저장 가능
- **검색 성능 향상**: 검색 시 리프 노드까지 도달해야 하지만, 범위 검색 및 순차 검색이 빠름

## B-Tree vs B+Tree 비교

| 비교 항목  | B-Tree | B+Tree |
|------------|--------|--------|
| 데이터 저장 위치 | 내부 노드 및 리프 노드 | 리프 노드에만 저장 |
| 순차 검색 성능 | 느림 | 빠름 (리프 노드 연결) |
| 범위 검색 | 상대적으로 느림 | 매우 빠름 |
| 노드 크기 | 더 큼 (데이터 포함) | 더 작음 (내부 노드는 인덱스 역할) |
| 사용 사례 | 일반적인 파일 시스템, 인덱스 구조 | 데이터베이스 인덱스, 높은 읽기 성능 요구 |

## 결론
- **B-Tree**: 읽기와 쓰기 성능이 균형적이며, 파일 시스템 등에서 자주 사용
- **B+Tree**: 빠른 순차 접근이 필요한 데이터베이스 인덱스에서 선호됨


</summary>
<ul>
<li> 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?</li>
# B+Tree의 단점 (B-Tree와 비교)

## 1. 추가적인 I/O 비용
- B-Tree는 내부 노드에서도 데이터를 찾을 수 있지만, B+Tree는 **반드시 리프 노드까지 내려가야 함**.
- 작은 데이터 세트에서는 오히려 비효율적일 수 있음.

## 2. 삽입 및 삭제 연산의 복잡성 증가
- B+Tree는 **리프 노드에만 데이터를 저장**하므로, 삽입/삭제 시 내부 노드와 리프 노드를 **모두 갱신해야 할 가능성**이 있음.
- B-Tree는 내부 노드에서도 삽입/삭제가 가능하여 구조 변경이 덜 발생할 수 있음.

## 3. 메모리 사용 증가
- B+Tree는 **모든 내부 노드가 인덱스 역할만 수행**하므로, 같은 깊이의 B-Tree보다 **더 많은 노드가 필요**할 수 있음.
- 리프 노드 간 **연결 리스트를 유지하기 위한 추가적인 포인터 공간**이 필요함.

## 4. 작은 데이터 집합에서는 불필요한 오버헤드
- B+Tree의 장점(범위 검색, 순차 검색 성능 향상)은 **대규모 데이터에 유리**하지만,  
  작은 데이터 세트에서는 **B-Tree보다 성능이 떨어질 수도 있음**.

---

# 결론
| 상황 | 추천하는 트리 |
|------|-------------|
| **빠른 범위 검색, 순차 검색 필요** | ✅ B+Tree |
| **삽입/삭제 성능과 메모리 효율 중요** | ✅ B-Tree |
| **데이터 크기가 작음** | ✅ B-Tree |

➡ **B+Tree가 항상 더 좋은 것은 아니며, 사용 목적과 환경에 따라 선택해야 함.**


<li> DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?</li>
# DB에서 RBT(Red-Black Tree)를 사용하지 않고 B-Tree/B+Tree를 사용하는 이유

## 1. **RBT는 트리의 깊이가 깊어질 수 있음**
- RBT는 이진 탐색 트리(BST) 기반이므로, **트리의 깊이가 상대적으로 깊어질 가능성이 있음**.
- 데이터베이스에서는 디스크 I/O를 최소화하는 것이 중요한데, **깊이가 깊어질수록 디스크 접근 횟수가 증가**하여 성능 저하가 발생할 수 있음.
- 반면, B-Tree/B+Tree는 **M-ary 트리(M-원 검색 트리)** 이므로, 트리의 깊이가 낮아지고 I/O 비용이 절감됨.

## 2. **디스크 I/O 최적화 필요**
- RBT는 **메모리 내 연산**에는 유리할 수 있으나, DB에서는 디스크 기반 저장 구조가 중요함.
- B-Tree/B+Tree는 **한 노드에 여러 개의 키를 저장하여 디스크 접근 횟수를 최소화**할 수 있음.
- 즉, 한 번의 디스크 읽기로 여러 키를 가져올 수 있어 성능이 향상됨.

## 3. **순차 검색 및 범위 검색 성능**
- RBT는 **순차 검색(범위 검색)에 비효율적**.
- B+Tree는 **리프 노드가 연결 리스트로 연결**되어 있어 **순차 검색이 매우 빠름**.
- 데이터베이스에서는 **인덱스를 활용한 범위 검색이 자주 발생**하므로, RBT보다 B+Tree가 더 적합함.

## 4. **삽입 및 삭제 시 균형 유지 비용**
- RBT는 삽입/삭제 시 **색상 변경 및 회전 연산이 필요**하여 오버헤드가 발생할 수 있음.
- B-Tree/B+Tree는 균형을 유지하기 위해 **노드 분할(Split)과 병합(Merge)** 을 수행하지만, RBT보다 연산이 덜 빈번하게 발생하여 성능이 더 안정적임.

---

# 결론
| 비교 항목 | RBT | B-Tree/B+Tree |
|----------|----|--------------|
| **트리 깊이** | 깊음 (BST 기반) | 낮음 (M-ary 트리) |
| **디스크 I/O** | 많음 (비효율적) | 적음 (효율적) |
| **순차 검색 성능** | 느림 | 빠름 (특히 B+Tree) |
| **삽입/삭제 오버헤드** | 색상 변경 및 회전 필요 | 노드 분할/병합으로 최적화 |
| **DB에서의 적합성** | ❌ 부적합 | ✅ 적합 |

➡ **RBT는 메모리 내 연산에는 유리하지만, 디스크 I/O가 중요한 DB 환경에서는 B-Tree/B+Tree가 훨씬 적합함.**

<li> 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.</li>
B 트리의 경우 내림차순 정렬을 시도할 경우, 모든 노드들을 역순으로 하나 하나 탐색해야 합니다. 따라서 B+ 트리 대비 낮은 성능을 보입니다.

B+ 트리의 경우
B+ 트리의 경우 내림차순 정렬을 시도할 경우, 리프 노드만 역순으로 탐색하면 되고, 리프 노드들이 링크드 리스트 형태를 띄고 있으므로 순차 접근에 최적화 되어있어 더 높은 성능을 보입니다.
</ul>
</details>

<details>
  <summary><h3>11. DB Locking에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.</li>
<li> 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?</li>
</ul>
</details>

<details>
  <summary><h3>12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?</h3></summary>
<ul>
<li> DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?</li>
</ul>
</details>

<details>
  <summary><h3>13. Schema가 무엇인가요?</h3></summary>
<ul>
  <li>Schema의 3계층에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>14. DB의 Connection Pool에 대해 설명해 주세요.</h3></summary>
<ul>
  <li>DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.</h3></summary>
<ul>
  <li>가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?</li>
  <li> COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요?</li>
</ul>
</details>

<details>
  <summary><h3>16. SQL Injection에 대해 설명해 주세요.</h3></summary>
<ul>
  <li>그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?</li>
</ul>
</details>
