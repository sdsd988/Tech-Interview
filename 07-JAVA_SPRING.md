## Java, Spring

<details>
  <summary><h3>1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.</h3></summary>

  JVM (Java Virtual Machine) 이란?
JVM(Java Virtual Machine)은 자바 바이트코드(.class 파일)를 실행하는 가상 머신입니다. 특정 하드웨어나 운영체제에 종속되지 않고 자바 프로그램이 실행될 수 있도록 중간 다리 역할을 수행합니다.

JVM의 주요 기능
JVM은 다음과 같은 핵심적인 기능들을 수행합니다.

바이트코드 실행: 자바 컴파일러가 생성한 바이트코드를 읽어 해석하거나(Interpreter) 네이티브 코드로 변환하여(JIT Compiler) 실행합니다.
메모리 관리: 프로그램 실행에 필요한 메모리 영역을 할당하고 관리합니다. 특히, 더 이상 사용하지 않는 객체를 자동으로 회수하는 **가비지 컬렉션(Garbage Collection, GC)**을 수행하여 메모리 누수를 방지합니다.
클래스 로딩: 클래스 로더를 통해 자바 클래스(.class 파일)를 JVM 메모리 영역으로 로드하고, 링크 과정을 거쳐 사용할 수 있도록 준비합니다.
보안: 바이트코드 검증 과정을 통해 악의적인 코드가 실행되는 것을 방지하고, 보안 관리자를 통해 시스템 자원에 대한 접근 권한을 관리합니다.
네이티브 인터페이스 (JNI, Java Native Interface): 자바 코드에서 특정 운영체제의 기능이나 하드웨어 관련 라이브러리(네이티브 코드)를 호출할 수 있도록 지원합니다.
스레드 관리: 멀티스레드 환경에서 스레드를 생성하고 스케줄링하며, 스레드 간의 동기화 및 통신을 지원합니다.
JVM의 구조
JVM은 크게 다음과 같은 구성 요소로 이루어져 있습니다.

클래스 로더 (Class Loader Subsystem):
.class 파일을 읽어 JVM 내부의 런타임 데이터 영역으로 로드합니다.
로딩 (Loading): 클래스 파일을 읽어와 JVM의 메모리에 저장합니다.
링킹 (Linking): 로드된 클래스를 사용할 수 있도록 연결하는 과정입니다.
검증 (Verification): 바이트코드가 JVM 명세에 맞게 작성되었는지, 보안상 문제가 없는지 검사합니다.
준비 (Preparation): 클래스 변수를 위한 메모리를 할당하고 기본값으로 초기화합니다.
해석 (Resolution): 심볼릭 참조를 실제 메모리 주소로 변경합니다.
초기화 (Initialization): 클래스 변수를 명시적인 값으로 초기화하고, static 블록을 실행합니다.
런타임 데이터 영역 (Runtime Data Areas): JVM이 프로그램을 실행하면서 사용하는 다양한 데이터를 저장하는 메모리 영역입니다.
힙 (Heap): new 연산자로 생성된 객체와 배열이 저장되는 공간입니다. 가비지 컬렉션의 주요 대상입니다.
메서드 영역 (Method Area): 클래스 정보(이름, 필드, 메서드 등), 상수 풀(Constant Pool), static 변수 등이 저장되는 공간입니다.
JVM 스택 (JVM Stacks): 각 스레드마다 생성되는 스택으로, 메서드 호출과 관련된 정보(지역 변수, 매개변수, 리턴 주소 등)를 담고 있는 스택 프레임을 저장합니다.
네이티브 메서드 스택 (Native Method Stacks): 네이티브 메서드 실행을 위한 스택입니다.
PC 레지스터 (Program Counter Register): 각 스레드가 현재 실행할 JVM 명령어의 주소를 저장합니다.
실행 엔진 (Execution Engine): 로드된 바이트코드를 실제로 실행하는 역할을 담당합니다.
인터프리터 (Interpreter): 바이트코드를 한 줄씩 읽어와서 실행합니다.
JIT(Just-In-Time) 컴파일러: 자주 사용되는 바이트코드 블록을 네이티브 코드로 컴파일하여 실행 속도를 향상시킵니다.
가비지 컬렉터 (Garbage Collector): 더 이상 참조되지 않는 객체를 찾아 메모리에서 제거하는 역할을 수행합니다.
JVM은 자바의 **"Write Once, Run Anywhere" (한 번 작성하면 어디서든 실행된다)**라는 특징을 가능하게 하는 핵심적인 기술입니다. 개발자는 운영체제에 종속적인 코드를 작성할 필요 없이 JVM 위에서 실행될 수 있는 자바 코드를 작성하면 됩니다. 각 운영체제에 맞는 JVM만 설치되어 있다면 동일한 자바 프로그램을 실행할 수 있습니다.
<ul>
<li> 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?</li>
  네, 자바 외의 다른 언어들도 JVM 위에서 실행될 수 있습니다. 이러한 언어들을 JVM 언어라고 부릅니다. JVM은 특정 프로그래밍 언어에 종속적인 것이 아니라, 자바 바이트코드라는 특정 형식의 중간 코드를 이해하고 실행하는 가상 머신이기 때문입니다.

자바 바이트코드로 컴파일될 수 있는 언어라면 어떤 언어든지 JVM 위에서 실행될 수 있습니다. JVM 언어들은 자바 생태계의 강력한 라이브러리와 프레임워크를 그대로 활용할 수 있으며, 자바 코드와 상호 운용성도 뛰어납니다.

대표적인 JVM 언어:

Kotlin: 간결하고 현대적인 문법을 제공하며, 안드로이드 공식 언어로 지정되면서 많은 인기를 얻고 있습니다. 자바와 100% 호환됩니다.
Scala: 함수형 프로그래밍과 객체 지향 프로그래밍을 모두 지원하는 강력한 언어입니다. 간결한 문법과 높은 생산성을 제공하며, 빅데이터 처리 분야에서 많이 사용됩니다.
Groovy: 동적 타이핑을 지원하며, 스크립트 언어처럼 사용할 수 있습니다. 자바와의 호환성이 뛰어나며, 빌드 자동화 도구인 Gradle의 기본 언어로 사용됩니다.
Clojure: Lisp 방언 중 하나로, 함수형 프로그래밍에 특화된 언어입니다. 불변성, 동시성 처리 등에 강점을 가지고 있습니다.
JRuby: Ruby 언어의 JVM 구현체입니다. Ruby의 문법을 그대로 사용하면서 JVM의 기능을 활용할 수 있습니다.
Jython: Python 언어의 JVM 구현체입니다. Python 코드를 JVM 위에서 실행하고, 자바 라이브러리와의 연동을 지원합니다.

<li> 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?</li>
대부분의 JVM 계열 언어는 JVM 위에서 실행되는 것을 목표로 설계되었으며, 바이트코드라는 중간 단계를 거칩니다. 네이티브 코드로 직접 컴파일하는 것은 기술적으로 어렵거나 제한적이며, 일반적인 개발 및 배포 방식은 아닙니다. JVM의 장점(플랫폼 독립성, 메모리 관리 등)을 포기하면서 네이티브 컴파일을 시도하는 것은 대부분의 경우 효율적이지 않습니다.

<li> VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.</li>
VM(Virtual Machine) 사용의 장점과 단점
VM(Virtual Machine), 즉 가상 머신을 사용하는 것은 다양한 이점을 제공하지만, 동시에 몇 가지 단점도 존재합니다.

장점
플랫폼 독립성 (Platform Independence): VM은 호스트 운영체제와 독립적인 가상 환경을 제공합니다. 따라서 VM 내에서 실행되는 소프트웨어는 호스트 OS의 종류(Windows, macOS, Linux 등)에 관계없이 동일하게 작동할 수 있습니다. 이는 개발, 테스트 및 배포 환경을 일관성 있게 유지하는 데 매우 유용합니다.
자원 활용도 향상: 물리적 서버 한 대에 여러 개의 VM을 생성하여 각 VM에 필요한 만큼의 자원을 할당할 수 있습니다. 이를 통해 서버의 유휴 자원을 효율적으로 활용하고, 하드웨어 투자 비용을 절감할 수 있습니다.
유연성 및 확장성: 필요에 따라 VM의 사양(CPU, 메모리, 디스크 공간 등)을 쉽게 변경하거나 새로운 VM을 추가/삭제할 수 있습니다. 이는 시스템 요구 사항 변화에 빠르게 대응하고, 서비스 확장성을 높이는 데 도움이 됩니다.
격리 및 보안: 각 VM은 독립적인 환경에서 실행되므로, 하나의 VM에서 발생한 문제(오류, 보안 침해 등)가 다른 VM이나 호스트 시스템에 영향을 미치지 않습니다. 이는 시스템 안정성과 보안성을 향상시키는 데 기여합니다.
테스트 및 개발 환경 용이성: 다양한 운영체제 및 소프트웨어 구성을 가진 VM을 쉽게 생성하고 복제할 수 있어, 소프트웨어의 호환성 테스트나 개발 환경 구축에 매우 편리합니다. 또한, 문제가 발생했을 경우 스냅샷 기능을 이용하여 이전 상태로 빠르게 복원할 수 있습니다.
재해 복구 및 백업: VM 전체를 파일 형태로 백업하고 복제하는 것이 용이하므로, 시스템 장애 발생 시 빠르게 복구하거나 다른 환경으로 마이그레이션할 수 있습니다.
레거시 시스템 지원: 오래된 운영체제나 특정 환경에서만 작동하는 레거시 애플리케이션을 최신 호스트 OS 환경에서 VM을 통해 실행할 수 있습니다.
단점
성능 오버헤드 (Performance Overhead): VM은 호스트 OS 위에 추상화 계층을 추가하므로, VM 내에서 실행되는 애플리케이션은 물리적 환경에서 직접 실행되는 것보다 성능이 저하될 수 있습니다. 특히 CPU, 메모리, 디스크 I/O 등의 자원을 공유하는 경우 성능 저하가 더 두드러질 수 있습니다.
자원 소비: 각 VM은 자체적인 운영체제와 애플리케이션을 실행하기 위해 일정량의 시스템 자원(CPU, 메모리, 디스크 공간)을 소비합니다. 따라서 너무 많은 VM을 동시에 실행하면 호스트 시스템의 자원 부족으로 인해 전체적인 성능이 저하될 수 있습니다.
설정 및 관리 복잡성: 여러 개의 VM을 효율적으로 관리하고 운영하기 위해서는 전문적인 지식과 도구가 필요합니다. VM 생성, 설정, 모니터링, 보안 관리 등에 대한 추가적인 노력이 요구될 수 있습니다.
라이선스 비용: VM 내에서 실행되는 운영체제 및 소프트웨어에 대한 라이선스 비용이 추가적으로 발생할 수 있습니다.
호환성 문제 (드문 경우): 특정 하드웨어 기능이나 고급 운영체제 기능을 VM이 완벽하게 지원하지 못할 수 있습니다. 이는 특정 애플리케이션의 호환성 문제를 일으킬 수 있습니다.
결론적으로, VM은 다양한 이점을 제공하여 시스템 관리, 개발, 테스트 등 여러 분야에서 유용하게 활용될 수 있습니다. 하지만 성능 오버헤드, 자원 소비, 관리 복잡성 등의 단점도 고려해야 하며, 사용 목적과 환경에 따라 적절한 선택과 구성이 필요합니다.

<li> JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?</li>
일반적으로 JVM과 그 내부에서 실행되는 자바 프로그램 간의 관계를 엄밀하게 부모-자식 프로세스 관계라고 보기는 어렵습니다. 더 정확하게 설명하자면, JVM은 하나의 프로세스로 실행되며, 그 내부에서 여러 개의 스레드를 생성하고 관리하여 자바 프로그램을 실행합니다.

이유:

프로세스 vs. 스레드:

프로세스: 운영체제로부터 독립적인 메모리 공간과 자원을 할당받아 실행되는 독립적인 실행 단위입니다. 각 프로세스는 자신만의 주소 공간을 가지므로, 다른 프로세스의 메모리에 직접 접근할 수 없습니다.
스레드: 하나의 프로세스 내에서 실행되는 더 작은 실행 단위입니다. 스레드는 프로세스가 할당받은 메모리 공간을 공유하며, 동시에 여러 작업을 수행할 수 있습니다.
JVM의 작동 방식:

사용자가 자바 프로그램을 실행하면, 운영체제는 JVM 실행 파일을 로드하여 하나의 새로운 프로세스를 생성합니다. 이 JVM 프로세스는 자체적인 메모리 공간(힙, 스택 등)을 할당받습니다.
JVM 프로세스가 시작되면, 클래스 로더를 통해 필요한 클래스들을 메모리에 로드하고, 메인 스레드를 포함한 여러 개의 스레드를 생성합니다.
자바 프로그램의 코드는 이 JVM 프로세스 내에서 생성된 스레드들에 의해 실행됩니다.
따라서, 자바 프로그램 자체는 별도의 운영체제 프로세스로 실행되는 것이 아니라, 이미 실행 중인 JVM 프로세스 내의 여러 스레드들의 집합으로 볼 수 있습니다.

유사한 점:

물론, 비유적으로 보았을 때 몇 가지 유사한 점은 있을 수 있습니다.

생명 주기: JVM 프로세스가 종료되면 그 내부에서 실행 중이던 모든 스레드(자바 프로그램)도 함께 종료됩니다. 이는 부모 프로세스가 종료되면 자식 프로세스도 종료되는 것과 유사하게 보일 수 있습니다.
자원 관리: JVM 프로세스는 내부에서 실행되는 스레드들에게 메모리, CPU 시간 등의 자원을 할당하고 관리합니다. 이는 부모 프로세스가 자식 프로세스에게 일부 자원을 할당하는 것과 유사하게 생각될 수 있습니다.
결론:

엄밀한 의미에서 JVM과 내부에서 실행되는 자바 프로그램은 부모-자식 프로세스 관계가 아닌, 프로세스-스레드 관계를 갖습니다. JVM은 하나의 프로세스로 실행되고, 자바 프로그램은 그 JVM 프로세스 내에서 여러 개의 스레드로 실행되는 것입니다.

이러한 이해는 자바 프로그램의 동시성 모델, 메모리 관리, 프로세스 간 통신 등을 이해하는 데 중요합니다.

</ul>
</details>

<details>
  <summary><h3>2. final 키워드를 사용하면, 어떤 이점이 있나요?</h3></summary>

  final 키워드의 이점
1. 불변성 확보 및 객체의 안정성 향상 (변수)
기본 타입 변수: final로 선언된 기본 타입 변수는 최초 할당된 값을 변경할 수 없습니다. 이는 변수의 값이 프로그램 실행 도중 예기치 않게 바뀌는 것을 방지하여 코드의 안정성을 높이고, 예측 가능성을 향상시킵니다.
참조 타입 변수: final로 선언된 참조 타입 변수는 다른 객체를 참조하도록 변경할 수 없습니다. 즉, 변수가 가리키는 객체의 주소는 고정됩니다. 하지만, 그 객체 내부의 상태(필드 값)는 final로 선언되지 않았다면 변경될 수 있습니다.
쓰레드 안전성: 불변 객체는 여러 쓰레드에서 동시에 접근해도 데이터 경쟁(race condition)이 발생하지 않으므로, 쓰레드 안전한 코드를 작성하는 데 도움이 됩니다. final 참조 변수가 불변 객체를 가리키도록 하면, 별도의 동기화 처리 없이 안전하게 공유할 수 있습니다.
2. 메서드 오버라이딩 방지 (메서드)
final로 선언된 메서드는 하위 클래스에서 오버라이딩할 수 없습니다. 이는 다음과 같은 이점을 제공합니다.
설계 의도 보존: 상위 클래스에서 중요한 기능을 수행하거나 특정 방식으로 동작하도록 설계된 메서드의 구현이 하위 클래스에서 변경되는 것을 막아 설계 의도를 유지할 수 있습니다.
일관성 유지: 상위 클래스의 메서드 동작이 하위 클래스에서 다르게 구현되어 발생할 수 있는 예기치 않은 동작이나 오류를 방지하여 코드의 일관성을 유지합니다.
보안 강화: 보안과 관련된 중요한 메서드가 하위 클래스에서 악의적으로 오버라이딩되는 것을 방지하여 시스템의 보안을 강화할 수 있습니다.
3. 클래스 확장 방지 (클래스)
final로 선언된 클래스는 다른 클래스가 상속할 수 없습니다. 이는 다음과 같은 경우에 유용합니다.
불변 클래스: String, Math 클래스처럼 내부 상태가 변경될 수 없는 불변 클래스를 만들 때 final로 선언하여 의도치 않은 상속을 막고 불변성을 보장할 수 있습니다.
특정 구현 강제: 클래스의 구현이 더 이상 변경되거나 확장될 필요가 없다고 판단될 때 final로 선언하여 하위 클래스 생성을 방지하고 특정 구현을 강제할 수 있습니다.
성능 향상 가능성: 컴파일러가 final 클래스에 대한 추가적인 최적화를 수행할 수 있어, 미미하지만 성능 향상을 기대할 수 있습니다.
요약
final 키워드는 코드의 안정성, 예측 가능성, 보안성을 높이는 데 중요한 역할을 합니다. 변수를 불변으로 만들어 데이터의 무결성을 유지하고, 메서드 오버라이딩을 막아 설계 의도를 보존하며, 클래스 상속을 제한하여 특정 구현을 강제하는 등 다양한 이점을 제공합니다. 따라서 상황에 맞게 final 키워드를 적절히 사용하는 것은 좋은 프로그래밍 습관입니다.
<ul>
<li> 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?</li>

  컴파일러의 final 키워드 처리
1. 변수 (final 필드 및 지역 변수)
컴파일 타임 상수 처리: final로 선언된 기본 타입 변수가 컴파일 시점에 값이 확정될 수 있는 상수 표현식으로 초기화된 경우 (예: final int MAX_VALUE = 100;), 컴파일러는 이 변수를 컴파일 타임 상수로 취급합니다. 이는 다음과 같은 이점을 가집니다.
인라인 치환 (Inline Substitution): 해당 final 변수가 사용되는 모든 곳에서 컴파일러는 변수 이름 대신 직접 그 값을 사용할 수 있습니다. 이는 런타임에 변수 접근 과정을 생략하여 성능 향상에 미미하게 기여할 수 있습니다.
상수 풀 최적화: 컴파일러는 이러한 상수 값을 클래스 파일의 상수 풀에 저장하여 효율적으로 관리합니다.
불변성 검증: 컴파일러는 final 변수가 초기화된 후 다시 할당되는 코드가 있는지 검사합니다. 재할당 시 컴파일 에러를 발생시켜 final 변수의 불변성을 보장합니다.
Definite Assignment 분석: final 지역 변수의 경우, 컴파일러는 변수가 사용되기 전에 반드시 한 번 초기화되었는지 확인하는 Definite Assignment 분석을 수행합니다. 초기화되지 않은 final 지역 변수를 사용하려고 하면 컴파일 에러가 발생합니다.
2. 메서드 (final 메서드)
오버라이딩 방지: 컴파일러는 final 메서드가 하위 클래스에서 오버라이딩되는 코드를 발견하면 컴파일 에러를 발생시켜 메서드 오버라이딩을 금지합니다.
최적화 가능성 증대: final 메서드는 오버라이딩될 수 없다는 정보는 컴파일러에게 추가적인 최적화 기회를 제공할 수 있습니다. 예를 들어, 컴파일러는 final 메서드 호출을 인라인화하는 것을 더 적극적으로 고려할 수 있습니다. (실제 JVM의 JIT 컴파일러가 주로 수행하지만, 컴파일러도 힌트를 얻을 수 있습니다.)
3. 클래스 (final 클래스)
상속 방지: 컴파일러는 final 클래스를 상속하려는 시도가 있으면 컴파일 에러를 발생시켜 상속을 금지합니다.
최적화 가능성 증대: final 클래스는 더 이상 하위 클래스를 가질 수 없으므로, 컴파일러는 객체 생성 및 메서드 호출과 관련된 특정 최적화를 수행할 수 있습니다. 예를 들어, 가상 메서드 호출 대신 직접 메서드 호출로 대체하는 등의 최적화가 가능할 수 있습니다. (이 또한 주로 JIT 컴파일러의 영역이지만, 컴파일러도 정보를 활용할 수 있습니다.)
요약하자면, final 키워드는 컴파일러에게 다음과 같은 정보를 제공하고, 이를 통해 컴파일러는 다양한 검증과 최적화를 수행할 수 있습니다.

불변성 보장: 변수가 한 번 할당된 후 변경되지 않음을 컴파일러에게 알려주어 데이터의 안정성을 확보하고 잠재적인 버그를 방지합니다.
오버라이딩/상속 방지: 메서드나 클래스가 확장되지 않아야 하는 설계 의도를 컴파일러에게 명시적으로 전달하여 코드의 구조를 유지하고 예상치 못한 변경을 막습니다.
최적화 힌트 제공: 컴파일러에게 추가적인 정보를 제공하여 런타임 성능 향상을 위한 최적화(인라인 치환 등)를 수행할 수 있는 가능성을 열어줍니다.
따라서 final 키워드는 단순히 런타임 제약만을 제공하는 것이 아니라, 컴파일 단계에서부터 코드의 정확성, 안정성, 그리고 잠재적인 성능 향상에 기여하는 중요한 역할을 수행합니다.

** 추가질문 **

Javascript에서는 Java의 final과 유사한 const 개념이 있다고 하는데, Java final과의 차이점은 무엇?

</ul>
</details>

<details>
  <summary><h3>3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.</h3></summary>

1. 목적
인터페이스 (Interface):

기능의 명세를 정의한다.

어떤 동작을 해야 하는지만 약속하고, 구현은 하지 않는다.

추상 클래스 (Abstract Class):

공통된 속성이나 **행동(기능)**을 정의하면서,

일부는 직접 구현하고 일부는 자식 클래스에게 구현을 맡긴다.

```java
interface Vehicle {
    void move();
}
```

```java
abstract class Vehicle {
    abstract void move();
    void start() {
        System.out.println("Vehicle started");
    }
}

```

추가질문 언제 인터페이스를 사용하고, 언제 추상클래스를 사용하는게 좋을까요? 혹은 사용해 본 경험이 있나요
1. 인터페이스를 사용하는 경우
서로 관계 없는 클래스들에 공통 기능을 부여하고 싶을 때

예: Bird, Airplane 모두 Flyable 인터페이스를 구현할 수 있음.

다중 상속이 필요한 경우

Java는 클래스 다중 상속은 불가하지만, 인터페이스는 여러 개 구현 가능.

**기능을 약속(규격화)**하고 싶을 때

예: 어떤 객체든 Serializable하면 직렬화가 가능함을 보장.

역할 중심 설계를 할 때

"나는 어떤 일을 할 수 있다"를 명시하고 싶을 때 사용.

✏️ 키워드
"무엇을 할 수 있다." (Can do something)
→ Runnable, Closable, Iterable 등

2. 추상 클래스를 사용하는 경우
서로 밀접한 관계가 있는 클래스들의 공통 로직을 공유할 때

예: Dog, Cat 모두 Animal의 공통 메소드를 상속.

**상태(필드) + 기능(메소드)**을 함께 물려주고 싶을 때

예: protected String name; 같은 필드를 공통으로 상속.

부분적으로 구현을 제공하고, 나머지는 자식 클래스가 구현하게 하고 싶을 때

기본 동작을 정의해주면서, 세부 동작은 자식 클래스에 맡김.

자식 클래스에 '강제성'을 부여하고 싶을 때

특정 메소드는 반드시 재정의하도록 강제할 수 있음 (abstract method).

✏️ 키워드
"무언가의 종류이다." (Is a kind of something)
→ Animal, Vehicle, Employee 등

3. 요약

상황	선택
다양한 관계 없는 클래스에 동일 기능을 부여하고 싶다	인터페이스
클래스들 사이에 강한 관계가 있고, 공통 코드를 공유하고 싶다	추상 클래스
다중 상속이 필요하다	인터페이스
일부 기본 동작을 제공하고 싶다	추상 클래스
추가로
실무에서는 보통 인터페이스 + 구현 클래스 조합을 많이 사용하고,
필요할 때만 추상 클래스로 공통 코드를 모듈화하는 식으로 씁니다.



  
<ul>
<li> 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?</li>

1. 클래스는 "구현(코드)"를 상속받기 때문에 충돌 위험이 크다
클래스는 변수, 메소드 구현체를 모두 상속받습니다.

만약 두 개 이상의 클래스를 상속하게 되면, 같은 이름의 메소드나 필드가 있을 때 어떤 걸 사용할지 모호성(ambiguity) 문제가 발생합니다.

```java
class A {
    void print() {
        System.out.println("A");
    }
}

class B {
    void print() {
        System.out.println("B");
    }
}

// 만약 C가 A, B를 모두 상속하면?
class C extends A, B { // Java에서는 불가능
}

```

➡️ C에서 print()를 호출하면, A의 print()를 쓸지 B의 print()를 쓸지 알 수 없음 → 충돌!

🔵 그래서 Java는 클래스의 다중 상속을 금지했습니다.

2. 인터페이스는 "구현이 없는 규칙"만 상속하기 때문에 충돌 위험이 적다
인터페이스는 기본적으로 **메소드 시그니처(이름 + 파라미터)**만 정의하고, 구현(내용)은 없습니다.

따라서 어떤 인터페이스를 여러 개 구현해도 충돌이 발생하지 않습니다.

```java
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

class Duck implements Flyable, Swimmable {
    public void fly() {
        System.out.println("Duck flies");
    }

    public void swim() {
        System.out.println("Duck swims");
    }
}

```

➡️ Duck은 Flyable과 Swimmable을 모두 구현할 수 있고,
➡️ 둘은 서로 간섭하지 않으니까 충돌이 없음.

🔵 그래서 Java는 인터페이스 다중 구현을 허용했습니다.

3. 요약

구분	클래스 상속	인터페이스 구현
내용(구현) 포함	O	X (Java 8부터 default 메소드 일부 구현 가능하지만 충돌 방지 규칙 존재)
충돌 가능성	높음	낮음
다중 상속/구현 가능 여부	❌ 불가능	✅ 가능
4. 추가: Java 8 이후 인터페이스에 default 메소드가 생긴 이유
Java 8부터 인터페이스에도 default 메소드를 선언해서 기본 구현을 가질 수 있게 했어요.

이 경우 여러 인터페이스에 같은 시그니처의 default 메소드가 있을 때는 구현 클래스가 명시적으로 override해야 합니다.

그래서 여전히 모호성 문제를 막고 있습니다.

```java

interface A {
    default void hello() {
        System.out.println("Hello from A");
    }
}

interface B {
    default void hello() {
        System.out.println("Hello from B");
    }
}

class C implements A, B {
    public void hello() {
        A.super.hello(); // 명시적으로 호출
    }
}

```

정리하면:

"클래스는 '구현'을 상속하니까 충돌 위험 때문에 단일 상속만,
인터페이스는 '약속'만 상속하니까 충돌이 적어 다중 구현을 허용"

</ul>
</details>

<details>
  <summary><h3>4. 리플렉션에 대해 설명해 주세요.</h3></summary>
  1. 리플렉션이란?

  **"실행 중(run-time)에 클래스, 메소드, 필드 등에 접근하고 조작할 수 있는 기능"**입니다.

원래는 컴파일 시점에 결정되는 것(클래스 타입, 메소드 호출 등)을 런타임에 동적으로 다룰 수 있게 해주는 기술입니다.

즉, "몰랐던 클래스나 메소드도 실행 중에 찾아서 사용할 수 있다."

2. 리플렉션으로 할 수 있는 것
클래스 이름을 문자열로 받아 클래스 객체(Class 객체) 생성

객체의 필드(변수), 메소드, 생성자에 접근하고 호출

private 필드나 메소드도 접근 가능 (권한 무시 가능)

새 객체 생성, 메소드 실행, 필드 값 읽고/쓰기 가능


리플렉션의 단점

단점	설명
성능 저하	리플렉션은 일반 코드 호출보다 느립니다. (런타임 검사 추가)
보안 위험	private 멤버에도 접근 가능 → 보안적으로 위험할 수 있음
유지보수 어려움	컴파일 타임 체크가 안 되기 때문에, 에러가 런타임에 터질 수 있음
6. 리플렉션을 사용하는 대표적인 예
프레임워크(Spring, Hibernate 등):
의존성 주입(Dependency Injection), 객체 생성 시 리플렉션 사용

테스트 프레임워크(JUnit 등):
테스트 메소드를 자동으로 찾아 실행

라이브러리 로딩:
JDBC 드라이버 등록 시 "Class.forName("com.mysql.cj.jdbc.Driver")" 사용

<ul>
<li> 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?</li>

  1. 네, 리플렉션은 보안 위험이 실제로 존재합니다.
리플렉션을 사용하면, private이나 protected로 선언된 필드나 메소드에도 setAccessible(true)로 강제로 접근할 수 있습니다.

원래 클래스 설계자가 숨기고 싶었던 내부 데이터나 로직을 외부 코드가 강제로 조작할 수 있게 됩니다.

특히, 악성 코드가 리플렉션을 사용하면 시스템 객체나 민감한 정보를 무단 조작하거나 노출시킬 수도 있습니다.

🔥 즉, 리플렉션은 **캡슐화(encapsulation)**를 깨뜨릴 수 있는 무기입니다.

2. 리플렉션 보안 문제 실제 사례
과거 Java 애플리케이션에서, 취약한 라이브러리를 통해 민감한 private 필드에 접근하고 값을 조작해 시스템 권한을 탈취하는 사례가 있었습니다.

Android 해킹이나 일부 서버 해킹은 리플렉션을 악용해서 시스템 보호를 뚫는 방식으로 진행되기도 했습니다.

3. 그렇다면, 어떻게 방지할까?
(1) SecurityManager를 설정한다 (옛날 방식)
Java에는 SecurityManager라는 보안 시스템이 있었습니다.

SecurityManager를 활성화하면 리플렉션을 통한 민감한 접근을 막을 수 있었어요.

하지만 Java 17 이후부터 SecurityManager는 Deprecated(사용 중단 예정) 됐습니다. (→ 장기적으로는 대체 기술로 넘어가는 중)

(2) 민감한 클래스는 리플렉션 허용을 강제 제한한다
중요한 클래스에서는 리플렉션 접근을 막기 위해 코드 레벨에서 방어하는 방법도 있습니다.

예를 들어, 리플렉션으로 호출될 수 있는 메소드에 대해 방어 코드를 추가할 수 있어요.

(3) 접근 제어를 신경 쓴다
불필요한 public 메소드는 최대한 만들지 않는다.

private/protected로 멤버를 관리하고, setter 같은 것도 필요 최소한만 공개한다.

(4) 애초에 리플렉션 사용을 최소화한다
리플렉션이 필요한 경우에도, 꼭 필요한 부분에서만 제한적으로 사용한다.

성능 저하 + 보안 이슈를 동시에 줄일 수 있다.

(5) 모듈 시스템(JPMS, Java 9 이상)을 활용한다
Java 9부터 도입된 **Java Platform Module System (JPMS)**를 사용하면,
모듈 별로 어떤 패키지를 외부에 공개할지 통제할 수 있습니다.

모듈화하면, 외부에서 마음대로 리플렉션으로 접근하는 걸 제어할 수 있어요.
<li> 리플렉션을 언제 활용할 수 있을까요?</li>
활용 상황 | 설명
프레임워크 제작 | 런타임에 유저 코드를 분석하고 자동화
어노테이션 기반 개발 | 메타데이터 읽어서 동작 다르게
플러그인 시스템 구축 | 동적 클래스 로딩
디버깅/도구 제작 | 객체 내부 동적 접근
</ul>
</details>

<details>
  <summary><h3>5. static class와 static method를 비교해 주세요.</h3></summary>

| 구분           | static class                                     | static method                                 |
|:--------------|:-------------------------------------------------|:---------------------------------------------|
| 대상           | 클래스                                           | 메소드(함수)                                |
| 의미           | 클래스가 외부 클래스 인스턴스에 독립적이다         | 메소드가 객체 상태와 무관하다               |
| 사용 목적      | 내부 클래스를 외부 클래스와 독립적으로 사용하고 싶을 때 | 객체 상태와 무관한 동작을 수행할 때         |
| 사용 위치      | 주로 내부 클래스(inner class) 에 사용            | 클래스 내부 어디든 가능                     |
| 접근 방식      | 클래스 이름으로 직접 접근                       | 클래스 이름으로 직접 호출                  |
| 예시           | `OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass();` | `Math.abs(-10);`                            |


  1. static class (정적 클래스)
설명:

보통 클래스 안에 선언된 클래스(중첩 클래스, Nested Class) 앞에 static을 붙이는 것을 말합니다.

static이 붙으면, 바깥 클래스의 인스턴스와 무관하게 사용할 수 있습니다.

예시:

java
복사
편집
class Outer {
    static class Inner {
        void hello() {
            System.out.println("Hello from static inner class");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Outer.Inner inner = new Outer.Inner(); // Outer 인스턴스 없이 생성 가능
        inner.hello();
    }
}
포인트:

Outer 객체를 만들지 않고도 Inner 클래스를 사용할 수 있다.

static이 없는 inner class는 반드시 Outer 인스턴스가 있어야만 생성할 수 있음.

2. static method (정적 메소드)
설명:

객체를 생성하지 않고도 호출할 수 있는 메소드입니다.

객체의 필드나 메소드에 접근할 수 없습니다. (this 사용 불가)

예시:

java
복사
편집
class Utils {
    public static int add(int a, int b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        int result = Utils.add(3, 5); // 객체 생성 없이 호출
        System.out.println(result);
    }
}
포인트:

new Utils() 같은 객체 생성 없이 Utils.add() 바로 호출 가능.

메소드가 특정 객체의 상태에 의존하지 않고, 입력값만으로 동작할 때 사용.

3. 정리 문장
static class는 "클래스와 외부 인스턴스의 독립"

static method는 "메소드와 객체 상태의 독립"


<ul>
<li> static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?</li>
### static 사용 시 이점

| 항목                  | 설명                                                                 |
|:---------------------|:--------------------------------------------------------------------|
| 객체 생성 없이 사용 가능  | 클래스를 인스턴스화하지 않고 바로 접근 가능 → 편하고 메모리 절약               |
| 메모리 효율             | static 멤버는 JVM의 **메소드 영역(Method Area)**에 올라감 → 인스턴스마다 복사되지 않음 |
| 공통 데이터 공유         | 여러 인스턴스가 하나의 static 변수(데이터)를 공유                           |
| 코드 간결성             | 객체 상태와 무관한 유틸리티성 메소드를 쉽게 작성 가능 (ex: Math, Collections)  |
| 프로그램 시작점 제공      | main 메소드는 static이어야 함 (JVM이 객체 없이 호출해야 하므로)             |

### static 사용 시 제약

| 항목                   | 설명                                                                 |
|:----------------------|:--------------------------------------------------------------------|
| 인스턴스 변수/메소드 접근 불가 | static 메소드 안에서는 `this`, 인스턴스 필드 사용 불가                     |
| 상태 유지 어려움         | 객체마다 다른 상태를 가지는 것(캡슐화된 상태 관리)이 불가능                  |
| 테스트 어려움            | static 메소드는 객체 지향적으로 Mocking/Test Double을 쓰기 어렵게 만듦 (테스트 코드 작성 힘듦) |
| 설계 유연성 저하          | 다형성(Polymorphism)을 활용하기 힘듦. 오버라이딩 불가.                       |
| 메모리 해제 어려움        | static 변수는 프로그램이 끝날 때까지 살아있음 → 메모리 누수(memory leak) 위험 |

<li> 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.</li>

static은 컴파일 타임에 "이건 클래스에 귀속된 멤버야"라고 마킹하고,
JVM 런타임에서 메소드 영역에 미리 올려두고 전역처럼 사용하게 한다.
</ul>
</details>

<details>
  <summary><h3>6. Java의 Exception에 대해 설명해 주세요.</h3></summary>
  Java에서 **Exception (예외)**은 프로그램 실행 중에 발생할 수 있는 예상치 못한 상황이나 오류를 의미합니다. 이러한 예외를 제대로 처리하지 않으면 프로그램이 비정상적으로 종료될 수 있습니다. Java는 강력한 예외 처리 메커니즘을 제공하여 이러한 상황에 유연하게 대처하고 프로그램의 안정성을 높일 수 있도록 합니다.

  Java의 예외는 크게 두 가지 주요 카테고리로 나뉩니다.

Checked Exception (확인된 예외):

Exception 클래스를 상속받았지만 RuntimeException 클래스를 상속받지 않은 예외들입니다.
컴파일러가 예외 처리 여부를 반드시 확인합니다. 즉, Checked Exception이 발생할 가능성이 있는 코드는 반드시 try-catch 블록으로 감싸거나, 해당 메서드 선언부에 throws 키워드를 사용하여 호출한 메서드로 예외를 던져야 합니다.
주로 외부 환경과의 상호작용에서 발생할 가능성이 있는 예외 (예: IOException, SQLException)입니다.
Unchecked Exception (확인되지 않은 예외 또는 Runtime Exception):

RuntimeException 클래스 또는 그 하위 클래스를 상속받은 예외들입니다.
컴파일러가 예외 처리 여부를 강제하지 않습니다. 개발자의 부주의나 논리적 오류로 인해 발생할 가능성이 높은 예외입니다.
주요 Unchecked Exception 종류:
NullPointerException: null 참조를 사용하려 할 때 발생
ArrayIndexOutOfBoundsException: 배열의 유효 범위를 벗어난 인덱스에 접근하려 할 때 발생
ClassCastException: 객체를 부적절한 타입으로 캐스팅하려 할 때 발생
IllegalArgumentException: 메서드에 부적절한 인수를 전달했을 때 발생
ArithmeticException: 0으로 나누는 등 산술 연산 오류 발생 시
Error (에러):

Error 클래스 또는 그 하위 클래스를 상속받은 예외들입니다.
주로 시스템 레벨의 심각한 문제로, 애플리케이션이 복구하기 어려운 상황을 나타냅니다 (예: OutOfMemoryError, StackOverflowError).
일반적으로 애플리케이션 코드에서 Error를 잡으려고 시도하지 않습니다.
<ul>
<li> 예외처리를 하는 세 방법에 대해 설명해 주세요.</li>
  Java에서는 try-catch-finally 블록과 throws 키워드를 사용하여 예외를 처리합니다.

try-catch 블록:

예외가 발생할 가능성이 있는 코드를 try 블록 안에 작성합니다.
try 블록 안에서 예외가 발생하면, 해당 예외 타입과 일치하는 catch 블록이 실행됩니다.
하나의 try 블록 뒤에는 여러 개의 catch 블록이 올 수 있으며, 각 catch 블록은 특정 타입의 예외를 처리합니다.
catch 블록에서는 발생한 예외에 대한 적절한 처리 (예: 오류 메시지 출력, 로깅, 예외 복구 시도 등)를 수행합니다.

finally 블록:

try 블록 뒤에 선택적으로 사용할 수 있는 finally 블록은 try 블록 안에서 예외가 발생하든 발생하지 않든, 항상 실행되는 코드 블록입니다.
주로 사용했던 자원 (예: 파일 스트림, 데이터베이스 연결)을 닫는 등의 마무리 작업을 수행하는 데 사용됩니다.

throws 키워드:

메서드 선언부에서 throws 키워드를 사용하여 해당 메서드 내에서 발생할 수 있는 Checked Exception을 호출한 메서드로 던질 수 있습니다.
메서드를 호출하는 쪽에서는 해당 예외를 try-catch 블록으로 처리하거나, 다시 throws 키워드를 사용하여 상위 호출 메서드로 던져야 합니다.
<li> CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.</li>
### CheckedException vs UncheckedException

| 구분                | CheckedException                                          | UncheckedException                                      |
|:-------------------|:--------------------------------------------------------|:--------------------------------------------------------|
| 정의                | 컴파일 타임에 반드시 처리해야 하는 예외                    | 실행 시간에 발생할 수 있는 예외, 처리하지 않아도 컴파일 오류가 발생하지 않음  |
| 상속 관계            | `Exception` 클래스를 상속하며, `RuntimeException`을 제외한 모든 예외 | `RuntimeException`을 상속한 예외                              |
| 처리 방법            | **강제 처리**: 예외가 발생할 가능성이 있는 코드를 작성할 때 `try-catch` 또는 `throws`로 처리해야 함  | **선택적 처리**: 처리할지 안 할지 개발자의 선택에 맡겨짐   |
| 예시                | `IOException`, `SQLException`, `FileNotFoundException`  | `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArithmeticException` |
| 발생 위치            | 주로 외부 시스템과의 인터페이스에서 발생 (파일 입출력, 데이터베이스 등) | 프로그램 내 논리적 오류나 잘못된 입력 등에서 발생         |
| 예외 처리            | 반드시 처리해야 하므로 코드가 길어질 수 있음                | 예외 처리를 하지 않아도 컴파일이 가능하지만, 프로그램에서 예기치 않은 동작이 발생할 수 있음 |
| 사용 사례            | 외부 자원과의 연동에서 발생할 수 있는 예외 처리 필요          | 개발 중에 발생할 수 있는 논리적 오류나 프로그래밍 실수에 대한 처리 |

<li> 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?</li>
3. 결론
예외 처리의 성능 영향:
예외를 자주 발생시키면 성능에 큰 부하가 될 수 있습니다.

예외 처리 자체가 부담이 되는 이유는 예외 객체 생성, 스택 트레이스 기록, 제어 흐름 변경 등의 과정 때문입니다.

성능 부하를 줄이는 방법:
예외를 자주 발생시키는 흐름을 피하고, 예외를 예외적인 상황에서만 사용.

예외를 던지지 않고 오류 코드나 반환 값을 사용하는 방식으로 처리.

예외 발생 가능성을 미리 체크하고, 예외가 발생하지 않도록 로직 개선.

결국, 예외 처리의 목적은 "예외적인 상황에 대한 대응"이어야 하며, 일상적인 흐름 제어의 일부로 예외를 사용하는 것은 피해야 합니다.


</ul>
</details>

<details>
  <summary><h3>7. Synchronized 키워드에 대해 설명해 주세요.</h3></summary>
  synchronized는 자바에서 멀티 스레드 환경에서 공유 자원에 대한 접근을 제어하고 스레드 간의 동기화를 보장하는 데 사용되는 키워드입니다. 쉽게 말해, 여러 스레드가 동시에 특정 자원을 건드려서 문제가 생기는 것을 막아주는 역할을 합니다.
<ul>
<li> Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.</li>
  1. 인스턴스 메서드

의미: 해당 메서드 전체가 **임계 영역(critical section)**이 됩니다.

동작 방식:
- 스레드가 메서드를 호출하려고 하면, 해당 메서드가 속한 **객체(instance)의 락(monitor lock 또는 intrinsic lock)**을 획득하려고 시도합니다.
- 락을 획득한 스레드만이 메서드의 실행을 시작할 수 있습니다.
- 다른 스레드가 같은 객체의 다른 synchronized 인스턴스 메서드를 호출하려고 하면, 첫 번째 스레드가 락을 해제할 때까지 **블로킹(waiting)**됩니다.

중요: 서로 다른 객체의 synchronized 인스턴스 메서드는 동시에 실행될 수 있습니다. 락은 객체 단위로 관리되기 때문입니다.
  
  2.정적 메서드

  의미: 해당 정적 메서드 전체가 클래스 레벨의 임계 영역이 됩니다.
  
동작 방식:
- 스레드가 메서드를 호출하려고 하면, 해당 메서드가 속한 클래스 객체(Class object)의 락을 획득하려고 시도합니다.
- 클래스 객체는 JVM 내에 클래스당 하나만 존재하는 특별한 객체입니다.
- 락을 획득한 스레드만이 메서드의 실행을 시작할 수 있습니다.
- 다른 스레드가 같은 클래스의 다른 synchronized static 메서드를 호출하려고 하면, 첫 번째 스레드가 락을 해제할 때까지 블로킹됩니다.

중요: synchronized static 메서드와 해당 클래스의 synchronized 인스턴스 메서드는 서로 다른 락을 사용하므로 동시에 실행될 수 있습니다. 정적 메서드는 클래스 락을, 인스턴스 메서드는 객체 락을 사용합니다.
    
  3. 코드 블록에 사용될 때의 의미


의미: synchronized 키워드 뒤에 오는 참조 변수(lockObject)가 가리키는 객체의 락을 획득하여 해당 코드 블록을 임계 영역으로 만듭니다.

동작 방식:

- 스레드가 synchronized (lockObject) 블록에 진입하려고 하면, lockObject가 가리키는 객체의 락을 획득하려고 시도합니다.
- 락을 획득한 스레드만이 이 블록 안의 코드를 실행할 수 있습니다.
- 다른 스레드가 같은 lockObject에 대해 synchronized 블록에 접근하려고 하면, 첫 번째 스레드가 락을 해제할 때까지 블로킹됩니다.
- lockObject는 어떤 객체든 될 수 있지만, 일반적으로 공유 자원을 보호하기 위한 목적으로 특별히 생성된 객체나 공유 자원 자체를 사용합니다.
  
<li> 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?</li>

synchronized는 멀티 스레드 환경에서 **안전성(thread safety)**을 보장하는 데 매우 중요한 역할을 하지만, 동시에 성능 저하를 유발할 수 있는 요소를 내포하고 있기 때문입니다.

synchronized의 장점 (안전성 측면):

간편한 동기화 구현: 공유 자원에 대한 동시 접근을 막는 기본적인 메커니즘을 제공하여 개발자가 복잡한 락 관리 로직을 직접 구현할 필요를 줄여줍니다.
데이터 무결성 보장: 여러 스레드가 동시에 공유 자원을 변경하는 상황에서 데이터의 일관성과 정확성을 유지하는 데 도움을 줍니다.
데드락 방지 (주의해서 사용해야 함): 올바르게 사용하면 레이스 컨디션과 같은 동시성 문제를 해결하여 데드락 발생 가능성을 줄일 수 있습니다. (하지만 잘못 사용하면 오히려 데드락의 원인이 될 수도 있습니다.)
synchronized의 단점 (효율성 측면):

성능 오버헤드: synchronized 블록 또는 메서드에 진입할 때 락을 획득하고, 빠져나올 때 락을 해제하는 과정에서 컨텍스트 스위칭과 같은 성능 오버헤드가 발생합니다. 특히 경쟁이 심한 환경에서는 이 오버헤드가 더욱 커질 수 있습니다.
블로킹: 하나의 스레드가 락을 획득하면 다른 스레드는 락이 해제될 때까지 블로킹되어 CPU 자원을 효율적으로 사용하지 못할 수 있습니다.
과도한 동기화: 불필요한 부분까지 synchronized로 처리하면 프로그램의 병렬성을 저해하고 전체적인 처리량을 감소시킬 수 있습니다.
효율적인 코드 작성을 위한 고려 사항:

정확한 동기화 범위 설정: 정말로 동시 접근이 문제가 되는 공유 자원에 대해서만 synchronized를 적용하고, 불필요한 동기화는 피해야 합니다. 코드 블록 동기화를 사용하여 필요한 최소한의 영역만 동기화하는 것이 좋습니다.
경쟁 정도 예측: 공유 자원에 대한 스레드 간의 경쟁 정도를 예측하고, 경쟁이 낮다면 synchronized 대신 다른 동시성 제어 메커니즘 (예: volatile, Atomic 변수 등)을 고려해 볼 수 있습니다.
고급 동시성 유틸리티 활용: java.util.concurrent 패키지에서 제공하는 Lock, ReadWriteLock, Semaphore, CountDownLatch, CyclicBarrier 등의 고급 동시성 유틸리티는 synchronized보다 더 세밀한 제어와 향상된 성능을 제공할 수 있습니다.
불변(Immutable) 객체 활용: 불변 객체는 생성 후 상태가 변하지 않으므로 스레드 안전하며, 동기화 없이 자유롭게 공유할 수 있어 성능 향상에 도움이 됩니다.
스레드 풀 관리: 스레드 생성 및 소멸 비용을 줄이고 작업 관리를 효율적으로 하기 위해 스레드 풀을 사용하는 것이 좋습니다.
결론:

synchronized는 멀티 스레드 프로그래밍에서 필수적인 도구이지만, 무분별하게 사용하면 성능 병목의 원인이 될 수 있습니다. 효율적인 코드를 작성하기 위해서는 synchronized의 장단점을 명확히 이해하고, 동기화가 필요한 최소한의 영역에만 신중하게 적용해야 합니다. 또한, 상황에 따라 더 나은 성능을 제공할 수 있는 다른 동시성 제어 메커니즘을 고려하는 것이 중요합니다.

핵심은 "필요한 곳에, 적절하게" 사용하는 것입니다. 안전성을 확보하면서도 성능 저하를 최소화하는 균형점을 찾는 것이 효율적인 멀티 스레드 프로그래밍의 핵심입니다.

<li> Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.</li>

1. java.util.concurrent.locks 패키지의 Lock 인터페이스 및 구현체:

Lock 인터페이스는 synchronized보다 더 명시적인 락 획득(lock()) 및 해제(unlock()) 기능을 제공합니다. 주요 구현체로는 ReentrantLock이 있습니다.

특징:
명시적인 락 획득 및 해제: lock() 메서드로 락을 획득하고, 반드시 finally 블록에서 unlock() 메서드를 호출하여 락을 해제해야 합니다. 이는 락이 제대로 해제되지 않아 발생할 수 있는 문제를 방지하는 데 중요합니다.
tryLock() 메서드: 락을 즉시 획득하거나, 지정된 시간 동안만 기다려보고 획득하지 못하면 실패하는 tryLock() 메서드를 제공합니다. 이를 통해 스레드가 무한정 대기하는 것을 방지할 수 있습니다.
인터럽트 가능한 락: 락을 획득하기 위해 대기 중인 스레드를 interrupt() 메서드를 통해 깨울 수 있습니다.
공정한 락: 락을 획득하려는 스레드들의 순서를 보장하는 공정한(fair) 락을 구현할 수 있습니다 (기본적으로는 비공정 락입니다).
조건(Condition) 객체: Lock 인터페이스는 Condition 객체를 제공하여 synchronized의 wait(), notify(), notifyAll()과 유사한 대기/알림 메커니즘을 더 유연하게 사용할 수 있도록 합니다. 여러 개의 조건 변수를 가질 수 있습니다.
2. java.util.concurrent.locks.ReadWriteLock 인터페이스 및 구현체 (ReentrantReadWriteLock):

읽기 작업과 쓰기 작업을 분리하여 성능을 향상시키는 락입니다. 여러 스레드가 동시에 읽기 락을 획득할 수 있지만, 쓰기 락은 오직 하나의 스레드만 획득할 수 있으며, 쓰기 락이 획득되면 다른 모든 읽기 및 쓰기 락 요청은 블로킹됩니다.

특징:
읽기 락 (Shared Lock): 여러 스레드가 동시에 획득 가능하므로 읽기 작업 위주의 환경에서 높은 병렬성을 제공합니다.
쓰기 락 (Exclusive Lock): 오직 하나의 스레드만 획득 가능하며, 다른 모든 락 요청을 블로킹하여 데이터의 일관성을 보장합니다.
락 다운그레이드: 쓰기 락을 획득한 스레드가 읽기 락으로 안전하게 전환할 수 있습니다.
3. java.util.concurrent.atomic 패키지의 Atomic 변수:

기본 데이터 타입(int, long, boolean, 객체 참조 등)에 대한 원자적인 연산을 제공하는 클래스들입니다. CAS (Compare-and-Swap) 메커니즘을 기반으로 락 없이 스레드 안전성을 보장하여 synchronized보다 훨씬 낮은 오버헤드를 가집니다.

주요 클래스: AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference, AtomicIntegerArray 등.
특징:
락 프리(Lock-Free): 명시적인 락을 사용하지 않아 락 경쟁으로 인한 성능 저하를 피할 수 있습니다.
높은 성능: CAS 연산은 일반적으로 락 획득 및 해제보다 훨씬 빠릅니다.
단순한 연산에 적합: 주로 카운터 증가/감소, 플래그 설정 등 간단한 연산의 동기화에 유용합니다. 복잡한 여러 단계의 연산에는 적합하지 않을 수 있습니다.
4. java.util.concurrent 패키지의 동시성 유틸리티:

이 패키지는 스레드 간의 협업 및 상태 관리를 위한 다양한 유틸리티 클래스를 제공하며, 때로는 synchronized를 대체하거나 보완하여 더 효율적인 동시성 프로그래밍을 가능하게 합니다.

Executor Framework (Executor, ExecutorService, ThreadPoolExecutor 등): 스레드 생성 및 관리를 추상화하여 개발자가 직접 스레드를 다루는 부담을 줄이고, 스레드 풀을 활용하여 성능을 향상시킵니다.
컬렉션 (ConcurrentHashMap, ConcurrentLinkedQueue, CopyOnWriteArrayList 등): 스레드 안전한 컬렉션 구현체를 제공하여 외부 동기화 없이 멀티 스레드 환경에서 안전하게 사용할 수 있습니다. 내부적으로 락 스트라이핑, CAS 등의 기법을 사용하여 높은 동시성을 제공합니다.
동기화 유틸리티 (Semaphore, CountDownLatch, CyclicBarrier, Phaser): 특정 조건이 충족될 때까지 스레드를 대기시키거나, 여러 스레드의 작업을 동기화하는 데 사용됩니다.
선택 기준:

어떤 동기화 기법을 선택할지는 애플리케이션의 요구 사항, 공유 자원의 접근 패턴 (읽기 위주 vs 쓰기 위주), 경쟁 정도, 그리고 필요한 유연성에 따라 달라집니다.

단순한 동기화 및 낮은 경쟁: synchronized가 여전히 간단하고 효과적인 선택일 수 있습니다.
명시적인 락 제어, 타임아웃, 인터럽트: Lock 인터페이스 및 구현체를 사용합니다.
읽기 작업 위주의 높은 동시성: ReadWriteLock을 고려합니다.
간단한 원자적 연산 및 높은 성능: Atomic 변수를 사용합니다.
스레드 관리 및 협업: java.util.concurrent 패키지의 다양한 유틸리티를 활용합니다.

** 추가 질문 ** 위와 같은 다른 동기화 방법이 Synchronized 방식보다 효율적이라고 생각하시나요, 그렇다면 그 이유는?
<li> Thread Local에 대해 설명해 주세요.</li>
ThreadLocal은 자바에서 각 스레드가 자신만의 독립적인 변수 복사본을 가질 수 있도록 하는 메커니즘입니다. 마치 각 스레드에게 개인적인 보관함을 제공하여 데이터를 안전하게 관리할 수 있도록 해주는 것과 같습니다.

ThreadLocal의 핵심 개념:

스레드 격리(Thread Isolation): ThreadLocal을 통해 생성된 변수는 각 스레드마다 별도의 값을 가지게 됩니다. 한 스레드에서 ThreadLocal 변수의 값을 변경해도 다른 스레드에는 영향을 주지 않습니다.
스레드 로컬 저장소(Thread-Local Storage): 각 스레드는 자신만의 로컬 저장소를 가지고 있으며, ThreadLocal 변수와 그에 해당하는 값을 이 저장소에 저장하고 관리합니다.

ThreadLocal의 장점:

스레드 안전성: 공유 변수에 대한 명시적인 동기화 없이 각 스레드가 자신만의 데이터를 안전하게 사용할 수 있습니다.
편의성: 데이터를 스레드 간에 파라미터로 계속 전달할 필요 없이, 필요한 곳에서 ThreadLocal을 통해 접근할 수 있어 코드의 가독성을 높일 수 있습니다.
ThreadLocal의 단점 및 주의사항:

메모리 누수 가능성: 스레드 풀 환경에서 스레드가 재사용될 때, ThreadLocal에 저장된 값이 명시적으로 제거되지 않으면 스레드 로컬 저장소에 계속 남아있어 메모리 누수를 유발할 수 있습니다. 따라서 사용이 끝난 ThreadLocal 변수는 반드시 remove() 메서드를 호출하여 제거해야 합니다.
과도한 사용: 전역 변수처럼 남용될 경우 코드의 흐름을 파악하기 어렵게 만들고, 스레드 간의 의존성을 숨길 수 있어 유지보수를 어렵게 할 수 있습니다. 정말로 스레드 격리가 필요한 경우에만 신중하게 사용해야 합니다.
초기화의 어려움: initialValue() 메서드를 통해 초기값을 설정할 수 있지만, 복잡한 초기화 로직이 필요한 경우 주의해야 합니다.
요약:

ThreadLocal은 각 스레드가 독립적인 데이터를 관리할 수 있도록 하는 강력한 메커니즘입니다. 스레드 안전성을 확보하고 코드의 편의성을 높이는 데 유용하지만, 메모리 누수 가능성과 과도한 사용에 대한 주의가 필요합니다. 스레드 풀 환경에서는 특히 remove() 메서드를 통한 자원 관리에 신경 써야 합니다.
</ul>
</details>

<details>
  <summary><h3>8. Java Stream에 대해 설명해 주세요.</h3></summary>

  Java Stream의 핵심 개념:

스트림(Stream): 데이터 원본(컬렉션, 배열, I/O 채널 등)에서 생성된 데이터의 흐름입니다. 스트림 자체는 데이터를 저장하지 않으며, 단지 파이프라인을 통해 데이터를 전달하고 처리하는 역할을 합니다.

파이프라인(Pipeline): 스트림을 통해 데이터를 처리하는 일련의 연산(operations) 단계입니다. 파이프라인은 **중간 연산(intermediate operations)**과 **최종 연산(terminal operation)**으로 구성됩니다.

중간 연산: 스트림을 변환하거나 필터링하는 연산입니다. 중간 연산의 결과는 또 다른 스트림이므로 여러 중간 연산을 연결하여 파이프라인을 구성할 수 있습니다. (예: filter, map, sorted)

최종 연산: 스트림 파이프라인의 결과를 생성하거나 소비하는 연산입니다. 최종 연산이 호출되면 파이프라인이 실행되고 결과가 만들어집니다. (예: forEach, collect, reduce, count)

선언형 프로그래밍: "어떻게(how)" 데이터를 처리할 것인지 명시하는 대신, "무엇(what)"을 원하는지 선언하는 방식입니다. 스트림 API는 개발자가 원하는 결과를 간결하고 가독성 높게 표현할 수 있도록 지원합니다.

Java Stream의 특징:

지연 연산(Lazy Evaluation): 중간 연산은 최종 연산이 호출될 때까지 실행되지 않습니다. 이는 불필요한 연산을 줄여 성능을 향상시킬 수 있습니다.
내부 반복(Internal Iteration): 컬렉션의 요소를 순회하는 방식을 개발자가 직접 제어하는 외부 반복(external iteration, for-each 루프 등)과 달리, 스트림 API는 내부적으로 요소를 순회하며 연산을 수행합니다. 이를 통해 병렬 처리를 더 쉽게 구현할 수 있습니다.
함수형 프로그래밍 지원: 람다 표현식(lambda expressions)과 함수형 인터페이스(functional interfaces)를 활용하여 코드를 간결하고 유연하게 작성할 수 있습니다.
병렬 처리 용이성: parallelStream() 메서드를 통해 스트림을 병렬 스트림으로 쉽게 변환하여 여러 스레드에서 데이터를 병렬로 처리할 수 있습니다. 이는 대규모 데이터 처리 작업의 성능을 크게 향상시킬 수 있습니다.
재사용 불가: 스트림은 한 번 최종 연산을 수행하면 더 이상 사용할 수 없습니다. 다시 데이터를 처리하려면 새로운 스트림을 생성해야 합니다.


** 추가 질문 ** Javacript에서의 Stream 

JavaScript에서 Stream과 관련된 주요 개념은 다음과 같습니다.

1. Observable (RxJS):

비동기 데이터 스트림: Reactive Extensions for JavaScript (RxJS)는 Observable이라는 핵심 개념을 제공합니다. Observable은 시간이 지남에 따라 방출되는 값의 시퀀스를 나타냅니다. 이는 비동기 이벤트, API 응답, 사용자 입력 등 다양한 종류의 데이터를 모델링하는 데 사용됩니다.
함수형 반응형 프로그래밍 (FRP): RxJS는 함수형 프로그래밍과 반응형 프로그래밍 패러다임을 기반으로 비동기 및 이벤트 기반 코드를 효과적으로 관리하고 구성할 수 있도록 해줍니다.
연산자: RxJS는 map, filter, reduce, merge, concat 등 Java Stream API와 유사한 다양한 연산자를 제공하여 Observable에서 방출되는 데이터를 변환, 필터링, 결합하고 처리할 수 있습니다.
Lazy Evaluation: Observable도 기본적으로는 구독(subscribe)될 때까지 아무런 동작을 수행하지 않는 지연 평가(lazy evaluation) 방식을 따릅니다.
예시 (RxJS):

JavaScript

import { fromEvent, interval } from 'rxjs';
import { map, filter, take } from 'rxjs/operators';

// DOM 이벤트에서 Observable 생성
const click$ = fromEvent(document, 'click');

// 간격으로 값을 방출하는 Observable 생성
const timer$ = interval(1000);

// 클릭 이벤트의 좌표 매핑
const clickCoords$ = click$.pipe(map(event => ({ x: event.clientX, y: event.clientY })));

// 특정 조건 필터링
const filteredTimer$ = timer$.pipe(filter(value => value % 2 === 0), take(5));

// 구독하여 데이터 처리
clickCoords$.subscribe(coords => console.log('클릭 좌표:', coords));
filteredTimer$.subscribe(value => console.log('짝수 타이머 값:', value));
2. Async Iterable & Async Iterator (ES2018):

비동기 데이터 순회: ECMAScript 2018 (ES9)에 도입된 Async Iterable과 Async Iterator는 비동기적으로 생성되는 데이터 시퀀스를 순회하기 위한 메커니즘을 제공합니다. 이는 비동기 제너레이터 함수(async function*)를 통해 생성할 수 있습니다.
for await...of 루프: Async Iterable은 for await...of 루프를 사용하여 비동기적으로 값을 순회할 수 있습니다.
예시 (Async Iterable):

JavaScript

async function* generateAsyncNumbers() {
  for (let i = 1; i <= 5; i++) {
    await new Promise(resolve => setTimeout(resolve, 500));
    yield i;
  }
}

async function processAsyncNumbers() {
  for await (const number of generateAsyncNumbers()) {
    console.log('비동기 숫자:', number);
  }
}

processAsyncNumbers();
Java Stream과의 차이점:

주요 대상: Java Stream은 주로 동기적인 컬렉션 데이터를 처리하는 데 초점을 맞추는 반면, JavaScript의 Observable (RxJS)는 비동기 이벤트 및 데이터 스트림을 다루는 데 강력합니다. Async Iterable/Iterator는 비동기 데이터 순회에 특화되어 있습니다.
내장 vs 라이브러리: Java Stream은 언어의 핵심 기능으로 내장되어 있지만, JavaScript에서 강력한 스트림 처리 기능을 사용하려면 RxJS와 같은 외부 라이브러리를 사용하는 경우가 많습니다. Async Iterable/Iterator는 ES 표준에 포함된 비교적 새로운 기능입니다.
병렬 처리: Java Stream은 parallelStream()을 통해 간편하게 병렬 처리를 지원하지만, JavaScript에서는 웹 워커(Web Workers)와 같은 별도의 메커니즘을 사용하여 병렬 처리를 구현해야 하며, 스트림 API 자체에서 직접적인 병렬 처리 지원은 제한적입니다.
결론:

JavaScript에도 데이터 스트림을 처리하는 개념이 존재하지만, Java의 Stream API와는 그 목적과 사용 방식에 차이가 있습니다. RxJS의 Observable은 비동기 데이터 스트림 처리에 강력한 도구를 제공하며, Async Iterable/Iterator는 비동기 데이터 순회를 위한 새로운 표준입니다. JavaScript에서 스트림과 유사한 방식으로 데이터를 처리하려면 이러한 개념과 관련 라이브러리를 이해하는 것이 중요합니다.
<ul>
<li> Stream과 for ~ loop의 성능 차이를 비교해 주세요,</li>

  작은 데이터셋: for 루프는 일반적으로 스트림 API의 초기화 오버헤드가 없어 약간 더 빠를 수 있습니다.
큰 데이터셋 및 병렬 처리: 스트림 API는 parallelStream()을 통해 쉽게 병렬 처리를 구현할 수 있어, 멀티코어 환경에서 for 루프보다 훨씬 뛰어난 성능을 보일 수 있습니다. 하지만 병렬 스트림은 스레드 관리 및 데이터 병합 등의 오버헤드가 있어, 작업의 특성과 데이터 크기에 따라 오히려 직렬 스트림보다 느릴 수도 있습니다.
중간 연산: 스트림의 중간 연산은 지연(lazy) 평가되므로, 최종 연산에 필요한 데이터만 처리하여 불필요한 연산을 줄일 수 있습니다. 하지만 체이닝된 많은 중간 연산은 오버헤드를 발생시킬 수 있습니다.
최종 연산: 최종 연산의 종류에 따라 성능이 달라질 수 있습니다. 예를 들어, 간단한 forEach는 for 루프와 비슷할 수 있지만, collect나 reduce와 같은 연산은 스트림 API의 특징을 활용하여 더 효율적일 수 있습니다.
가독성 및 유지보수성:

스트림 API는 선언형 프로그래밍 스타일을 지향하여, 데이터 처리 로직을 간결하고 명확하게 표현할 수 있어 가독성이 좋습니다.
for 루프는 명령형 방식으로 "어떻게" 처리할지를 명시하므로, 복잡한 로직에서는 가독성이 떨어질 수 있습니다.
결론:

단순한 작업 및 작은 데이터셋: for 루프가 약간의 성능 우위를 가질 수 있습니다.
복잡한 데이터 처리, 큰 데이터셋, 병렬 처리 가능성: 스트림 API가 더 나은 성능과 가독성을 제공할 수 있습니다.

<li> Stream은 병렬처리 할 수 있나요?</li>

할수 있다.

병렬 스트림의 장점:

향상된 성능: 멀티코어 환경에서 대량의 데이터를 처리할 때 처리 시간을 크게 단축할 수 있습니다.
간편한 구현: parallelStream() 메서드 호출 한 번으로 병렬 처리를 적용할 수 있어 개발 편의성이 높습니다.

네 
<li> Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.</li>

Java Stream API는 람다 표현식과 함께 사용되어 강력한 데이터 처리 기능을 제공합니다. 
람다 표현식은 **함수형 인터페이스(Functional Interface)**의 추상 메서드를 구현하는 데 사용됩니다. Stream API에서 자주 사용되는 주요 함수형 인터페이스들은 다음과 같습니다.


1. Predicate<T>:

추상 메서드: boolean test(T t)

역할: 주어진 객체 t가 특정 조건을 만족하는지 여부를 평가하여 true 또는 false를 반환합니다.

Stream API 사용 예시: filter(Predicate<T> predicate)

```JAVA
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream().filter(n -> n % 2 == 0).forEach(System.out::println); // 짝수만 출력
```

2. Function<T, R>:

추상 메서드: R apply(T t)

역할: 주어진 객체 t를 다른 타입 R의 객체로 변환하는 함수를 나타냅니다.

Stream API 사용 예시: map(Function<T, R> mapper)

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.stream().map(String::length).forEach(System.out::println); // 각 이름의 길이 출력

```

3. Consumer<T>:

추상 메서드: void accept(T t)

역할: 주어진 객체 t에 대해 특정 작업을 수행합니다. 반환 값은 없습니다.

Stream API 사용 예시: forEach(Consumer<T> action), peek(Consumer<T> action)

```java
List<String> greetings = Arrays.asList("Hello", "World");
greetings.stream().forEach(s -> System.out.println(s + "!")); // 각 문자열에 "!"를 붙여 출력

```

4. Supplier<T>:

추상 메서드: T get()

역할: 특정 타입 T의 객체를 제공(생성)하는 함수를 나타냅니다.

Stream API 사용 예시: Stream.generate(Supplier<T> supplier

```java
Stream.generate(Math::random).limit(5).forEach(System.out::println); // 5개의 랜덤 실수 출력
```


<li> 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?</li>

1. 캡처된 변수의 불변성 보장 (사실상 final):

람다 표현식이나 익명 클래스는 자신이 정의된 스코프의 변수를 **캡처(capture)**할 수 있습니다.
Java 8 이전에는 람다/익명 클래스에서 외부 변수를 사용하려면 그 변수가 반드시 final로 선언되어 있어야 했습니다.
Java 8부터는 effectively final이라는 개념이 도입되어, 명시적으로 final로 선언되지 않았더라도 람다/익명 클래스 내에서 값이 변경되지 않는 변수는 암묵적으로 final처럼 취급되어 사용할 수 있습니다. 이를 "effectively final"이라고 합니다.
2. 스레드 안전성:

람다/익명 클래스가 여러 스레드에서 동시에 실행될 수 있는 경우 (예: 병렬 스트림 처리), 캡처된 변수가 변경 가능하다면 스레드 안전성 문제가 발생할 수 있습니다.
final 또는 effectively final 변수는 값이 한 번 할당된 후에는 변경되지 않으므로, 여러 스레드가 동시에 접근해도 데이터 불일치 문제가 발생하지 않습니다.
3. 의도 명확성 및 코드 이해도 향상:

외부 변수에 final 키워드를 명시적으로 붙이면, 해당 변수가 람다/익명 클래스 내에서 값이 변경되지 않고 읽기 전용으로 사용될 것이라는 의도를 명확하게 드러냅니다. 이는 코드의 가독성과 유지보수성을 높이는 데 도움이 됩니다.
개발자가 실수로 람다/익명 클래스 내에서 외부 변수의 값을 변경하려고 하면 컴파일러 에러가 발생하여 잠재적인 버그를 미리 방지할 수 있습니다.
꼭 그래야 할까요?

Java 8 이후: 변수가 effectively final이라면 명시적으로 final을 붙이지 않아도 람다/익명 클래스 내에서 사용할 수 있습니다. 따라서 필수는 아닙니다.
하지만, final을 붙이는 것을 권장합니다. 이는 코드의 안정성, 가독성, 그리고 의도 명확성을 높이는 데 도움이 되기 때문입니다. 특히 병렬 처리 환경에서는 스레드 안전성을 보장하는 중요한 습관입니다.
결론적으로, final 키워드를 붙이는 것은 문법적으로 필수는 아니지만, 코드의 품질을 높이고 잠재적인 문제를 예방하는 좋은 습관입니다. 외부 변수가 람다/익명 클래스 내에서 변경되지 않을 것이라면 명시적으로 final을 붙여주는 것을 고려해 보세요.
</ul>
</details>

<details>
  <summary><h3>9. Java의 GC에 대해 설명해 주세요.</h3></summary>
  
  - GC가 필요한 이유 
  프로그램이 실행되려면 메모리 공간이 필요해요. 객체를 생성하고 데이터를 저장하는 데 사용되죠. 그런데 프로그램이 계속 실행되다 보면 더 이상 필요 없는 객체들이 메모리에 계속 남아있게 돼요. 이걸 그대로 두면 메모리가 부족해져서 결국 프로그램이 멈추거나 아주 느려지게 됩니다. 마치 오랫동안 청소하지 않은 집처럼 엉망진창이 되는 거죠. GC는 이런 상황을 막기 위해 자동으로 메모리를 관리해주는 역할을 합니다.

 - GC 동작 방법
   
Mark and Sweep (표시하고 쓸어버리기):

Mark (표시): GC는 살아있는(reachable) 객체들을 찾아 표시합니다. '루트(root)'라고 불리는 특별한 객체들(예: 현재 실행 중인 스택의 변수, 정적 변수 등)부터 시작해서 참조를 따라 도달할 수 있는 모든 객체를 표시하는 거죠.
Sweep (쓸어버리기): 표시되지 않은 객체들은 더 이상 사용되지 않는다고 판단하고 메모리에서 제거합니다. 마치 청소기가 먼지를 흡입하는 것처럼요.
Generational Garbage Collection (세대별 쓰레기 수집): 대부분의 객체는 금방 생성되었다가 금방 사라지는 '젊은 객체'라는 특징을 활용하는 방식입니다. 그래서 Java의 힙(Heap) 메모리 영역을 여러 세대로 나누어 관리합니다.

Young Generation (Young Gen, Young Space): 새롭게 생성된 객체들이 주로 위치하는 영역입니다. Minor GC라는 비교적 짧고 자주 발생하는 GC가 이 영역에서 수행됩니다. Young Generation은 Eden, Survivor0 (S0), Survivor1 (S1)이라는 작은 공간으로 더 나뉩니다.
새로운 객체는 주로 Eden 영역에 생성됩니다.
Eden 영역이 꽉 차면 Minor GC가 발생하여 살아남은 객체들은 Survivor 영역 중 하나로 이동합니다.
Minor GC가 반복되면서 살아남은 객체들은 다른 Survivor 영역으로 이동하고, 일정 횟수 이상 살아남은 객체는 Old Generation으로 이동합니다.
Old Generation (Old Gen, Old Space): 오랫동안 살아남은 객체들이 위치하는 영역입니다. Major GC 또는 Full GC라고 불리는 더 길고 드물게 발생하는 GC가 이 영역에서 수행됩니다. Young Generation에 비해 GC 빈도가 낮습니다.
Permanent Generation (Perm Gen) 또는 Metaspace: 클래스 메타데이터, 메소드 정보, 상수 풀, 정적 변수 등이 저장되는 영역입니다. Java 8부터는 Perm Gen이 없어지고 Metaspace라는 새로운 구조로 바뀌었습니다. Metaspace는 Heap 영역이 아닌 Native Memory 영역을 사용하며, 필요에 따라 동적으로 크기가 늘어날 수 있습니다. 

주요 GC 알고리즘:

Java에는 여러 가지 GC 알고리즘이 있으며, JVM 설정에 따라 선택해서 사용할 수 있습니다. 주요 알고리즘들은 다음과 같습니다.

Serial GC: 싱글 스레드로 GC를 수행합니다. 단순하지만, GC가 수행되는 동안 애플리케이션 스레드가 모두 멈추기 때문에(Stop-The-World) 대규모 애플리케이션에서는 성능 병목을 일으킬 수 있습니다.
Parallel GC: Young Generation의 Minor GC를 멀티 스레드로 병렬 처리하여 Serial GC보다 빠릅니다. Old Generation GC는 여전히 싱글 스레드로 수행될 수 있습니다.
CMS (Concurrent Mark Sweep) GC: Old Generation GC를 수행하는 동안 애플리케이션 스레드의 일부만 멈추고 나머지는 계속 실행될 수 있도록 설계되었습니다. Stop-The-World 시간을 줄이는 데 초점을 맞춥니다. 하지만 다른 GC 방식에 비해 CPU를 더 많이 사용할 수 있고, 메모리 단편화 문제가 발생할 수 있습니다. Java 9에서 deprecated 되었습니다.
G1 (Garbage-First) GC: 전체 Heap 영역을 작은 Region으로 나누어 GC를 수행합니다. Stop-The-World 시간을 줄이면서 높은 처리량을 목표로 합니다. 예측 가능한 GC 일시 중지 시간을 제공하며, Java 9부터 기본 GC로 채택되었습니다.
ZGC (Z Garbage Collector): 낮은 지연 시간(low latency)에 초점을 맞춘 GC입니다. 매우 큰 Heap 메모리 환경에서도 Stop-The-World 시간을 매우 짧게 유지하는 것을 목표로 합니다. Java 11에 처음 도입되었습니다.
Shenandoah GC: ZGC와 마찬가지로 낮은 지연 시간을 목표로 하는 GC입니다. 객체를 이동시키는 작업을 애플리케이션 스레드와 동시에 수행하여 Stop-The-World 시간을 최소화합니다. Java 11에 처음 도입되었습니다.
GC 튜닝:

GC는 대부분 자동으로 잘 작동하지만, 애플리케이션의 특성에 따라 GC 관련 설정을 튜닝하여 성능을 최적화할 수 있습니다. 예를 들어, Heap 사이즈 조절, GC 알고리즘 선택, Young/Old Generation 비율 조정 등이 있습니다. 하지만 GC 튜닝은 복잡하고 신중하게 접근해야 합니다.

핵심 요약:

GC는 Java에서 더 이상 사용하지 않는 메모리를 자동으로 회수하는 기능입니다.
메모리 누수를 방지하고 프로그램의 안정적인 실행을 돕습니다.
Mark and Sweep, Generational GC 등의 방식으로 작동합니다.
다양한 GC 알고리즘이 있으며, JVM 설정을 통해 선택할 수 있습니다.
애플리케이션의 특성에 따라 GC 튜닝을 고려할 수 있습니다.


<ul>
<li> finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?</li>

finalize() 메소드는 JVM에 의해 자동으로 호출되도록 설계된 콜백 함수이다. finalize()는 예측 불가능한 실행 시점, 성능저하, 객체부활, 경쟁조건 등의 문제를 발생시킬 수 있다. 그래서 만약 자원 해제와 같은 정리 작업은 명시적인 방법을 사용하는 
것이 훨씬 안전하고 예측 가능하며 성능에도 좋습니다. 따라서 finalize()를 수동으로 호출하는 것은 피해야 합니다.

<li> 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?</li>

네, 어떤 변수의 값이 null이 되었다면, 그 변수가 마지막으로 해당 객체를 참조하고 있었다면 해당 객체는 GC(Garbage Collection)의 대상이 될 가능성이 매우 높습니다.

좀 더 자세히 설명해 드릴게요.

GC의 조건: Reachability (도달 가능성)

Java의 GC는 **도달 가능성(Reachability)**이라는 개념을 기반으로 작동합니다. GC는 프로그램의 실행 흐름상에서 어떤 경로로든 접근할 수 있는 객체를 살아있는 객체로 간주하고, 그 외의 객체는 더 이상 필요 없는 쓰레기(garbage)로 판단하여 회수합니다.

변수가 null이 되는 것과 GC의 관계:

1. 변수가 유일한 참조였다면: 만약 특정 객체를 참조하는 변수가 딱 하나였고, 그 변수에 null이 할당되면 해당 객체로의 모든 접근 경로가 끊어집니다. 이는 GC 루트(예: 스택 변수, 정적 변수)로부터 더 이상 해당 객체로 도달할 수 없게 된다는 의미입니다. 따라서 이 객체는 unreachable 상태가 되어 GC의 대상이 될 가능성이 매우 높아집니다.

2. 다른 변수가 여전히 참조하고 있다면: 만약 해당 객체를 참조하는 다른 변수가 여전히 존재한다면, 하나의 변수가 null이 되더라도 객체는 여전히 reachable 상태입니다. 따라서 이 경우 해당 객체는 GC의 대상이 되지 않습니다.

GC 발생 시점:

변수가 null이 되었다고 해서 객체가 즉시 GC되는 것은 아닙니다. GC는 JVM의 필요에 따라, 특정 조건이 충족되었을 때 (예: 메모리 부족) 실행됩니다. 따라서 변수가 null이 된 객체는 GC가 실행되는 시점에 메모리에서 회수될 가능성이 높아지는 것입니다.

Finalization의 가능성:

만약 해당 객체에 finalize() 메소드가 정의되어 있다면, GC 대상이 된 후 GC 과정에서 finalize() 메소드가 한 번 호출될 수 있습니다. 하지만 앞서 설명드린 것처럼 finalize() 메소드의 사용은 권장되지 않으며, 예측 가능성이 낮습니다.

결론적으로, 변수의 값이 null이 되는 것은 해당 변수가 마지막 남은 참조였다면 객체가 unreachable 상태가 되어 GC의 대상이 될 가능성을 크게 높이는 행위입니다. 하지만 다른 유효한 참조가 남아있다면 GC되지 않으며, 실제로 GC가 언제 실행될지는 JVM의 결정에 따릅니다.

</ul>
</details>

<details>
  <summary><h3>10. equals()와 hashcode()에 대해 설명해 주세요.</h3></summary>
  equals()와 hashCode()는 Java에서 객체의 동등성을 비교하고 컬렉션(특히 Hash 기반 컬렉션)을 효율적으로 관리하는 데 매우 중요한 역할을 하는 메소드입니다. Object 클래스에 정의되어 있으며, 필요에 따라 하위 클래스에서 재정의(overriding)하여 객체의 논리적 동등성을 정의할 수 있습니다.
<ul>
<li> 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?</li>
<li> 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>11. IoC와 DI에 대해 설명해 주세요.</h3></summary>
  IoC (Inversion of Control, 제어의 역전)
**IoC(제어의 역전)**는 프로그램의 제어 흐름에 대한 권한을 개발자가 아닌 외부의 프레임워크나 컨테이너에게 넘기는 디자인 원칙입니다. 전통적인 프로그래밍 방식에서는 개발자가 직접 객체를 생성하고, 객체 간의 의존성을 관리하며, 프로그램의 실행 흐름을 제어합니다. 하지만 IoC가 적용되면 이러한 제어권이 프레임워크나 컨테이너로 넘어가고, 개발자는 필요한 로직을 구현하는 데만 집중할 수 있게 됩니다.

  DI (Dependency Injection, 의존성 주입)
**DI(의존성 주입)**는 IoC를 구현하는 하나의 디자인 패턴으로, 객체가 필요로 하는 의존성(다른 객체)을 직접 생성하는 대신 외부로부터 주입받는 방식입니다. 객체는 자신의 역할을 수행하는 데 필요한 다른 객체에 대한 정보를 가지고만 있고, 실제로 그 객체를 어떻게 얻는지, 누가 생성하는지는 알 필요가 없습니다.

DI의 목표:

객체 간의 결합도를 낮춥니다.
코드의 재사용성과 유지보수성을 높입니다.
단위 테스트를 용이하게 합니다.
<ul>
<li> 후보 없이 특정 기능을 하는 클래스가 딱 한 개하면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?</li>
<li> Spring의 Bean 생성 주기에 대해 설명해 주세요.</li>
<li> 프로토타입 빈은 무엇인가요?</li>
</ul>
</details>

<details>
  <summary><h3>12. AOP에 대해 설명해 주세요.</h3></summary>
<ul>
<li> @Aspect는 어떻게 동작하나요?</li>
</ul>
</details>

<details>
  <summary><h3>13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?</li>
</ul>
</details>

<details>
  <summary><h3>14. DispatcherServlet 의 역할에 대해 설명해 주세요.</h3></summary>
<ul>
<li>여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?</li>
<li>수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?</li>
</ul>
</details>

<details>
  <summary><h3>15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?</h3></summary>
<ul>
<li> 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?</li>
<li> N + 1 문제에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>16. @Transactional 은 어떤 기능을 하나요?</h3></summary>
<ul>
<li> @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?</li>
<li> 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?</li>
</ul>
</details>


<details>
  <summary><h3>17. Java 에서 Annotation 은 어떤 기능을 하나요?</h3></summary>
<ul>
<li> 별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?</li>
<li> Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?</li>
</ul>
</details>

<details>
  <summary><h3>18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?</h3></summary>
<ul>
<li> 혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?</li>
</ul>
</details>
