## Java, Spring

<details>
  <summary><h3>1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.</h3></summary>

  JVM (Java Virtual Machine) 이란?
JVM(Java Virtual Machine)은 자바 바이트코드(.class 파일)를 실행하는 가상 머신입니다. 특정 하드웨어나 운영체제에 종속되지 않고 자바 프로그램이 실행될 수 있도록 중간 다리 역할을 수행합니다.

JVM의 주요 기능
JVM은 다음과 같은 핵심적인 기능들을 수행합니다.

바이트코드 실행: 자바 컴파일러가 생성한 바이트코드를 읽어 해석하거나(Interpreter) 네이티브 코드로 변환하여(JIT Compiler) 실행합니다.
메모리 관리: 프로그램 실행에 필요한 메모리 영역을 할당하고 관리합니다. 특히, 더 이상 사용하지 않는 객체를 자동으로 회수하는 **가비지 컬렉션(Garbage Collection, GC)**을 수행하여 메모리 누수를 방지합니다.
클래스 로딩: 클래스 로더를 통해 자바 클래스(.class 파일)를 JVM 메모리 영역으로 로드하고, 링크 과정을 거쳐 사용할 수 있도록 준비합니다.
보안: 바이트코드 검증 과정을 통해 악의적인 코드가 실행되는 것을 방지하고, 보안 관리자를 통해 시스템 자원에 대한 접근 권한을 관리합니다.
네이티브 인터페이스 (JNI, Java Native Interface): 자바 코드에서 특정 운영체제의 기능이나 하드웨어 관련 라이브러리(네이티브 코드)를 호출할 수 있도록 지원합니다.
스레드 관리: 멀티스레드 환경에서 스레드를 생성하고 스케줄링하며, 스레드 간의 동기화 및 통신을 지원합니다.
JVM의 구조
JVM은 크게 다음과 같은 구성 요소로 이루어져 있습니다.

클래스 로더 (Class Loader Subsystem):
.class 파일을 읽어 JVM 내부의 런타임 데이터 영역으로 로드합니다.
로딩 (Loading): 클래스 파일을 읽어와 JVM의 메모리에 저장합니다.
링킹 (Linking): 로드된 클래스를 사용할 수 있도록 연결하는 과정입니다.
검증 (Verification): 바이트코드가 JVM 명세에 맞게 작성되었는지, 보안상 문제가 없는지 검사합니다.
준비 (Preparation): 클래스 변수를 위한 메모리를 할당하고 기본값으로 초기화합니다.
해석 (Resolution): 심볼릭 참조를 실제 메모리 주소로 변경합니다.
초기화 (Initialization): 클래스 변수를 명시적인 값으로 초기화하고, static 블록을 실행합니다.
런타임 데이터 영역 (Runtime Data Areas): JVM이 프로그램을 실행하면서 사용하는 다양한 데이터를 저장하는 메모리 영역입니다.
힙 (Heap): new 연산자로 생성된 객체와 배열이 저장되는 공간입니다. 가비지 컬렉션의 주요 대상입니다.
메서드 영역 (Method Area): 클래스 정보(이름, 필드, 메서드 등), 상수 풀(Constant Pool), static 변수 등이 저장되는 공간입니다.
JVM 스택 (JVM Stacks): 각 스레드마다 생성되는 스택으로, 메서드 호출과 관련된 정보(지역 변수, 매개변수, 리턴 주소 등)를 담고 있는 스택 프레임을 저장합니다.
네이티브 메서드 스택 (Native Method Stacks): 네이티브 메서드 실행을 위한 스택입니다.
PC 레지스터 (Program Counter Register): 각 스레드가 현재 실행할 JVM 명령어의 주소를 저장합니다.
실행 엔진 (Execution Engine): 로드된 바이트코드를 실제로 실행하는 역할을 담당합니다.
인터프리터 (Interpreter): 바이트코드를 한 줄씩 읽어와서 실행합니다.
JIT(Just-In-Time) 컴파일러: 자주 사용되는 바이트코드 블록을 네이티브 코드로 컴파일하여 실행 속도를 향상시킵니다.
가비지 컬렉터 (Garbage Collector): 더 이상 참조되지 않는 객체를 찾아 메모리에서 제거하는 역할을 수행합니다.
JVM은 자바의 **"Write Once, Run Anywhere" (한 번 작성하면 어디서든 실행된다)**라는 특징을 가능하게 하는 핵심적인 기술입니다. 개발자는 운영체제에 종속적인 코드를 작성할 필요 없이 JVM 위에서 실행될 수 있는 자바 코드를 작성하면 됩니다. 각 운영체제에 맞는 JVM만 설치되어 있다면 동일한 자바 프로그램을 실행할 수 있습니다.
<ul>
<li> 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?</li>
  네, 자바 외의 다른 언어들도 JVM 위에서 실행될 수 있습니다. 이러한 언어들을 JVM 언어라고 부릅니다. JVM은 특정 프로그래밍 언어에 종속적인 것이 아니라, 자바 바이트코드라는 특정 형식의 중간 코드를 이해하고 실행하는 가상 머신이기 때문입니다.

자바 바이트코드로 컴파일될 수 있는 언어라면 어떤 언어든지 JVM 위에서 실행될 수 있습니다. JVM 언어들은 자바 생태계의 강력한 라이브러리와 프레임워크를 그대로 활용할 수 있으며, 자바 코드와 상호 운용성도 뛰어납니다.

대표적인 JVM 언어:

Kotlin: 간결하고 현대적인 문법을 제공하며, 안드로이드 공식 언어로 지정되면서 많은 인기를 얻고 있습니다. 자바와 100% 호환됩니다.
Scala: 함수형 프로그래밍과 객체 지향 프로그래밍을 모두 지원하는 강력한 언어입니다. 간결한 문법과 높은 생산성을 제공하며, 빅데이터 처리 분야에서 많이 사용됩니다.
Groovy: 동적 타이핑을 지원하며, 스크립트 언어처럼 사용할 수 있습니다. 자바와의 호환성이 뛰어나며, 빌드 자동화 도구인 Gradle의 기본 언어로 사용됩니다.
Clojure: Lisp 방언 중 하나로, 함수형 프로그래밍에 특화된 언어입니다. 불변성, 동시성 처리 등에 강점을 가지고 있습니다.
JRuby: Ruby 언어의 JVM 구현체입니다. Ruby의 문법을 그대로 사용하면서 JVM의 기능을 활용할 수 있습니다.
Jython: Python 언어의 JVM 구현체입니다. Python 코드를 JVM 위에서 실행하고, 자바 라이브러리와의 연동을 지원합니다.

<li> 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?</li>
대부분의 JVM 계열 언어는 JVM 위에서 실행되는 것을 목표로 설계되었으며, 바이트코드라는 중간 단계를 거칩니다. 네이티브 코드로 직접 컴파일하는 것은 기술적으로 어렵거나 제한적이며, 일반적인 개발 및 배포 방식은 아닙니다. JVM의 장점(플랫폼 독립성, 메모리 관리 등)을 포기하면서 네이티브 컴파일을 시도하는 것은 대부분의 경우 효율적이지 않습니다.

<li> VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.</li>
VM(Virtual Machine) 사용의 장점과 단점
VM(Virtual Machine), 즉 가상 머신을 사용하는 것은 다양한 이점을 제공하지만, 동시에 몇 가지 단점도 존재합니다.

장점
플랫폼 독립성 (Platform Independence): VM은 호스트 운영체제와 독립적인 가상 환경을 제공합니다. 따라서 VM 내에서 실행되는 소프트웨어는 호스트 OS의 종류(Windows, macOS, Linux 등)에 관계없이 동일하게 작동할 수 있습니다. 이는 개발, 테스트 및 배포 환경을 일관성 있게 유지하는 데 매우 유용합니다.
자원 활용도 향상: 물리적 서버 한 대에 여러 개의 VM을 생성하여 각 VM에 필요한 만큼의 자원을 할당할 수 있습니다. 이를 통해 서버의 유휴 자원을 효율적으로 활용하고, 하드웨어 투자 비용을 절감할 수 있습니다.
유연성 및 확장성: 필요에 따라 VM의 사양(CPU, 메모리, 디스크 공간 등)을 쉽게 변경하거나 새로운 VM을 추가/삭제할 수 있습니다. 이는 시스템 요구 사항 변화에 빠르게 대응하고, 서비스 확장성을 높이는 데 도움이 됩니다.
격리 및 보안: 각 VM은 독립적인 환경에서 실행되므로, 하나의 VM에서 발생한 문제(오류, 보안 침해 등)가 다른 VM이나 호스트 시스템에 영향을 미치지 않습니다. 이는 시스템 안정성과 보안성을 향상시키는 데 기여합니다.
테스트 및 개발 환경 용이성: 다양한 운영체제 및 소프트웨어 구성을 가진 VM을 쉽게 생성하고 복제할 수 있어, 소프트웨어의 호환성 테스트나 개발 환경 구축에 매우 편리합니다. 또한, 문제가 발생했을 경우 스냅샷 기능을 이용하여 이전 상태로 빠르게 복원할 수 있습니다.
재해 복구 및 백업: VM 전체를 파일 형태로 백업하고 복제하는 것이 용이하므로, 시스템 장애 발생 시 빠르게 복구하거나 다른 환경으로 마이그레이션할 수 있습니다.
레거시 시스템 지원: 오래된 운영체제나 특정 환경에서만 작동하는 레거시 애플리케이션을 최신 호스트 OS 환경에서 VM을 통해 실행할 수 있습니다.
단점
성능 오버헤드 (Performance Overhead): VM은 호스트 OS 위에 추상화 계층을 추가하므로, VM 내에서 실행되는 애플리케이션은 물리적 환경에서 직접 실행되는 것보다 성능이 저하될 수 있습니다. 특히 CPU, 메모리, 디스크 I/O 등의 자원을 공유하는 경우 성능 저하가 더 두드러질 수 있습니다.
자원 소비: 각 VM은 자체적인 운영체제와 애플리케이션을 실행하기 위해 일정량의 시스템 자원(CPU, 메모리, 디스크 공간)을 소비합니다. 따라서 너무 많은 VM을 동시에 실행하면 호스트 시스템의 자원 부족으로 인해 전체적인 성능이 저하될 수 있습니다.
설정 및 관리 복잡성: 여러 개의 VM을 효율적으로 관리하고 운영하기 위해서는 전문적인 지식과 도구가 필요합니다. VM 생성, 설정, 모니터링, 보안 관리 등에 대한 추가적인 노력이 요구될 수 있습니다.
라이선스 비용: VM 내에서 실행되는 운영체제 및 소프트웨어에 대한 라이선스 비용이 추가적으로 발생할 수 있습니다.
호환성 문제 (드문 경우): 특정 하드웨어 기능이나 고급 운영체제 기능을 VM이 완벽하게 지원하지 못할 수 있습니다. 이는 특정 애플리케이션의 호환성 문제를 일으킬 수 있습니다.
결론적으로, VM은 다양한 이점을 제공하여 시스템 관리, 개발, 테스트 등 여러 분야에서 유용하게 활용될 수 있습니다. 하지만 성능 오버헤드, 자원 소비, 관리 복잡성 등의 단점도 고려해야 하며, 사용 목적과 환경에 따라 적절한 선택과 구성이 필요합니다.

<li> JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?</li>
일반적으로 JVM과 그 내부에서 실행되는 자바 프로그램 간의 관계를 엄밀하게 부모-자식 프로세스 관계라고 보기는 어렵습니다. 더 정확하게 설명하자면, JVM은 하나의 프로세스로 실행되며, 그 내부에서 여러 개의 스레드를 생성하고 관리하여 자바 프로그램을 실행합니다.

이유:

프로세스 vs. 스레드:

프로세스: 운영체제로부터 독립적인 메모리 공간과 자원을 할당받아 실행되는 독립적인 실행 단위입니다. 각 프로세스는 자신만의 주소 공간을 가지므로, 다른 프로세스의 메모리에 직접 접근할 수 없습니다.
스레드: 하나의 프로세스 내에서 실행되는 더 작은 실행 단위입니다. 스레드는 프로세스가 할당받은 메모리 공간을 공유하며, 동시에 여러 작업을 수행할 수 있습니다.
JVM의 작동 방식:

사용자가 자바 프로그램을 실행하면, 운영체제는 JVM 실행 파일을 로드하여 하나의 새로운 프로세스를 생성합니다. 이 JVM 프로세스는 자체적인 메모리 공간(힙, 스택 등)을 할당받습니다.
JVM 프로세스가 시작되면, 클래스 로더를 통해 필요한 클래스들을 메모리에 로드하고, 메인 스레드를 포함한 여러 개의 스레드를 생성합니다.
자바 프로그램의 코드는 이 JVM 프로세스 내에서 생성된 스레드들에 의해 실행됩니다.
따라서, 자바 프로그램 자체는 별도의 운영체제 프로세스로 실행되는 것이 아니라, 이미 실행 중인 JVM 프로세스 내의 여러 스레드들의 집합으로 볼 수 있습니다.

유사한 점:

물론, 비유적으로 보았을 때 몇 가지 유사한 점은 있을 수 있습니다.

생명 주기: JVM 프로세스가 종료되면 그 내부에서 실행 중이던 모든 스레드(자바 프로그램)도 함께 종료됩니다. 이는 부모 프로세스가 종료되면 자식 프로세스도 종료되는 것과 유사하게 보일 수 있습니다.
자원 관리: JVM 프로세스는 내부에서 실행되는 스레드들에게 메모리, CPU 시간 등의 자원을 할당하고 관리합니다. 이는 부모 프로세스가 자식 프로세스에게 일부 자원을 할당하는 것과 유사하게 생각될 수 있습니다.
결론:

엄밀한 의미에서 JVM과 내부에서 실행되는 자바 프로그램은 부모-자식 프로세스 관계가 아닌, 프로세스-스레드 관계를 갖습니다. JVM은 하나의 프로세스로 실행되고, 자바 프로그램은 그 JVM 프로세스 내에서 여러 개의 스레드로 실행되는 것입니다.

이러한 이해는 자바 프로그램의 동시성 모델, 메모리 관리, 프로세스 간 통신 등을 이해하는 데 중요합니다.

</ul>
</details>

<details>
  <summary><h3>2. final 키워드를 사용하면, 어떤 이점이 있나요?</h3></summary>

  final 키워드의 이점
1. 불변성 확보 및 객체의 안정성 향상 (변수)
기본 타입 변수: final로 선언된 기본 타입 변수는 최초 할당된 값을 변경할 수 없습니다. 이는 변수의 값이 프로그램 실행 도중 예기치 않게 바뀌는 것을 방지하여 코드의 안정성을 높이고, 예측 가능성을 향상시킵니다.
참조 타입 변수: final로 선언된 참조 타입 변수는 다른 객체를 참조하도록 변경할 수 없습니다. 즉, 변수가 가리키는 객체의 주소는 고정됩니다. 하지만, 그 객체 내부의 상태(필드 값)는 final로 선언되지 않았다면 변경될 수 있습니다.
쓰레드 안전성: 불변 객체는 여러 쓰레드에서 동시에 접근해도 데이터 경쟁(race condition)이 발생하지 않으므로, 쓰레드 안전한 코드를 작성하는 데 도움이 됩니다. final 참조 변수가 불변 객체를 가리키도록 하면, 별도의 동기화 처리 없이 안전하게 공유할 수 있습니다.
2. 메서드 오버라이딩 방지 (메서드)
final로 선언된 메서드는 하위 클래스에서 오버라이딩할 수 없습니다. 이는 다음과 같은 이점을 제공합니다.
설계 의도 보존: 상위 클래스에서 중요한 기능을 수행하거나 특정 방식으로 동작하도록 설계된 메서드의 구현이 하위 클래스에서 변경되는 것을 막아 설계 의도를 유지할 수 있습니다.
일관성 유지: 상위 클래스의 메서드 동작이 하위 클래스에서 다르게 구현되어 발생할 수 있는 예기치 않은 동작이나 오류를 방지하여 코드의 일관성을 유지합니다.
보안 강화: 보안과 관련된 중요한 메서드가 하위 클래스에서 악의적으로 오버라이딩되는 것을 방지하여 시스템의 보안을 강화할 수 있습니다.
3. 클래스 확장 방지 (클래스)
final로 선언된 클래스는 다른 클래스가 상속할 수 없습니다. 이는 다음과 같은 경우에 유용합니다.
불변 클래스: String, Math 클래스처럼 내부 상태가 변경될 수 없는 불변 클래스를 만들 때 final로 선언하여 의도치 않은 상속을 막고 불변성을 보장할 수 있습니다.
특정 구현 강제: 클래스의 구현이 더 이상 변경되거나 확장될 필요가 없다고 판단될 때 final로 선언하여 하위 클래스 생성을 방지하고 특정 구현을 강제할 수 있습니다.
성능 향상 가능성: 컴파일러가 final 클래스에 대한 추가적인 최적화를 수행할 수 있어, 미미하지만 성능 향상을 기대할 수 있습니다.
요약
final 키워드는 코드의 안정성, 예측 가능성, 보안성을 높이는 데 중요한 역할을 합니다. 변수를 불변으로 만들어 데이터의 무결성을 유지하고, 메서드 오버라이딩을 막아 설계 의도를 보존하며, 클래스 상속을 제한하여 특정 구현을 강제하는 등 다양한 이점을 제공합니다. 따라서 상황에 맞게 final 키워드를 적절히 사용하는 것은 좋은 프로그래밍 습관입니다.
<ul>
<li> 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?</li>

  컴파일러의 final 키워드 처리
1. 변수 (final 필드 및 지역 변수)
컴파일 타임 상수 처리: final로 선언된 기본 타입 변수가 컴파일 시점에 값이 확정될 수 있는 상수 표현식으로 초기화된 경우 (예: final int MAX_VALUE = 100;), 컴파일러는 이 변수를 컴파일 타임 상수로 취급합니다. 이는 다음과 같은 이점을 가집니다.
인라인 치환 (Inline Substitution): 해당 final 변수가 사용되는 모든 곳에서 컴파일러는 변수 이름 대신 직접 그 값을 사용할 수 있습니다. 이는 런타임에 변수 접근 과정을 생략하여 성능 향상에 미미하게 기여할 수 있습니다.
상수 풀 최적화: 컴파일러는 이러한 상수 값을 클래스 파일의 상수 풀에 저장하여 효율적으로 관리합니다.
불변성 검증: 컴파일러는 final 변수가 초기화된 후 다시 할당되는 코드가 있는지 검사합니다. 재할당 시 컴파일 에러를 발생시켜 final 변수의 불변성을 보장합니다.
Definite Assignment 분석: final 지역 변수의 경우, 컴파일러는 변수가 사용되기 전에 반드시 한 번 초기화되었는지 확인하는 Definite Assignment 분석을 수행합니다. 초기화되지 않은 final 지역 변수를 사용하려고 하면 컴파일 에러가 발생합니다.
2. 메서드 (final 메서드)
오버라이딩 방지: 컴파일러는 final 메서드가 하위 클래스에서 오버라이딩되는 코드를 발견하면 컴파일 에러를 발생시켜 메서드 오버라이딩을 금지합니다.
최적화 가능성 증대: final 메서드는 오버라이딩될 수 없다는 정보는 컴파일러에게 추가적인 최적화 기회를 제공할 수 있습니다. 예를 들어, 컴파일러는 final 메서드 호출을 인라인화하는 것을 더 적극적으로 고려할 수 있습니다. (실제 JVM의 JIT 컴파일러가 주로 수행하지만, 컴파일러도 힌트를 얻을 수 있습니다.)
3. 클래스 (final 클래스)
상속 방지: 컴파일러는 final 클래스를 상속하려는 시도가 있으면 컴파일 에러를 발생시켜 상속을 금지합니다.
최적화 가능성 증대: final 클래스는 더 이상 하위 클래스를 가질 수 없으므로, 컴파일러는 객체 생성 및 메서드 호출과 관련된 특정 최적화를 수행할 수 있습니다. 예를 들어, 가상 메서드 호출 대신 직접 메서드 호출로 대체하는 등의 최적화가 가능할 수 있습니다. (이 또한 주로 JIT 컴파일러의 영역이지만, 컴파일러도 정보를 활용할 수 있습니다.)
요약하자면, final 키워드는 컴파일러에게 다음과 같은 정보를 제공하고, 이를 통해 컴파일러는 다양한 검증과 최적화를 수행할 수 있습니다.

불변성 보장: 변수가 한 번 할당된 후 변경되지 않음을 컴파일러에게 알려주어 데이터의 안정성을 확보하고 잠재적인 버그를 방지합니다.
오버라이딩/상속 방지: 메서드나 클래스가 확장되지 않아야 하는 설계 의도를 컴파일러에게 명시적으로 전달하여 코드의 구조를 유지하고 예상치 못한 변경을 막습니다.
최적화 힌트 제공: 컴파일러에게 추가적인 정보를 제공하여 런타임 성능 향상을 위한 최적화(인라인 치환 등)를 수행할 수 있는 가능성을 열어줍니다.
따라서 final 키워드는 단순히 런타임 제약만을 제공하는 것이 아니라, 컴파일 단계에서부터 코드의 정확성, 안정성, 그리고 잠재적인 성능 향상에 기여하는 중요한 역할을 수행합니다.

</ul>
</details>

<details>
  <summary><h3>3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?</li>
</ul>
</details>

<details>
  <summary><h3>4. 리플렉션에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?</li>
<li> 리플렉션을 언제 활용할 수 있을까요?</li>
</ul>
</details>

<details>
  <summary><h3>5. static class와 static method를 비교해 주세요.</h3></summary>
<ul>
<li> static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?</li>
<li> 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>6. Java의 Exception에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 예외처리를 하는 세 방법에 대해 설명해 주세요.</li>
<li> CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.</li>
<li> 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?</li>
</ul>
</details>

<details>
  <summary><h3>7. Synchronized 키워드에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.</li>
<li> 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?</li>
<li> Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.</li>
<li> Thread Local에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>8. Java Stream에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Stream과 for ~ loop의 성능 차이를 비교해 주세요,</li>
<li> Stream은 병렬처리 할 수 있나요?</li>
<li> Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.</li>
<li> 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?</li>
</ul>
</details>

<details>
  <summary><h3>9. Java의 GC에 대해 설명해 주세요.</h3></summary>
<ul>
<li> finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?</li>
<li> 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?</li>
</ul>
</details>

<details>
  <summary><h3>10. equals()와 hashcode()에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?</li>
<li> 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>11. IoC와 DI에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 후보 없이 특정 기능을 하는 클래스가 딱 한 개하면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?</li>
<li> Spring의 Bean 생성 주기에 대해 설명해 주세요.</li>
<li> 프로토타입 빈은 무엇인가요?</li>
</ul>
</details>

<details>
  <summary><h3>12. AOP에 대해 설명해 주세요.</h3></summary>
<ul>
<li> @Aspect는 어떻게 동작하나요?</li>
</ul>
</details>

<details>
  <summary><h3>13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?</li>
</ul>
</details>

<details>
  <summary><h3>14. DispatcherServlet 의 역할에 대해 설명해 주세요.</h3></summary>
<ul>
<li>여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?</li>
<li>수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?</li>
</ul>
</details>

<details>
  <summary><h3>15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?</h3></summary>
<ul>
<li> 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?</li>
<li> N + 1 문제에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>16. @Transactional 은 어떤 기능을 하나요?</h3></summary>
<ul>
<li> @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?</li>
<li> 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?</li>
</ul>
</details>


<details>
  <summary><h3>17. Java 에서 Annotation 은 어떤 기능을 하나요?</h3></summary>
<ul>
<li> 별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?</li>
<li> Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?</li>
</ul>
</details>

<details>
  <summary><h3>18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?</h3></summary>
<ul>
<li> 혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?</li>
</ul>
</details>
